{"task_id": "HumanEval/0", "prompt": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n", "entry_point": "has_close_elements", "canonical_solution": "    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n"}
{"task_id": "HumanEval/1", "prompt": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n", "entry_point": "separate_paren_groups", "canonical_solution": "    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n"}
{"task_id": "HumanEval/2", "prompt": "\n\ndef truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n", "entry_point": "truncate_number", "canonical_solution": "    return number % 1.0\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n"}
{"task_id": "HumanEval/3", "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n", "entry_point": "below_zero", "canonical_solution": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n"}
{"task_id": "HumanEval/4", "prompt": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n", "entry_point": "mean_absolute_deviation", "canonical_solution": "    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6\n\n"}
{"task_id": "HumanEval/5", "prompt": "from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n", "entry_point": "intersperse", "canonical_solution": "    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n"}
{"task_id": "HumanEval/6", "prompt": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n", "entry_point": "parse_nested_parens", "canonical_solution": "    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n"}
{"task_id": "HumanEval/7", "prompt": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n", "entry_point": "filter_by_substring", "canonical_solution": "    return [x for x in strings if substring in x]\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n"}
{"task_id": "HumanEval/8", "prompt": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n", "entry_point": "sum_product", "canonical_solution": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n"}
{"task_id": "HumanEval/9", "prompt": "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n", "entry_point": "rolling_max", "canonical_solution": "    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n"}
{"task_id": "HumanEval/10", "prompt": "\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n", "entry_point": "make_palindrome", "canonical_solution": "    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n"}
{"task_id": "HumanEval/11", "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n", "entry_point": "string_xor", "canonical_solution": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n"}
{"task_id": "HumanEval/12", "prompt": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n", "entry_point": "longest", "canonical_solution": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n"}
{"task_id": "HumanEval/13", "prompt": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n", "entry_point": "greatest_common_divisor", "canonical_solution": "    while b:\n        a, b = b, a % b\n    return a\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n"}
{"task_id": "HumanEval/14", "prompt": "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n", "entry_point": "all_prefixes", "canonical_solution": "    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n"}
{"task_id": "HumanEval/15", "prompt": "\n\ndef string_sequence(n: int) -> str:\n    \"\"\" Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n", "entry_point": "string_sequence", "canonical_solution": "    return ' '.join([str(x) for x in range(n + 1)])\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n"}
{"task_id": "HumanEval/16", "prompt": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n", "entry_point": "count_distinct_characters", "canonical_solution": "    return len(set(string.lower()))\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n"}
{"task_id": "HumanEval/17", "prompt": "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n", "entry_point": "parse_music", "canonical_solution": "    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n"}
{"task_id": "HumanEval/18", "prompt": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n", "entry_point": "how_many_times", "canonical_solution": "    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n"}
{"task_id": "HumanEval/19", "prompt": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Input is a space-delimited string of numberals from 'zero' to 'nine'.\n    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n    Return the string with numbers sorted from smallest to largest\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n", "entry_point": "sort_numbers", "canonical_solution": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n"}
{"task_id": "HumanEval/20", "prompt": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n", "entry_point": "find_closest_elements", "canonical_solution": "    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n"}
{"task_id": "HumanEval/21", "prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n", "entry_point": "rescale_to_unit", "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n"}
{"task_id": "HumanEval/22", "prompt": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n", "entry_point": "filter_integers", "canonical_solution": "    return [x for x in values if isinstance(x, int)]\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n"}
{"task_id": "HumanEval/23", "prompt": "\n\ndef strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n", "entry_point": "strlen", "canonical_solution": "    return len(string)\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n"}
{"task_id": "HumanEval/24", "prompt": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n", "entry_point": "largest_divisor", "canonical_solution": "    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n"}
{"task_id": "HumanEval/25", "prompt": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n", "entry_point": "factorize", "canonical_solution": "    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n"}
{"task_id": "HumanEval/26", "prompt": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n", "entry_point": "remove_duplicates", "canonical_solution": "    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n"}
{"task_id": "HumanEval/27", "prompt": "\n\ndef flip_case(string: str) -> str:\n    \"\"\" For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n", "entry_point": "flip_case", "canonical_solution": "    return string.swapcase()\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n"}
{"task_id": "HumanEval/28", "prompt": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n", "entry_point": "concatenate", "canonical_solution": "    return ''.join(strings)\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n"}
{"task_id": "HumanEval/29", "prompt": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that start with a given prefix.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n", "entry_point": "filter_by_prefix", "canonical_solution": "    return [x for x in strings if x.startswith(prefix)]\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n"}
{"task_id": "HumanEval/30", "prompt": "\n\ndef get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n", "entry_point": "get_positive", "canonical_solution": "    return [e for e in l if e > 0]\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n"}
{"task_id": "HumanEval/31", "prompt": "\n\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n", "entry_point": "is_prime", "canonical_solution": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n"}
{"task_id": "HumanEval/32", "prompt": "import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n", "entry_point": "find_zero", "canonical_solution": "    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) / 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n"}
{"task_id": "HumanEval/33", "prompt": "\n\ndef sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n", "entry_point": "sort_third", "canonical_solution": "    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n"}
{"task_id": "HumanEval/34", "prompt": "\n\ndef unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n", "entry_point": "unique", "canonical_solution": "    return sorted(list(set(l)))\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n"}
{"task_id": "HumanEval/35", "prompt": "\n\ndef max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n", "entry_point": "max_element", "canonical_solution": "    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n"}
{"task_id": "HumanEval/36", "prompt": "\n\ndef fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n", "entry_point": "fizz_buzz", "canonical_solution": "    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n"}
{"task_id": "HumanEval/37", "prompt": "\n\ndef sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n", "entry_point": "sort_even", "canonical_solution": "    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n"}
{"task_id": "HumanEval/38", "prompt": "\n\ndef encode_cyclic(s: str):\n    \"\"\"\n    returns encoded string by cycling groups of three characters.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n", "entry_point": "decode_cyclic", "canonical_solution": "    return encode_cyclic(encode_cyclic(s))\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n"}
{"task_id": "HumanEval/39", "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n", "entry_point": "prime_fib", "canonical_solution": "    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n"}
{"task_id": "HumanEval/40", "prompt": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero takes a list of integers as an input.\n    it returns True if there are three distinct elements in the list that\n    sum to zero, and False otherwise.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n", "entry_point": "triples_sum_to_zero", "canonical_solution": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n"}
{"task_id": "HumanEval/41", "prompt": "\n\ndef car_race_collision(n: int):\n    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n    n cars are driving left to right;  simultaneously, a different set of n cars\n    are driving right to left.   The two sets of cars start out being very far from\n    each other.  All cars move in the same speed.  Two cars are said to collide\n    when a car that's moving left to right hits a car that's moving right to left.\n    However, the cars are infinitely sturdy and strong; as a result, they continue moving\n    in their trajectory as if they did not collide.\n\n    This function outputs the number of such collisions.\n    \"\"\"\n", "entry_point": "car_race_collision", "canonical_solution": "    return n**2\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n"}
{"task_id": "HumanEval/42", "prompt": "\n\ndef incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n", "entry_point": "incr_list", "canonical_solution": "    return [(e + 1) for e in l]\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n"}
{"task_id": "HumanEval/43", "prompt": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero takes a list of integers as an input.\n    it returns True if there are two distinct elements in the list that\n    sum to zero, and False otherwise.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n", "entry_point": "pairs_sum_to_zero", "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n"}
{"task_id": "HumanEval/44", "prompt": "\n\ndef change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"\n", "entry_point": "change_base", "canonical_solution": "    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x //= base\n    return ret\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n"}
{"task_id": "HumanEval/45", "prompt": "\n\ndef triangle_area(a, h):\n    \"\"\"Given length of a side and high return area for a triangle.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n", "entry_point": "triangle_area", "canonical_solution": "    return a * h / 2.0\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n"}
{"task_id": "HumanEval/46", "prompt": "\n\ndef fib4(n: int):\n    \"\"\"The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n", "entry_point": "fib4", "canonical_solution": "    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n"}
{"task_id": "HumanEval/47", "prompt": "\n\ndef median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n", "entry_point": "median", "canonical_solution": "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n"}
{"task_id": "HumanEval/48", "prompt": "\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Checks if given string is a palindrome\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n", "entry_point": "is_palindrome", "canonical_solution": "    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n"}
{"task_id": "HumanEval/49", "prompt": "\n\ndef modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n", "entry_point": "modp", "canonical_solution": "    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n"}
{"task_id": "HumanEval/50", "prompt": "\n\ndef encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n", "entry_point": "decode_shift", "canonical_solution": "    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n"}
{"task_id": "HumanEval/51", "prompt": "\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n", "entry_point": "remove_vowels", "canonical_solution": "    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n"}
{"task_id": "HumanEval/52", "prompt": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Return True if all numbers in the list l are below threshold t.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n", "entry_point": "below_threshold", "canonical_solution": "    for e in l:\n        if e >= t:\n            return False\n    return True\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n"}
{"task_id": "HumanEval/53", "prompt": "\n\ndef add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n", "entry_point": "add", "canonical_solution": "    return x + y\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n"}
{"task_id": "HumanEval/54", "prompt": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n", "entry_point": "same_chars", "canonical_solution": "    return set(s0) == set(s1)\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n"}
{"task_id": "HumanEval/55", "prompt": "\n\ndef fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n", "entry_point": "fib", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n"}
{"task_id": "HumanEval/56", "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n", "entry_point": "correct_bracketing", "canonical_solution": "    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n"}
{"task_id": "HumanEval/57", "prompt": "\n\ndef monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n", "entry_point": "monotonic", "canonical_solution": "    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n"}
{"task_id": "HumanEval/58", "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n", "entry_point": "common", "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n"}
{"task_id": "HumanEval/59", "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n", "entry_point": "largest_prime_factor", "canonical_solution": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n"}
{"task_id": "HumanEval/60", "prompt": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n is a function that sums numbers from 1 to n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n", "entry_point": "sum_to_n", "canonical_solution": "    return sum(range(n + 1))\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n"}
{"task_id": "HumanEval/61", "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"\n", "entry_point": "correct_bracketing", "canonical_solution": "    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n"}
{"task_id": "HumanEval/62", "prompt": "\n\ndef derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n", "entry_point": "derivative", "canonical_solution": "    return [(i * x) for i, x in enumerate(xs)][1:]\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n"}
{"task_id": "HumanEval/63", "prompt": "\n\ndef fibfib(n: int):\n    \"\"\"The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n", "entry_point": "fibfib", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n"}
{"task_id": "HumanEval/64", "prompt": "\nFIX = \"\"\"\nAdd more test cases.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n", "entry_point": "vowels_count", "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/65", "prompt": "\ndef circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"\n", "entry_point": "circular_shift", "canonical_solution": "    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/66", "prompt": "\ndef digitSum(s):\n    \"\"\"Task\n    Write a function that takes a string as input and returns the sum of the upper characters only'\n    ASCII codes.\n\n    Examples:\n        digitSum(\"\") => 0\n        digitSum(\"abAB\") => 131\n        digitSum(\"abcCd\") => 67\n        digitSum(\"helloE\") => 69\n        digitSum(\"woArBld\") => 131\n        digitSum(\"aAaaaXa\") => 153\n    \"\"\"\n", "entry_point": "digitSum", "canonical_solution": "    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n"}
{"task_id": "HumanEval/67", "prompt": "\ndef fruit_distribution(s,n):\n    \"\"\"\n    In this task, you will be given a string that represents a number of apples and oranges \n    that are distributed in a basket of fruit this basket contains \n    apples, oranges, and mango fruits. Given the string that represents the total number of \n    the oranges and apples and an integer that represent the total number of the fruits \n    in the basket return the number of the mango fruits in the basket.\n    for examble:\n    fruit_distribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n    fruit_distribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n    fruit_distribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n    fruit_distribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n    \"\"\"\n", "entry_point": "fruit_distribution", "canonical_solution": "    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n"}
{"task_id": "HumanEval/68", "prompt": "\ndef pluck(arr):\n    \"\"\"\n    \"Given an array representing a branch of a tree that has non-negative integer nodes\n    your task is to pluck one of the nodes and return it.\n    The plucked node should be the node with the smallest even value.\n    If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n    The plucked node should be returned in a list, [ smalest_value, its index ],\n    If there are no even values or the given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n                     so we will choose the first zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \"\"\"\n", "entry_point": "pluck", "canonical_solution": "    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n"}
{"task_id": "HumanEval/69", "prompt": "\ndef search(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n", "entry_point": "search", "canonical_solution": "    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n", "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n"}
{"task_id": "HumanEval/70", "prompt": "\ndef strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n", "entry_point": "strange_sort_list", "canonical_solution": "    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"task_id": "HumanEval/71", "prompt": "\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n", "entry_point": "triangle_area", "canonical_solution": "    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n"}
{"task_id": "HumanEval/72", "prompt": "\ndef will_it_fly(q,w):\n    '''\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) \u279e False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u279e False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u279e True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) \u279e True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    '''\n", "entry_point": "will_it_fly", "canonical_solution": "    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n"}
{"task_id": "HumanEval/73", "prompt": "\ndef smallest_change(arr):\n    \"\"\"\n    Given an array arr of integers, find the minimum number of elements that\n    need to be changed to make the array palindromic. A palindromic array is an array that\n    is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n", "entry_point": "smallest_change", "canonical_solution": "    ans = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n"}
{"task_id": "HumanEval/74", "prompt": "\ndef total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n", "entry_point": "total_match", "canonical_solution": "    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n"}
{"task_id": "HumanEval/75", "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less then 100. \n    Example:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n", "entry_point": "is_multiply_prime", "canonical_solution": "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n", "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n"}
{"task_id": "HumanEval/76", "prompt": "\ndef is_simple_power(x, n):\n    \"\"\"Your task is to write a function that returns true if a number x is a simple\n    power of n and false in other cases.\n    x is a simple power of n if n**int=x\n    For example:\n    is_simple_power(1, 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) => true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n    is_simple_power(5, 3) => false\n    \"\"\"\n", "entry_point": "is_simple_power", "canonical_solution": "    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/77", "prompt": "\ndef iscube(a):\n    '''\n    Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n", "entry_point": "iscube", "canonical_solution": "    a = abs(a)\n    return int(round(a ** (1. / 3))) ** 3 == a\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n"}
{"task_id": "HumanEval/78", "prompt": "\ndef hex_key(num):\n    \"\"\"You have been tasked to write a function that receives \n    a hexadecimal number as a string and counts the number of hexadecimal \n    digits that are primes (prime number, or a prime, is a natural number \n    greater than 1 that is not a product of two smaller natural numbers).\n    Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    So you have to determine a number of the following digits: 2, 3, 5, 7, \n    B (=decimal 11), D (=decimal 13).\n    Note: you may assume the input is always correct or empty string, \n    and symbols A,B,C,D,E,F are always uppercase.\n    Examples:\n    For num = \"AB\" the output should be 1.\n    For num = \"1077E\" the output should be 2.\n    For num = \"ABED1A33\" the output should be 4.\n    For num = \"123456789ABCDEF0\" the output should be 6.\n    For num = \"2020\" the output should be 2.\n    \"\"\"\n", "entry_point": "hex_key", "canonical_solution": "    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n"}
{"task_id": "HumanEval/79", "prompt": "\ndef decimal_to_binary(decimal):\n    \"\"\"You will be given a number in decimal form and your task is to convert it to\n    binary format. The function should return a string, with each character representing a binary\n    number. Each character in the string will be '0' or '1'.\n\n    There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    The extra characters are there to help with the format.\n\n    Examples:\n    decimal_to_binary(15)   # returns \"db1111db\"\n    decimal_to_binary(32)   # returns \"db100000db\"\n    \"\"\"\n", "entry_point": "decimal_to_binary", "canonical_solution": "    return \"db\" + bin(decimal)[2:] + \"db\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/80", "prompt": "\ndef is_happy(s):\n    \"\"\"You are given a string s.\n    Your task is to check if the string is happy or not.\n    A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n    For example:\n    is_happy(a) => False\n    is_happy(aa) => False\n    is_happy(abcd) => True\n    is_happy(aabb) => False\n    is_happy(adb) => True\n    is_happy(xyy) => False\n    \"\"\"\n", "entry_point": "is_happy", "canonical_solution": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n"}
{"task_id": "HumanEval/81", "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"It is the last week of the semester and the teacher has to give the grades\n    to students. The teacher has been making her own algorithm for grading.\n    The only problem is, she has lost the code she used for grading.\n    She has given you a list of GPAs for some students and you have to write \n    a function that can output a list of letter grades using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    Example:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n", "entry_point": "numerical_letter_grade", "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"task_id": "HumanEval/82", "prompt": "\ndef prime_length(string):\n    \"\"\"Write a function that takes a string and returns True if the string\n    length is a prime number or False otherwise\n    Examples\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n", "entry_point": "prime_length", "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n"}
{"task_id": "HumanEval/83", "prompt": "\ndef starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\n", "entry_point": "starts_one_ends", "canonical_solution": "    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/84", "prompt": "\ndef solve(N):\n    \"\"\"Given a positive integer N, return the total sum of its digits in binary.\n    \n    Example\n        For N = 1000, the sum of digits will be 1 the output should be \"1\".\n        For N = 150, the sum of digits will be 6 the output should be \"110\".\n        For N = 147, the sum of digits will be 12 the output should be \"1100\".\n    \n    Variables:\n        @N integer\n             Constraints: 0 \u2264 N \u2264 10000.\n    Output:\n         a string of binary number\n    \"\"\"\n", "entry_point": "solve", "canonical_solution": "    return bin(sum(int(i) for i in str(N)))[2:]\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n"}
{"task_id": "HumanEval/85", "prompt": "\ndef add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n", "entry_point": "add", "canonical_solution": "    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n"}
{"task_id": "HumanEval/86", "prompt": "\ndef anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n", "entry_point": "anti_shuffle", "canonical_solution": "    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"task_id": "HumanEval/87", "prompt": "\ndef get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n", "entry_point": "get_row", "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"task_id": "HumanEval/88", "prompt": "\ndef sort_array(array):\n    \"\"\"\n    Given an array of non-negative integers, return a copy of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \"\"\"\n", "entry_point": "sort_array", "canonical_solution": "    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n"}
{"task_id": "HumanEval/89", "prompt": "\ndef encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n", "entry_point": "encrypt", "canonical_solution": "    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/90", "prompt": "\ndef next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n", "entry_point": "next_smallest", "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"task_id": "HumanEval/91", "prompt": "\ndef is_bored(S):\n    \"\"\"\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word \"I\".\n    Sentences are delimited by '.', '?' or '!'.\n   \n    For example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n", "entry_point": "is_bored", "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/92", "prompt": "\ndef any_int(x, y, z):\n    '''\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n    \n    Examples\n    any_int(5, 2, 7) \u279e True\n    \n    any_int(3, 2, 2) \u279e False\n\n    any_int(3, -2, 1) \u279e True\n    \n    any_int(3.6, -2.2, 2) \u279e False\n  \n\n    \n    '''\n", "entry_point": "any_int", "canonical_solution": "    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/93", "prompt": "\ndef encode(message):\n    \"\"\"\n    Write a function that takes a message, and encodes in such a \n    way that it swaps case of all letters, replaces all vowels in \n    the message with the letter that appears 2 places ahead of that \n    vowel in the english alphabet. \n    Assume only letters. \n    \n    Examples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n", "entry_point": "encode", "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/94", "prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n", "entry_point": "skjkasdkd", "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n"}
{"task_id": "HumanEval/95", "prompt": "\ndef check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n", "entry_point": "check_dict_case", "canonical_solution": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n"}
{"task_id": "HumanEval/96", "prompt": "\ndef count_up_to(n):\n    \"\"\"Implement a function that takes an non-negative integer and returns an array of the first n\n    integers that are prime numbers and less than n.\n    for example:\n    count_up_to(5) => [2,3]\n    count_up_to(11) => [2,3,5,7]\n    count_up_to(0) => []\n    count_up_to(20) => [2,3,5,7,11,13,17,19]\n    count_up_to(1) => []\n    count_up_to(18) => [2,3,5,7,11,13,17]\n    \"\"\"\n", "entry_point": "count_up_to", "canonical_solution": "    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n", "test": "def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n"}
{"task_id": "HumanEval/97", "prompt": "\ndef multiply(a, b):\n    \"\"\"Complete the function that takes two integers and returns \n    the product of their unit digits.\n    Assume the input is always valid.\n    Examples:\n    multiply(148, 412) should return 16.\n    multiply(19, 28) should return 72.\n    multiply(2020, 1851) should return 0.\n    multiply(14,-15) should return 20.\n    \"\"\"\n", "entry_point": "multiply", "canonical_solution": "    return abs(a % 10) * abs(b % 10)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n"}
{"task_id": "HumanEval/98", "prompt": "\ndef count_upper(s):\n    \"\"\"\n    Given a string s, count the number of uppercase vowels in even indices.\n    \n    For example:\n    count_upper('aBCdEf') returns 1\n    count_upper('abcdefg') returns 0\n    count_upper('dBBE') returns 0\n    \"\"\"\n", "entry_point": "count_upper", "canonical_solution": "    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"task_id": "HumanEval/99", "prompt": "\ndef closest_integer(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n", "entry_point": "closest_integer", "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n"}
{"task_id": "HumanEval/100", "prompt": "\ndef make_a_pile(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n", "entry_point": "make_a_pile", "canonical_solution": "    return [n + 2*i for i in range(n)]\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/101", "prompt": "\ndef words_string(s):\n    \"\"\"\n    You will be given a string of words separated by commas or spaces. Your task is\n    to split the string into words and return an array of the words.\n    \n    For example:\n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n", "entry_point": "words_string", "canonical_solution": "    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n"}
{"task_id": "HumanEval/102", "prompt": "\ndef choose_num(x, y):\n    \"\"\"This function takes two positive numbers x and y and returns the\n    biggest even integer number that is in the range [x, y] inclusive. If \n    there's no such number, then the function should return -1.\n\n    For example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"\n", "entry_point": "choose_num", "canonical_solution": "    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n"}
{"task_id": "HumanEval/103", "prompt": "\ndef rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n", "entry_point": "rounded_avg", "canonical_solution": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n"}
{"task_id": "HumanEval/104", "prompt": "\ndef unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n", "entry_point": "unique_digits", "canonical_solution": "    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"task_id": "HumanEval/105", "prompt": "\ndef by_length(arr):\n    \"\"\"\n    Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n    \n      If the array is empty, return an empty array:\n      arr = []\n      return []\n    \n      If the array has any strange number ignore it:\n      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n            -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\n", "entry_point": "by_length", "canonical_solution": "    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n"}
{"task_id": "HumanEval/106", "prompt": "\ndef f(n):\n    \"\"\" Implement the function f that takes n as a parameter,\n    and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n    or the sum of numbers from 1 to i otherwise.\n    i starts from 1.\n    the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n    Example:\n    f(5) == [1, 2, 6, 24, 15]\n    \"\"\"\n", "entry_point": "f", "canonical_solution": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n", "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n"}
{"task_id": "HumanEval/107", "prompt": "\ndef even_odd_palindrome(n):\n    \"\"\"\n    Given a positive integer n, return a tuple that has the number of even and odd\n    integer palindromes that fall within the range(1, n), inclusive.\n\n    Example 1:\n\n        Input: 3\n        Output: (1, 2)\n        Explanation:\n        Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n    Example 2:\n\n        Input: 12\n        Output: (4, 6)\n        Explanation:\n        Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n    Note:\n        1. 1 <= n <= 10^3\n        2. returned tuple has the number of even and odd integer palindromes respectively.\n    \"\"\"\n", "entry_point": "even_odd_palindrome", "canonical_solution": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/108", "prompt": "\ndef count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n", "entry_point": "count_nums", "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/109", "prompt": "\ndef move_one_ball(arr):\n    \"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return True else return False.\n    If the given array is empty then return True.\n\n    Note: The given list is guaranteed to have unique elements.\n\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \"\"\"\n", "entry_point": "move_one_ball", "canonical_solution": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n"}
{"task_id": "HumanEval/110", "prompt": "\ndef exchange(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n", "entry_point": "exchange", "canonical_solution": "    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n"}
{"task_id": "HumanEval/111", "prompt": "\ndef histogram(test):\n    \"\"\"Given a string representing a space separated lowercase letters, return a dictionary\n    of the letter with the most repetition and containing the corresponding count.\n    If several letters have the same occurrence, return all of them.\n    \n    Example:\n    histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n    histogram('a b b a') == {'a': 2, 'b': 2}\n    histogram('a b c a b') == {'a': 2, 'b': 2}\n    histogram('b b b b a') == {'b': 4}\n    histogram('') == {}\n\n    \"\"\"\n", "entry_point": "histogram", "canonical_solution": "    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/112", "prompt": "\ndef reverse_delete(s,c):\n    \"\"\"Task\n    We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n    then check if the result string is palindrome.\n    A string is called palindrome if it reads the same backward as forward.\n    You should return a tuple containing the result string and True/False for the check.\n    Example\n    For s = \"abcde\", c = \"ae\", the result should be ('bcd',False)\n    For s = \"abcdef\", c = \"b\"  the result should be ('acdef',False)\n    For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',True)\n    \"\"\"\n", "entry_point": "reverse_delete", "canonical_solution": "    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n", "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n"}
{"task_id": "HumanEval/113", "prompt": "\ndef odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n", "entry_point": "odd_count", "canonical_solution": "    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/114", "prompt": "\ndef minSubArraySum(nums):\n    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array\n    of nums.\n    Example\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n", "entry_point": "minSubArraySum", "canonical_solution": "    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n"}
{"task_id": "HumanEval/115", "prompt": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    You are given a rectangular grid of wells. Each row represents a single well,\n    and each 1 in a row represents a single unit of water.\n    Each well has a corresponding bucket that can be used to extract water from it, \n    and all buckets have the same capacity.\n    Your task is to use the buckets to empty the wells.\n    Output the number of times you need to lower the buckets.\n\n    Example 1:\n        Input: \n            grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output: 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n        * all wells have the same length\n        * 1 <= grid.length <= 10^2\n        * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= capacity <= 10\n    \"\"\"\n", "entry_point": "max_fill", "canonical_solution": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n", "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n"}
{"task_id": "HumanEval/116", "prompt": "\ndef sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n", "entry_point": "sort_array", "canonical_solution": "    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/117", "prompt": "\ndef select_words(s, n):\n    \"\"\"Given a string s and a natural number n, you have been tasked to implement \n    a function that returns a list of all words from string s that contain exactly \n    n consonants, in order these words appear in the string s.\n    If the string s is empty then the function should return an empty list.\n    Note: you may assume the input string contains only letters and spaces.\n    Examples:\n    select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n    select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n    select_words(\"simple white space\", 2) ==> []\n    select_words(\"Hello world\", 4) ==> [\"world\"]\n    select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n    \"\"\"\n", "entry_point": "select_words", "canonical_solution": "    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n"}
{"task_id": "HumanEval/118", "prompt": "\ndef get_closest_vowel(word):\n    \"\"\"You are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"\n", "entry_point": "get_closest_vowel", "canonical_solution": "    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"task_id": "HumanEval/119", "prompt": "\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n", "entry_point": "match_parens", "canonical_solution": "    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n"}
{"task_id": "HumanEval/120", "prompt": "\ndef maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n", "entry_point": "maximum", "canonical_solution": "    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n"}
{"task_id": "HumanEval/121", "prompt": "\ndef solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n", "entry_point": "solution", "canonical_solution": "    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n"}
{"task_id": "HumanEval/122", "prompt": "\ndef add_elements(arr, k):\n    \"\"\"\n    Given a non-empty array of integers arr and an integer k, return\n    the sum of the elements with at most two digits from the first k elements of arr.\n\n    Example:\n\n        Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Output: 24 # sum of 21 + 3\n\n    Constraints:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n    \"\"\"\n", "entry_point": "add_elements", "canonical_solution": "    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/123", "prompt": "\ndef get_odd_collatz(n):\n    \"\"\"\n    Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n    as follows: start with any positive integer n. Then each term is obtained from the \n    previous term as follows: if the previous term is even, the next term is one half of \n    the previous term. If the previous term is odd, the next term is 3 times the previous\n    term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n        2. returned list sorted in increasing order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\n", "entry_point": "get_odd_collatz", "canonical_solution": "    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/124", "prompt": "\ndef valid_date(date):\n    \"\"\"You have to write a function which validates a given date string and\n    returns True if the date is valid otherwise False.\n    The date is valid if all of the following rules are satisfied:\n    1. The date string is not empty.\n    2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n    3. The months should not be less than 1 or higher than 12.\n    4. The date should be in the format: mm-dd-yyyy\n\n    for example: \n    valid_date('03-11-2000') => True\n\n    valid_date('15-01-2012') => False\n\n    valid_date('04-0-2040') => False\n\n    valid_date('06-04-2020') => True\n\n    valid_date('06/04/2020') => False\n    \"\"\"\n", "entry_point": "valid_date", "canonical_solution": "    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n"}
{"task_id": "HumanEval/125", "prompt": "\ndef split_words(txt):\n    '''\n    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n    split_words(\"Hello world!\") \u279e [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") \u279e [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''\n", "entry_point": "split_words", "canonical_solution": "    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n", "test": "def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n"}
{"task_id": "HumanEval/126", "prompt": "\ndef is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted([5]) \u279e True\n    is_sorted([1, 2, 3, 4, 5]) \u279e True\n    is_sorted([1, 3, 2, 4, 5]) \u279e False\n    is_sorted([1, 2, 3, 4, 5, 6]) \u279e True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279e True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) \u279e False\n    is_sorted([1, 2, 2, 3, 3, 4]) \u279e True\n    is_sorted([1, 2, 2, 2, 3, 4]) \u279e False\n    '''\n", "entry_point": "is_sorted", "canonical_solution": "    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n"}
{"task_id": "HumanEval/127", "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"You are given two intervals,\n    where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n    The given intervals are closed which means that the interval (start, end)\n    includes both start and end.\n    For each given interval, it is assumed that its start is less or equal its end.\n    Your task is to determine whether the length of intersection of these two \n    intervals is a prime number.\n    Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n    which its length is 1, which not a prime number.\n    If the length of the intersection is a prime number, return \"YES\",\n    otherwise, return \"NO\".\n    If the two intervals don't intersect, return \"NO\".\n\n\n    [input/output] samples:\n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"\n", "entry_point": "intersection", "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n"}
{"task_id": "HumanEval/128", "prompt": "\ndef prod_signs(arr):\n    \"\"\"\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\n", "entry_point": "prod_signs", "canonical_solution": "    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/129", "prompt": "\ndef minPath(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"\n", "entry_point": "minPath", "canonical_solution": "    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n"}
{"task_id": "HumanEval/130", "prompt": "\ndef tri(n):\n    \"\"\"Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    tri(3) = [1, 3, 2, 8]\n    \"\"\"\n", "entry_point": "tri", "canonical_solution": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n"}
{"task_id": "HumanEval/131", "prompt": "\ndef digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\"\n", "entry_point": "digits", "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n"}
{"task_id": "HumanEval/132", "prompt": "\ndef is_nested(string):\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]') \u279e True\n    is_nested('[]]]]]]][[[[[]') \u279e False\n    is_nested('[][]') \u279e False\n    is_nested('[]') \u279e False\n    is_nested('[[][]]') \u279e True\n    is_nested('[[]][[') \u279e True\n    '''\n", "entry_point": "is_nested", "canonical_solution": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n"}
{"task_id": "HumanEval/133", "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"You are given a list of numbers.\n    You need to return the sum of squared numbers in the given list,\n    round each element in the list to the upper int(Ceiling) first.\n    Examples:\n    For lst = [1,2,3] the output should be 14\n    For lst = [1,4,9] the output should be 98\n    For lst = [1,3,5,7] the output should be 84\n    For lst = [1.4,4.2,0] the output should be 29\n    For lst = [-2.4,1,1] the output should be 6\n    \n\n    \"\"\"\n", "entry_point": "sum_squares", "canonical_solution": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/134", "prompt": "\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") \u279e False\n    check_if_last_char_is_a_letter(\"apple pi e\") \u279e True\n    check_if_last_char_is_a_letter(\"apple pi e \") \u279e False\n    check_if_last_char_is_a_letter(\"\") \u279e False \n    '''\n", "entry_point": "check_if_last_char_is_a_letter", "canonical_solution": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"task_id": "HumanEval/135", "prompt": "\ndef can_arrange(arr):\n    \"\"\"Create a function which returns the largest index of an element which\n    is not greater than or equal to the element immediately preceding it. If\n    no such element exists then return -1. The given array will not contain\n    duplicate values.\n\n    Examples:\n    can_arrange([1,2,4,3,5]) = 3\n    can_arrange([1,2,3]) = -1\n    \"\"\"\n", "entry_point": "can_arrange", "canonical_solution": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n"}
{"task_id": "HumanEval/136", "prompt": "\ndef largest_smallest_integers(lst):\n    '''\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n", "entry_point": "largest_smallest_integers", "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n"}
{"task_id": "HumanEval/137", "prompt": "\ndef compare_one(a, b):\n    \"\"\"\n    Create a function that takes integers, floats, or strings representing\n    real numbers, and returns the larger variable in its given variable type.\n    Return None if the values are equal.\n    Note: If a real number is represented as a string, the floating point might be . or ,\n\n    compare_one(1, 2.5) \u279e 2.5\n    compare_one(1, \"2,3\") \u279e \"2,3\"\n    compare_one(\"5,1\", \"6\") \u279e \"6\"\n    compare_one(\"1\", 1) \u279e None\n    \"\"\"\n", "entry_point": "compare_one", "canonical_solution": "    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"task_id": "HumanEval/138", "prompt": "\ndef is_equal_to_sum_even(n):\n    \"\"\"Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n    Example\n    is_equal_to_sum_even(4) == False\n    is_equal_to_sum_even(6) == False\n    is_equal_to_sum_even(8) == True\n    \"\"\"\n", "entry_point": "is_equal_to_sum_even", "canonical_solution": "    return n%2 == 0 and n >= 8\n", "test": "def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n"}
{"task_id": "HumanEval/139", "prompt": "\ndef special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n", "entry_point": "special_factorial", "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n"}
{"task_id": "HumanEval/140", "prompt": "\ndef fix_spaces(text):\n    \"\"\"\n    Given a string text, replace all spaces in it with underscores, \n    and if a string has more than 2 consecutive spaces, \n    then replace all consecutive spaces with - \n    \n    fix_spaces(\"Example\") == \"Example\"\n    fix_spaces(\"Example 1\") == \"Example_1\"\n    fix_spaces(\" Example 2\") == \"_Example_2\"\n    fix_spaces(\" Example   3\") == \"_Example-3\"\n    \"\"\"\n", "entry_point": "fix_spaces", "canonical_solution": "    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n"}
{"task_id": "HumanEval/141", "prompt": "\ndef file_name_check(file_name):\n    \"\"\"Create a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\") # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n    \"\"\"\n", "entry_point": "file_name_check", "canonical_solution": "    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n"}
{"task_id": "HumanEval/142", "prompt": "\n\n\ndef sum_squares(lst):\n    \"\"\"\"\n    This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n    multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n    change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n    \n    Examples:\n    For lst = [1,2,3] the output should be 6\n    For lst = []  the output should be 0\n    For lst = [-1,-5,2,-1,-5]  the output should be -126\n    \"\"\"\n", "entry_point": "sum_squares", "canonical_solution": "    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n"}
{"task_id": "HumanEval/143", "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"\n    You are given a string representing a sentence,\n    the sentence contains some words separated by a space,\n    and you have to return a string that contains the words from the original sentence,\n    whose lengths are prime numbers,\n    the order of the words in the new string should be the same as the original one.\n\n    Example 1:\n        Input: sentence = \"This is a test\"\n        Output: \"is\"\n\n    Example 2:\n        Input: sentence = \"lets go for swimming\"\n        Output: \"go for\"\n\n    Constraints:\n        * 1 <= len(sentence) <= 100\n        * sentence contains only letters\n    \"\"\"\n", "entry_point": "words_in_sentence", "canonical_solution": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n"}
{"task_id": "HumanEval/144", "prompt": "\ndef simplify(x, n):\n    \"\"\"Your task is to implement a function that will simplify the expression\n    x * n. The function returns True if x * n evaluates to a whole number and False\n    otherwise. Both x and n, are string representation of a fraction, and have the following format,\n    <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n    You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n    simplify(\"1/5\", \"5/1\") = True\n    simplify(\"1/6\", \"2/1\") = False\n    simplify(\"7/10\", \"10/2\") = False\n    \"\"\"\n", "entry_point": "simplify", "canonical_solution": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n"}
{"task_id": "HumanEval/145", "prompt": "\ndef order_by_points(nums):\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n", "entry_point": "order_by_points", "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/146", "prompt": "\ndef specialFilter(nums):\n    \"\"\"Write a function that takes an array of numbers as input and returns \n    the number of elements in the array that are greater than 10 and both \n    first and last digits of a number are odd (1, 3, 5, 7, 9).\n    For example:\n    specialFilter([15, -73, 14, -15]) => 1 \n    specialFilter([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"\n", "entry_point": "specialFilter", "canonical_solution": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n"}
{"task_id": "HumanEval/147", "prompt": "\ndef get_max_triples(n):\n    \"\"\"\n    You are given a positive integer n. You have to create an integer array a of length n.\n        For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n        Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n    and a[i] + a[j] + a[k] is a multiple of 3.\n\n    Example :\n        Input: n = 5\n        Output: 1\n        Explanation: \n        a = [1, 3, 7, 13, 21]\n        The only valid triple is (1, 7, 13).\n    \"\"\"\n", "entry_point": "get_max_triples", "canonical_solution": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n", "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n"}
{"task_id": "HumanEval/148", "prompt": "\ndef bf(planet1, planet2):\n    '''\n    There are eight planets in our solar system: the closerst to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n", "entry_point": "bf", "canonical_solution": "    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n"}
{"task_id": "HumanEval/149", "prompt": "\ndef sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n", "entry_point": "sorted_list_sum", "canonical_solution": "    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n"}
{"task_id": "HumanEval/150", "prompt": "\ndef x_or_y(n, x, y):\n    \"\"\"A simple program which should return the value of x if n is \n    a prime number and should return the value of y otherwise.\n\n    Examples:\n    for x_or_y(7, 34, 12) == 34\n    for x_or_y(15, 8, 5) == 5\n    \n    \"\"\"\n", "entry_point": "x_or_y", "canonical_solution": "    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n"}
{"task_id": "HumanEval/151", "prompt": "\ndef double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n", "entry_point": "double_the_difference", "canonical_solution": "    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n"}
{"task_id": "HumanEval/152", "prompt": "\ndef compare(game,guess):\n    \"\"\"I think we all remember that feeling when the result of some long-awaited\n    event is finally known. The feelings and thoughts you have at that moment are\n    definitely worth noting down and comparing.\n    Your task is to determine if a person correctly guessed the results of a number of matches.\n    You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    \n    \n    example:\n\n    compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n    compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n    \"\"\"\n", "entry_point": "compare", "canonical_solution": "    return [abs(x-y) for x,y in zip(game,guess)]\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/153", "prompt": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"You will be given the name of a class (a string) and a list of extensions.\n    The extensions are to be used to load additional classes to the class. The\n    strength of the extension is as follows: Let CAP be the number of the uppercase\n    letters in the extension's name, and let SM be the number of lowercase letters \n    in the extension's name, the strength is given by the fraction CAP - SM. \n    You should find the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the list.\n    For example, if you are given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n    \"\"\"\n", "entry_point": "Strongest_Extension", "canonical_solution": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n"}
{"task_id": "HumanEval/154", "prompt": "\ndef cycpattern_check(a , b):\n    \"\"\"You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word\n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n\n    \"\"\"\n", "entry_point": "cycpattern_check", "canonical_solution": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n"}
{"task_id": "HumanEval/155", "prompt": "\ndef even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\"\n", "entry_point": "even_odd_count", "canonical_solution": "    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"task_id": "HumanEval/156", "prompt": "\ndef int_to_mini_roman(number):\n    \"\"\"\n    Given a positive integer, obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n", "entry_point": "int_to_mini_roman", "canonical_solution": "    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"task_id": "HumanEval/157", "prompt": "\ndef right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n", "entry_point": "right_angle_triangle", "canonical_solution": "    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n"}
{"task_id": "HumanEval/158", "prompt": "\ndef find_max(words):\n    \"\"\"Write a function that accepts a list of strings.\n    The list contains different words. Return the word with maximum number\n    of unique characters. If multiple strings have maximum number of unique\n    characters, return the one which comes first in lexicographical order.\n\n    find_max([\"name\", \"of\", \"string\"]) == \"string\"\n    find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n    find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n    \"\"\"\n", "entry_point": "find_max", "canonical_solution": "    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n"}
{"task_id": "HumanEval/159", "prompt": "\ndef eat(number, need, remaining):\n    \"\"\"\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10, 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\n", "entry_point": "eat", "canonical_solution": "    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n"}
{"task_id": "HumanEval/160", "prompt": "\ndef do_algebra(operator, operand):\n    \"\"\"\n    Given two lists operator, and operand. The first list has basic algebra operations, and \n    the second list is a list of integers. Use the two given lists to build the algebric \n    expression and return the evaluation of this expression.\n\n    The basic algebra operations:\n    Addition ( + ) \n    Subtraction ( - ) \n    Multiplication ( * ) \n    Floor division ( // ) \n    Exponentiation ( ** ) \n\n    Example:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n\n    \"\"\"\n", "entry_point": "do_algebra", "canonical_solution": "    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['//', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/161", "prompt": "\ndef solve(s):\n    \"\"\"You are given a string s.\n    if s[i] is a letter, reverse its case from lower to upper or vise versa, \n    otherwise keep it as it is.\n    If the string contains no letters, reverse the string.\n    The function should return the resulted string.\n    Examples\n    solve(\"1234\") = \"4321\"\n    solve(\"ab\") = \"AB\"\n    solve(\"#a@C\") = \"#A@c\"\n    \"\"\"\n", "entry_point": "solve", "canonical_solution": "    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n"}
{"task_id": "HumanEval/162", "prompt": "\ndef string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n", "entry_point": "string_to_md5", "canonical_solution": "    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"task_id": "HumanEval/163", "prompt": "\ndef generate_integers(a, b):\n    \"\"\"\n    Given two positive integers a and b, return the even digits between a\n    and b, in ascending order.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"\n", "entry_point": "generate_integers", "canonical_solution": "    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "LeetCode/1", "prompt": "Given an array of integers `nums` and an integer `target`, return _indices of the two numbers such that they add up to `target`_.\n\nYou may assume that each input would have **_exactly_ one solution**, and you may not use the _same_ element twice.\n\nYou can return the answer in any order.\n\n**Example 1:**\n\n**Input:** nums = \\[2,7,11,15\\], target = 9\n**Output:** \\[0,1\\]\n**Explanation:** Because nums\\[0\\] + nums\\[1\\] == 9, we return \\[0, 1\\].\n\n**Example 2:**\n\n**Input:** nums = \\[3,2,4\\], target = 6\n**Output:** \\[1,2\\]\n\n**Example 3:**\n\n**Input:** nums = \\[3,3\\], target = 6\n**Output:** \\[0,1\\]\n\n**Constraints:**\n\n*   `2 <= nums.length <= 104`\n*   `-109 <= nums[i] <= 109`\n*   `-109 <= target <= 109`\n*   **Only one valid answer exists.**\n\n**Follow-up:** Can you come up with an algorithm that is less than `O(n2)` time complexity?", "entry_point": "two_sum", "canonical_solutions": {"python": "def twoSum(nums, target):\n    map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in map:\n            return [map[complement], i]\n        map[num] = i\n    return []", "java": "import java.util.HashMap;\nimport java.util.Map;\n\npublic int[] twoSum(int[] nums, int target) {\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        int complement = target - nums[i];\n        if (map.containsKey(complement)) {\n            return new int[]{map.get(complement), i};\n        }\n        map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n}", "cpp": "#include <vector>\n#include <unordered_map>\n\nstd::vector<int> twoSum(std::vector<int>& nums, int target) {\n    std::unordered_map<int, int> map;\n    for (int i = 0; i < nums.size(); i++) {\n        int complement = target - nums[i];\n        if (map.find(complement) != map.end()) {\n            return {map[complement], i};\n        }\n        map[nums[i]] = i;\n    }\n    return {};\n}", "javascript": "function twoSum(nums, target) {\n    const map = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        const complement = target - nums[i];\n        if (map.has(complement)) {\n            return [map.get(complement), i];\n        }\n        map.set(nums[i], i);\n    }\n    return [];\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/2", "prompt": "You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n**Example 1:**\n\n**Input:** l1 = \\[2,4,3\\], l2 = \\[5,6,4\\]\n**Output:** \\[7,0,8\\]\n**Explanation:** 342 + 465 = 807.\n\n**Example 2:**\n\n**Input:** l1 = \\[0\\], l2 = \\[0\\]\n**Output:** \\[0\\]\n\n**Example 3:**\n\n**Input:** l1 = \\[9,9,9,9,9,9,9\\], l2 = \\[9,9,9,9\\]\n**Output:** \\[8,9,9,9,0,0,0,1\\]\n\n**Constraints:**\n\n*   The number of nodes in each linked list is in the range `[1, 100]`.\n*   `0 <= Node.val <= 9`\n*   It is guaranteed that the list represents a number that does not have leading zeros.", "entry_point": "add_two_numbers", "canonical_solutions": {"python": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef addTwoNumbers(l1, l2):\n    dummy = ListNode(0)\n    current = dummy\n    carry = 0\n\n    while l1 or l2 or carry:\n        sum_val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry\n        carry = sum_val // 10\n        current.next = ListNode(sum_val % 10)\n        current = current.next\n\n        if l1: l1 = l1.next\n        if l2: l2 = l2.next\n\n    return dummy.next", "java": "public class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) { val = x; }\n}\n\npublic ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n    ListNode dummy = new ListNode(0);\n    ListNode current = dummy;\n    int carry = 0;\n\n    while (l1 != null || l2 != null || carry != 0) {\n        int sum = (l1 != null ? l1.val : 0) + (l2 != null ? l2.val : 0) + carry;\n        carry = sum / 10;\n        current.next = new ListNode(sum % 10);\n        current = current.next;\n\n        if (l1 != null) l1 = l1.next;\n        if (l2 != null) l2 = l2.next;\n    }\n\n    return dummy.next;\n}", "cpp": "struct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(nullptr) {}\n};\n\nListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n    ListNode dummy(0);\n    ListNode* current = &dummy;\n    int carry = 0;\n\n    while (l1 || l2 || carry) {\n        int sum = (l1 ? l1->val : 0) + (l2 ? l2->val : 0) + carry;\n        carry = sum / 10;\n        current->next = new ListNode(sum % 10);\n        current = current->next;\n\n        if (l1) l1 = l1->next;\n        if (l2) l2 = l2->next;\n    }\n\n    return dummy.next;\n}", "javascript": "function ListNode(val, next) {\n    this.val = (val===undefined ? 0 : val);\n    this.next = (next===undefined ? null : next);\n};\n\nfunction addTwoNumbers(l1, l2) {\n    const dummy = new ListNode(0);\n    let current = dummy;\n    let carry = 0;\n\n    while (l1 || l2 || carry) {\n        let sum = (l1 ? l1.val : 0) + (l2 ? l2.val : 0) + carry;\n        carry = Math.floor(sum / 10);\n        current.next = new ListNode(sum % 10);\n        current = current.next;\n\n        if (l1) l1 = l1.next;\n        if (l2) l2 = l2.next;\n    }\n\n    return dummy.next;\n};"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/3", "prompt": "Given a string `s`, find the length of the **longest** **substring** without repeating characters.\n\n**Example 1:**\n\n**Input:** s =  \"abcabcbb \"\n**Output:** 3\n**Explanation:** The answer is  \"abc \", with the length of 3.\n\n**Example 2:**\n\n**Input:** s =  \"bbbbb \"\n**Output:** 1\n**Explanation:** The answer is  \"b \", with the length of 1.\n\n**Example 3:**\n\n**Input:** s =  \"pwwkew \"\n**Output:** 3\n**Explanation:** The answer is  \"wke \", with the length of 3.\nNotice that the answer must be a substring,  \"pwke \" is a subsequence and not a substring.\n\n**Constraints:**\n\n*   `0 <= s.length <= 5 * 104`\n*   `s` consists of English letters, digits, symbols and spaces.", "entry_point": "longest_substring_without_repeating_characters", "canonical_solutions": {"python": "def length_of_longest_substring(s: str) -> int:\n    left = 0\n    right = 0\n    max_length = 0\n    characters = set()\n\n    while right < len(s):\n        if s[right] not in characters:\n            characters.add(s[right])\n            max_length = max(max_length, right - left + 1)\n            right += 1\n        else:\n            characters.remove(s[left])\n            left += 1\n\n    return max_length", "java": "import java.util.HashSet;\nimport java.util.Set;\n\npublic int lengthOfLongestSubstring(String s) {\n    int left = 0, right = 0, maxLength = 0;\n    Set<Character> characters = new HashSet<>();\n\n    while (right < s.length()) {\n        if (!characters.contains(s.charAt(right))) {\n            characters.add(s.charAt(right));\n            maxLength = Math.max(maxLength, right - left + 1);\n            right++;\n        } else {\n            characters.remove(s.charAt(left));\n            left++;\n        }\n    }\n\n    return maxLength;\n}", "cpp": "#include <string>\n#include <unordered_set>\n\nint lengthOfLongestSubstring(std::string s) {\n    int left = 0, right = 0, maxLength = 0;\n    std::unordered_set<char> characters;\n\n    while (right < s.size()) {\n        if (characters.find(s[right]) == characters.end()) {\n            characters.insert(s[right]);\n            maxLength = std::max(maxLength, right - left + 1);\n            right++;\n        } else {\n            characters.erase(s[left]);\n            left++;\n        }\n    }\n\n    return maxLength;\n}", "javascript": "function lengthOfLongestSubstring(s) {\n    let left = 0, right = 0, maxLength = 0;\n    const characters = new Set();\n\n    while (right < s.length) {\n        if (!characters.has(s.charAt(right))) {\n            characters.add(s.charAt(right));\n            maxLength = Math.max(maxLength, right - left + 1);\n            right++;\n        } else {\n            characters.delete(s.charAt(left));\n            left++;\n        }\n    }\n\n    return maxLength;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/4", "prompt": "Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return **the median** of the two sorted arrays.\n\nThe overall run time complexity should be `O(log (m+n))`.\n\n**Example 1:**\n\n**Input:** nums1 = \\[1,3\\], nums2 = \\[2\\]\n**Output:** 2.00000\n**Explanation:** merged array = \\[1,2,3\\] and median is 2.\n\n**Example 2:**\n\n**Input:** nums1 = \\[1,2\\], nums2 = \\[3,4\\]\n**Output:** 2.50000\n**Explanation:** merged array = \\[1,2,3,4\\] and median is (2 + 3) / 2 = 2.5.\n\n**Constraints:**\n\n*   `nums1.length == m`\n*   `nums2.length == n`\n*   `0 <= m <= 1000`\n*   `0 <= n <= 1000`\n*   `1 <= m + n <= 2000`\n*   `-106 <= nums1[i], nums2[i] <= 106`", "entry_point": "median_of_two_sorted_arrays", "canonical_solutions": {"python": "def findMedianSortedArrays(nums1, nums2):\n    if len(nums1) > len(nums2):\n        return findMedianSortedArrays(nums2, nums1)\n    \n    x, y = len(nums1), len(nums2)\n    low, high = 0, x\n\n    while low <= high:\n        partition_x = (low + high) // 2\n        partition_y = (x + y + 1) // 2 - partition_x\n\n        max_left_x = float('-inf') if partition_x == 0 else nums1[partition_x - 1]\n        min_right_x = float('inf') if partition_x == x else nums1[partition_x]\n\n        max_left_y = float('-inf') if partition_y == 0 else nums2[partition_y - 1]\n        min_right_y = float('inf') if partition_y == y else nums2[partition_y]\n\n        if max_left_x <= min_right_y and max_left_y <= min_right_x:\n            if (x + y) % 2 == 0:\n                return (max(max_left_x, max_left_y) + min(min_right_x, min_right_y)) / 2\n            else:\n                return max(max_left_x, max_left_y)\n        elif max_left_x > min_right_y:\n            high = partition_x - 1\n        else:\n            low = partition_x + 1\n    \n    return 0", "java": "public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n    if (nums1.length > nums2.length) {\n        return findMedianSortedArrays(nums2, nums1);\n    }\n    \n    int x = nums1.length;\n    int y = nums2.length;\n    int low = 0;\n    int high = x;\n    \n    while (low <= high) {\n        int partitionX = (low + high) / 2;\n        int partitionY = (x + y + 1) / 2 - partitionX;\n        \n        int maxLeftX = (partitionX == 0) ? Integer.MIN_VALUE : nums1[partitionX - 1];\n        int minRightX = (partitionX == x) ? Integer.MAX_VALUE : nums1[partitionX];\n        \n        int maxLeftY = (partitionY == 0) ? Integer.MIN_VALUE : nums2[partitionY - 1];\n        int minRightY = (partitionY == y) ? Integer.MAX_VALUE : nums2[partitionY];\n        \n        if (maxLeftX <= minRightY && maxLeftY <= minRightX) {\n            if ((x + y) % 2 == 0) {\n                return (double)(Math.max(maxLeftX, maxLeftY) + Math.min(minRightX, minRightY)) / 2;\n            } else {\n                return (double)Math.max(maxLeftX, maxLeftY);\n            }\n        } else if (maxLeftX > minRightY) {\n            high = partitionX - 1;\n        } else {\n            low = partitionX + 1;\n        }\n    }    \n    return 0;\n}", "cpp": "double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n    if (nums1.size() > nums2.size()) {\n        return findMedianSortedArrays(nums2, nums1);\n    }\n    \n    int x = nums1.size();\n    int y = nums2.size();\n    int low = 0;\n    int high = x;\n    \n    while (low <= high) {\n        int partitionX = (low + high) / 2;\n        int partitionY = (x + y + 1) / 2 - partitionX;\n        \n        int maxLeftX = (partitionX == 0) ? INT_MIN : nums1[partitionX - 1];\n        int minRightX = (partitionX == x) ? INT_MAX : nums1[partitionX];\n        \n        int maxLeftY = (partitionY == 0) ? INT_MIN : nums2[partitionY - 1];\n        int minRightY = (partitionY == y) ? INT_MAX : nums2[partitionY];\n        \n        if (maxLeftX <= minRightY && maxLeftY <= minRightX) {\n            if ((x + y) % 2 == 0) {\n                return (double(max(maxLeftX, maxLeftY) + min(minRightX, minRightY))) / 2;\n            } else {\n                return double(max(maxLeftX, maxLeftY));\n            }\n        } else if (maxLeftX > minRightY) {\n            high = partitionX - 1;\n        } else {\n            low = partitionX + 1;\n        }\n    }    \n    return 0;\n}", "javascript": "function findMedianSortedArrays(nums1, nums2) {\n    if (nums1.length > nums2.length) {\n        return findMedianSortedArrays(nums2, nums1);\n    }\n    \n    const x = nums1.length;\n    const y = nums2.length;\n    let low = 0;\n    let high = x;\n    \n    while (low <= high) {\n        const partitionX = Math.floor((low + high) / 2);\n        const partitionY = Math.floor((x + y + 1) / 2) - partitionX;\n        \n        const maxLeftX = (partitionX === 0) ? Number.NEGATIVE_INFINITY : nums1[partitionX - 1];\n        const minRightX = (partitionX === x) ? Number.POSITIVE_INFINITY : nums1[partitionX];\n        \n        const maxLeftY = (partitionY === 0) ? Number.NEGATIVE_INFINITY : nums2[partitionY - 1];\n        const minRightY = (partitionY === y) ? Number.POSITIVE_INFINITY : nums2[partitionY];\n        \n        if (maxLeftX <= minRightY && maxLeftY <= minRightX) {\n            if ((x + y) % 2 === 0) {\n                return (Math.max(maxLeftX, maxLeftY) + Math.min(minRightX, minRightY)) / 2;\n            } else {\n                return Math.max(maxLeftX, maxLeftY);\n            }\n        } else if (maxLeftX > minRightY) {\n            high = partitionX - 1;\n        } else {\n            low = partitionX + 1;\n        }\n    }    \n    return 0;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/5", "prompt": "Given a string `s`, return _the longest_ _palindromic_ _substring_ in `s`.\n\n**Example 1:**\n\n**Input:** s =  \"babad \"\n**Output:**  \"bab \"\n**Explanation:**  \"aba \" is also a valid answer.\n\n**Example 2:**\n\n**Input:** s =  \"cbbd \"\n**Output:**  \"bb \"\n\n**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s` consist of only digits and English letters.", "entry_point": "longest_palindromic_substring", "canonical_solutions": {"python": "def longest_palindromic_substring(s: str) -> str:\n    n = len(s)\n    if n == 0: return \"\"\n\n    start, max_length = 0, 1\n\n    for i in range(n):\n        l, r = i, i\n\n        while r < n - 1 and s[r] == s[r + 1]:\n            r += 1\n        i = r\n\n        while l > 0 and r < n - 1 and s[l - 1] == s[r + 1]:\n            l -= 1\n            r += 1\n\n        length = r - l + 1\n        if length > max_length:\n            start, max_length = l, length\n\n    return s[start:start + max_length]", "java": "public String longestPalindromicSubstring(String s) {\n    int n = s.length();\n    if (n == 0) return \"\";\n\n    int start = 0, maxLength = 1;\n\n    for (int i = 0; i < n; ++i) {\n        int l = i, r = i;\n\n        while (r < n - 1 && s.charAt(r) == s.charAt(r + 1))\n            r++;\n        i = r;\n\n        while (l > 0 && r < n - 1 && s.charAt(l - 1) == s.charAt(r + 1)) {\n            l--;\n            r++;\n        }\n\n        int length = r - l + 1;\n        if (length > maxLength) {\n            start = l;\n            maxLength = length;\n        }\n    }\n\n    return s.substring(start, start + maxLength);\n}", "cpp": "#include <string>\n\nstd::string longestPalindromicSubstring(std::string s) {\n  int n = s.size();\n  if (n == 0) return \"\";\n  int start = 0, maxLength = 1;\n\n  for (int i = 0; i < n; ++i) {\n    int l = i, r = i;\n\n    while (r < n - 1 && s[r] == s[r + 1])\n      r++;\n    i = r;\n\n    while (l > 0 && r < n - 1 && s[l - 1] == s[r + 1]) {\n      l--;\n      r++;\n    }\n\n    int length = r - l + 1;\n    if (length > maxLength) {\n      start = l;\n      maxLength = length;\n    }\n  }\n\n  return s.substr(start, maxLength);\n}", "javascript": "function longestPalindromicSubstring(s) {\n  let n = s.length;\n  if (n === 0) return \"\";\n\n  let start = 0, maxLength = 1;\n\n  for (let i = 0; i < n; ++i) {\n    let l = i, r = i;\n\n    while (r < n - 1 && s[r] === s[r + 1])\n      r++;\n    i = r;\n\n    while (l > 0 && r < n - 1 && s[l - 1] === s[r + 1]) {\n      l--;\n      r++;\n    }\n\n    let length = r - l + 1;\n    if (length > maxLength) {\n      start = l;\n      maxLength = length;\n    }\n  }\n\n  return s.substring(start, start + maxLength);\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/6", "prompt": "The string `\"PAYPALISHIRING \"` is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n\nP   A   H   N\nA P L S I I G\nY   I   R\n\nAnd then read line by line: `\"PAHNAPLSIIGYIR \"`\n\nWrite the code that will take a string and make this conversion given a number of rows:\n\nstring convert(string s, int numRows);\n\n**Example 1:**\n\n**Input:** s =  \"PAYPALISHIRING \", numRows = 3\n**Output:**  \"PAHNAPLSIIGYIR \"\n\n**Example 2:**\n\n**Input:** s =  \"PAYPALISHIRING \", numRows = 4\n**Output:**  \"PINALSIGYAHRPI \"\n**Explanation:**\nP     I    N\nA   L S  I G\nY A   H R\nP     I\n\n**Example 3:**\n\n**Input:** s =  \"A \", numRows = 1\n**Output:**  \"A \"\n\n**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s` consists of English letters (lower-case and upper-case), `','` and `'.'`.\n*   `1 <= numRows <= 1000`", "entry_point": "zigzag_conversion", "canonical_solutions": {"python": "def convert(s: str, numRows: int) -> str:\n    if numRows == 1 or numRows >= len(s):\n        return s\n\n    rows = [\"\"] * numRows\n    curRow = 0\n    goingDown = False\n\n    for c in s:\n        rows[curRow] += c\n        if curRow == 0 or curRow == numRows - 1:\n            goingDown = not goingDown\n        curRow += 1 if goingDown else -1\n\n    return \"\".join(rows)", "java": "public class ZigzagConversion {\n    public String convert(String s, int numRows) {\n        if (numRows == 1 || numRows >= s.length()) return s;\n\n        StringBuilder[] rows = new StringBuilder[numRows];\n        for (int i = 0; i < numRows; i++) rows[i] = new StringBuilder();\n        \n        int curRow = 0;\n        boolean goingDown = false;\n\n        for (char c : s.toCharArray()) {\n            rows[curRow].append(c);\n            if (curRow == 0 || curRow == numRows - 1) goingDown = !goingDown;\n            curRow += goingDown ? 1 : -1;\n        }\n\n        StringBuilder result = new StringBuilder();\n        for (StringBuilder row : rows) result.append(row);\n        return result.toString();\n    }\n}", "cpp": "#include <string>\n#include <vector>\n\nstd::string convert(std::string s, int numRows) {\n    if (numRows == 1 || numRows >= s.size()) return s;\n\n    std::vector<std::string> rows(std::min(numRows, int(s.size())));\n    int curRow = 0;\n    bool goingDown = false;\n\n    for (char c : s) {\n        rows[curRow] += c;\n        if (curRow == 0 || curRow == numRows - 1) goingDown = !goingDown;\n        curRow += goingDown ? 1 : -1;\n    }\n\n    std::string result;\n    for (std::string row : rows) result += row;\n    return result;\n}", "javascript": "function convert(s, numRows) {\n    if (numRows === 1 || numRows >= s.length) return s;\n\n    let rows = new Array(numRows).fill(\"\");\n    let curRow = 0;\n    let goingDown = false;\n\n    for (let c of s) {\n        rows[curRow] += c;\n        if (curRow === 0 || curRow === numRows - 1) goingDown = !goingDown;\n        curRow += goingDown ? 1 : -1;\n    }\n\n    return rows.join(\"\");\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/7", "prompt": "Given a signed 32-bit integer `x`, return `x` _with its digits reversed_. If reversing `x` causes the value to go outside the signed 32-bit integer range `[-231, 231 - 1]`, then return `0`.\n\n**Assume the environment does not allow you to store 64-bit integers (signed or unsigned).**\n\n**Example 1:**\n\n**Input:** x = 123\n**Output:** 321\n\n**Example 2:**\n\n**Input:** x = -123\n**Output:** -321\n\n**Example 3:**\n\n**Input:** x = 120\n**Output:** 21\n\n**Constraints:**\n\n*   `-231 <= x <= 231 - 1`", "entry_point": "reverse_integer", "canonical_solutions": {"python": "def reverse(x: int) -> int:\n    sign = -1 if x < 0 else 1\n    x = abs(x)\n    res = 0\n    while x:\n        res = res * 10 + x % 10\n        x //= 10\n    res *= sign\n    return res if -2**31 <= res <= 2**31 - 1 else 0", "java": "public int reverse(int x) {\n    long res = 0;\n    while (x != 0) {\n        res = res * 10 + x % 10;\n        x /= 10;\n    }\n    return (res < Integer.MIN_VALUE || res > Integer.MAX_VALUE) ? 0 : (int)res;\n}", "cpp": "int reverse(int x) {\n    long long res = 0;\n    while (x != 0) {\n        res = res * 10 + x % 10;\n        x /= 10;\n    }\n    return (res < INT_MIN || res > INT_MAX) ? 0 : res;\n}", "javascript": "function reverse(x) {\n    let sign = x < 0 ? -1 : 1;\n    x = Math.abs(x);\n    let res = 0;\n    while (x !== 0) {\n        res = res * 10 + x % 10;\n        x = Math.floor(x / 10);\n    }\n    res *= sign;\n    return (res < -(2 ** 31) || res > 2 ** 31 - 1) ? 0 : res;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/8", "prompt": "Implement the `myAtoi(string s)` function, which converts a string to a 32-bit signed integer (similar to C/C++'s `atoi` function).\n\nThe algorithm for `myAtoi(string s)` is as follows:\n\n1.  Read in and ignore any leading whitespace.\n2.  Check if the next character (if not already at the end of the string) is `'-'` or `'+'`. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\n3.  Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\n4.  Convert these digits into an integer (i.e. `\"123 \" -> 123`, `\"0032 \" -> 32`). If no digits were read, then the integer is `0`. Change the sign as necessary (from step 2).\n5.  If the integer is out of the 32-bit signed integer range `[-231, 231 - 1]`, then clamp the integer so that it remains in the range. Specifically, integers less than `-231` should be clamped to `-231`, and integers greater than `231 - 1` should be clamped to `231 - 1`.\n6.  Return the integer as the final result.\n\n**Note:**\n\n*   Only the space character `' '` is considered a whitespace character.\n*   **Do not ignore** any characters other than the leading whitespace or the rest of the string after the digits.\n\n**Example 1:**\n\n**Input:** s =  \"42 \"\n**Output:** 42\n**Explanation:** The underlined characters are what is read in, the caret is the current reader position.\nStep 1:  \"42 \" (no characters read because there is no leading whitespace)\n         ^\nStep 2:  \"42 \" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3:  \"42 \" ( \"42 \" is read in)\n           ^\nThe parsed integer is 42.\nSince 42 is in the range \\[-231, 231 - 1\\], the final result is 42.\n\n**Example 2:**\n\n**Input:** s =  \"   -42 \"\n**Output:** -42\n**Explanation:**\nStep 1:  \"   \\-42 \" (leading whitespace is read and ignored)\n            ^\nStep 2:  \"   \\-42 \" ('-' is read, so the result should be negative)\n             ^\nStep 3:  \"   -42 \" ( \"42 \" is read in)\n               ^\nThe parsed integer is -42.\nSince -42 is in the range \\[-231, 231 - 1\\], the final result is -42.\n\n**Example 3:**\n\n**Input:** s =  \"4193 with words \"\n**Output:** 4193\n**Explanation:**\nStep 1:  \"4193 with words \" (no characters read because there is no leading whitespace)\n         ^\nStep 2:  \"4193 with words \" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3:  \"4193 with words \" ( \"4193 \" is read in; reading stops because the next character is a non-digit)\n             ^\nThe parsed integer is 4193.\nSince 4193 is in the range \\[-231, 231 - 1\\], the final result is 4193.\n\n**Constraints:**\n\n*   `0 <= s.length <= 200`\n*   `s` consists of English letters (lower-case and upper-case), digits (`0-9`), `' '`, `'+'`, `'-'`, and `'.'`.", "entry_point": "string_to_integer_atoi", "canonical_solutions": {"python": "def myAtoi(s):\n    result, i, sign = 0, 0, 1\n    while i < len(s) and s[i] == ' ': i += 1\n    if i < len(s) and (s[i] == '-' or s[i] == '+'):\n        sign = -1 if s[i] == '-' else 1\n        i += 1\n    while i < len(s) and s[i].isdigit():\n        result = result * 10 + int(s[i])\n        i += 1\n        if result * sign > 2**31 - 1: return 2**31 - 1\n        if result * sign < -2**31: return -2**31\n    return result * sign", "java": "public int myAtoi(String s) {\n    long result = 0;\n    int i = 0, sign = 1;\n    while (i < s.length() && s.charAt(i) == ' ') i++;\n    if (i < s.length() && (s.charAt(i) == '-' || s.charAt(i) == '+')) {\n        sign = (s.charAt(i++) == '+') ? 1 : -1;\n    }\n    while (i < s.length() && Character.isDigit(s.charAt(i))) {\n        result = result * 10 + (s.charAt(i++) - '0');\n        if (result * sign > Integer.MAX_VALUE) return Integer.MAX_VALUE;\n        if (result * sign < Integer.MIN_VALUE) return Integer.MIN_VALUE;\n    }\n    return (int) (result * sign);\n}", "cpp": "int myAtoi(string s) {\n    long result = 0;\n    int i = 0, sign = 1;\n    while (s[i] == ' ') i++;\n    if (s[i] == '-' || s[i] == '+') sign = (s[i++] == '+') ? 1 : -1;\n    while (isdigit(s[i])) {\n        result = result * 10 + (s[i++] - '0');\n        if (result * sign > INT_MAX) return INT_MAX;\n        if (result * sign < INT_MIN) return INT_MIN;\n    }\n    return result * sign;\n}", "javascript": "function myAtoi(s) {\n    let result = 0, i = 0, sign = 1;\n    while (s[i] === ' ') i++;\n    if (s[i] === '-' || s[i] === '+') sign = (s[i++] === '+') ? 1 : -1;\n    while (!isNaN(s[i]) && s[i] !== ' ') {\n        result = result * 10 + parseInt(s[i++], 10);\n        if (result * sign > 2147483647) return 2147483647;\n        if (result * sign < -2147483648) return -2147483648;\n    }\n    return result * sign;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/9", "prompt": "Given an integer `x`, return `true` _if_ `x` _is a_ _**palindrome**__, and_ `false` _otherwise_.\n\n**Example 1:**\n\n**Input:** x = 121\n**Output:** true\n**Explanation:** 121 reads as 121 from left to right and from right to left.\n\n**Example 2:**\n\n**Input:** x = -121\n**Output:** false\n**Explanation:** From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n\n**Example 3:**\n\n**Input:** x = 10\n**Output:** false\n**Explanation:** Reads 01 from right to left. Therefore it is not a palindrome.\n\n**Constraints:**\n\n*   `-231 <= x <= 231 - 1`\n\n**Follow up:** Could you solve it without converting the integer to a string?", "entry_point": "palindrome_number", "canonical_solutions": {"python": "def is_palindrome(x: int) -> bool:\n    if x < 0:\n        return False\n    original, reversed = x, 0\n    while x > 0:\n        reversed = reversed * 10 + x % 10\n        x //= 10\n    return original == reversed", "java": "public boolean isPalindrome(int x) {\n    if (x < 0) return false;\n    int original = x, reversed = 0;\n    while (x > 0) {\n        reversed = reversed * 10 + x % 10;\n        x /= 10;\n    }\n    return original == reversed;\n}", "cpp": "bool isPalindrome(int x) {\n    if (x < 0) return false;\n    int original = x, reversed = 0;\n    while (x > 0) {\n        reversed = reversed * 10 + x % 10;\n        x /= 10;\n    }\n    return original == reversed;\n}", "javascript": "function isPalindrome(x) {\n    if (x < 0) return false;\n    let original = x, reversed = 0;\n    while (x > 0) {\n        reversed = reversed * 10 + x % 10;\n        x = Math.floor(x / 10);\n    }\n    return original === reversed;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/10", "prompt": "Given an input string `s` and a pattern `p`, implement regular expression matching with support for `'.'` and `'*'` where:\n\n*   `'.'` Matches any single character.\u200b\u200b\u200b\u200b\n*   `'*'` Matches zero or more of the preceding element.\n\nThe matching should cover the **entire** input string (not partial).\n\n**Example 1:**\n\n**Input:** s =  \"aa \", p =  \"a \"\n**Output:** false\n**Explanation:**  \"a \" does not match the entire string  \"aa \".\n\n**Example 2:**\n\n**Input:** s =  \"aa \", p =  \"a\\* \"\n**Output:** true\n**Explanation:** '\\*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes  \"aa \".\n\n**Example 3:**\n\n**Input:** s =  \"ab \", p =  \".\\* \"\n**Output:** true\n**Explanation:**  \".\\* \" means  \"zero or more (\\*) of any character (.) \".\n\n**Constraints:**\n\n*   `1 <= s.length <= 20`\n*   `1 <= p.length <= 20`\n*   `s` contains only lowercase English letters.\n*   `p` contains only lowercase English letters, `'.'`, and `'*'`.\n*   It is guaranteed for each appearance of the character `'*'`, there will be a previous valid character to match.", "entry_point": "regular_expression_matching", "canonical_solutions": {"python": "def is_match(s: str, p: str) -> bool:\n    m, n = len(s), len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    for j in range(1, n + 1):\n        if p[j - 1] == '*' and dp[0][j - 2]:\n            dp[0][j] = True\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if p[j - 1] == s[i - 1] or p[j - 1] == '.':\n                dp[i][j] = dp[i - 1][j - 1]\n            elif p[j - 1] == '*':\n                dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.'))\n\n    return dp[m][n]", "java": "public boolean isMatch(String s, String p) {\n    int m = s.length(), n = p.length();\n    boolean[][] dp = new boolean[m + 1][n + 1];\n    dp[0][0] = true;\n\n    for (int j = 1; j <= n; j++) {\n        if (p.charAt(j - 1) == '*' && dp[0][j - 2]) {\n            dp[0][j] = true;\n        }\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (p.charAt(j - 1) == s.charAt(i - 1) || p.charAt(j - 1) == '.') {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else if (p.charAt(j - 1) == '*') {\n                dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.'));\n            }\n        }\n    }\n\n    return dp[m][n];\n}", "cpp": "bool isMatch(std::string s, std::string p) {\n    int m = s.length(), n = p.length();\n    std::vector<std::vector<bool>> dp(m + 1, std::vector<bool>(n + 1, false));\n    dp[0][0] = true;\n\n    for (int j = 1; j <= n; j++) {\n        if (p[j - 1] == '*' && dp[0][j - 2]) {\n            dp[0][j] = true;\n        }\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (p[j - 1] == s[i - 1] || p[j - 1] == '.') {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else if (p[j - 1] == '*') {\n                dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.'));\n            }\n        }\n    }\n\n    return dp[m][n];\n}", "javascript": "function isMatch(s, p) {\n    const m = s.length, n = p.length;\n    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(false));\n    dp[0][0] = true;\n\n    for (let j = 1; j <= n; j++) {\n        if (p[j - 1] === '*' && dp[0][j - 2]) {\n            dp[0][j] = true;\n        }\n    }\n\n    for (let i = 1; i <= m; i++) {\n      for (let j = 1; j <= n; j++) {\n          if (p[j - 1] === s[i - 1] || p[j - 1] === '.') {\n              dp[i][j] = dp[i - 1][j - 1];\n          } else if (p[j - 1] === '*') {\n              dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s[i - 1] === p[j - 2] || p[j - 2] === '.'));\n          }\n      }\n    }\n\n    return dp[m][n];\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/12", "prompt": "Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.\n\n**Symbol**       **Value**\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n\nFor example, `2` is written as `II` in Roman numeral, just two one's added together. `12` is written as `XII`, which is simply `X + II`. The number `27` is written as `XXVII`, which is `XX + V + II`.\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as `IX`. There are six instances where subtraction is used:\n\n*   `I` can be placed before `V` (5) and `X` (10) to make 4 and 9.\n*   `X` can be placed before `L` (50) and `C` (100) to make 40 and 90.\n*   `C` can be placed before `D` (500) and `M` (1000) to make 400 and 900.\n\nGiven an integer, convert it to a roman numeral.\n\n**Example 1:**\n\n**Input:** num = 3\n**Output:**  \"III \"\n**Explanation:** 3 is represented as 3 ones.\n\n**Example 2:**\n\n**Input:** num = 58\n**Output:**  \"LVIII \"\n**Explanation:** L = 50, V = 5, III = 3.\n\n**Example 3:**\n\n**Input:** num = 1994\n**Output:**  \"MCMXCIV \"\n**Explanation:** M = 1000, CM = 900, XC = 90 and IV = 4.\n\n**Constraints:**\n\n*   `1 <= num <= 3999`", "entry_point": "integer_to_roman", "canonical_solutions": {"python": "def int_to_roman(num):\n    romans = [\n        (1000, \"M\"), (900, \"CM\"), (500, \"D\"),\n        (400, \"CD\"), (100, \"C\"), (90, \"XC\"),\n        (50, \"L\"), (40, \"XL\"), (10, \"X\"), \n        (9, \"IX\"), (5, \"V\"), (4, \"IV\"), (1, \"I\")\n    ]\n    roman = \"\"\n    for value, symbol in romans:\n        while num >= value:\n            roman += symbol\n            num -= value\n    return roman", "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class RomanNumerals {\n    public static String intToRoman(int num) {\n        List<Pair> romans = Arrays.asList(\n            new Pair(1000, \"M\"), new Pair(900, \"CM\"), new Pair(500, \"D\"), \n            new Pair(400, \"CD\"), new Pair(100, \"C\"), new Pair(90, \"XC\"),\n            new Pair(50, \"L\"), new Pair(40, \"XL\"), new Pair(10, \"X\"), \n            new Pair(9, \"IX\"), new Pair(5, \"V\"), new Pair(4, \"IV\"),\n            new Pair(1, \"I\")\n        );\n        StringBuilder roman = new StringBuilder();\n        for (Pair p : romans) {\n            while (num >= p.num) {\n                roman.append(p.symbol);\n                num -= p.num;\n            }\n        }\n        return roman.toString();\n    }\n    \n    private static class Pair {\n        final int num;\n        final String symbol;\n        \n        Pair(int num, String symbol) {\n            this.num = num;\n            this.symbol = symbol;\n        }\n    }\n}", "cpp": "#include <vector>\n#include <string>\n\nstd::string intToRoman(int num) {\n    std::vector<std::pair<int, std::string>> romans = {\n        {1000, \"M\"},\n        {900, \"CM\"},\n        {500, \"D\"},\n        {400, \"CD\"},\n        {100, \"C\"},\n        {90, \"XC\"},\n        {50, \"L\"},\n        {40, \"XL\"},\n        {10, \"X\"},\n        {9, \"IX\"},\n        {5, \"V\"},\n        {4, \"IV\"},\n        {1, \"I\"}\n    };\n    std::string roman = \"\";\n    for (const auto& p : romans) {\n        while (num >= p.first) {\n            roman += p.second;\n            num -= p.first;\n        }\n    }\n    return roman;\n}", "javascript": "function intToRoman(num) {\n    const romans = [\n        [1000, \"M\"], [900, \"CM\"], [500, \"D\"],\n        [400, \"CD\"], [100, \"C\"], [90, \"XC\"],\n        [50, \"L\"], [40, \"XL\"], [10, \"X\"], \n        [9, \"IX\"], [5, \"V\"], [4, \"IV\"], [1, \"I\"]\n    ];\n    let roman = \"\";\n    for (const [value, symbol] of romans) {\n        while (num >= value) {\n            roman += symbol;\n            num -= value;\n        }\n    }\n    return roman;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/13", "prompt": "Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.\n\n**Symbol**       **Value**\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n\nFor example, `2` is written as `II` in Roman numeral, just two ones added together. `12` is written as `XII`, which is simply `X + II`. The number `27` is written as `XXVII`, which is `XX + V + II`.\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as `IX`. There are six instances where subtraction is used:\n\n*   `I` can be placed before `V` (5) and `X` (10) to make 4 and 9.\n*   `X` can be placed before `L` (50) and `C` (100) to make 40 and 90.\n*   `C` can be placed before `D` (500) and `M` (1000) to make 400 and 900.\n\nGiven a roman numeral, convert it to an integer.\n\n**Example 1:**\n\n**Input:** s =  \"III \"\n**Output:** 3\n**Explanation:** III = 3.\n\n**Example 2:**\n\n**Input:** s =  \"LVIII \"\n**Output:** 58\n**Explanation:** L = 50, V= 5, III = 3.\n\n**Example 3:**\n\n**Input:** s =  \"MCMXCIV \"\n**Output:** 1994\n**Explanation:** M = 1000, CM = 900, XC = 90 and IV = 4.\n\n**Constraints:**\n\n*   `1 <= s.length <= 15`\n*   `s` contains only the characters `('I', 'V', 'X', 'L', 'C', 'D', 'M')`.\n*   It is **guaranteed** that `s` is a valid roman numeral in the range `[1, 3999]`.", "entry_point": "roman_to_integer", "canonical_solutions": {"python": "def roman_to_int(s):\n    roman_values = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n    total = 0\n    prev_value = 0\n    \n    for c in s:\n        current_value = roman_values[c]\n        if current_value > prev_value:\n            total += current_value - 2 * prev_value\n        else:\n            total += current_value\n        prev_value = current_value\n\n    return total", "java": "public int romanToInt(String s) {\n    Map<Character, Integer> romanValues = new HashMap<>();\n    romanValues.put('I', 1);\n    romanValues.put('V', 5);\n    romanValues.put('X', 10);\n    romanValues.put('L', 50);\n    romanValues.put('C', 100);\n    romanValues.put('D', 500);\n    romanValues.put('M', 1000);\n\n    int total = 0;\n    int prevValue = 0;\n\n    for (char c : s.toCharArray()) {\n        int currValue = romanValues.get(c);\n        total += currValue > prevValue ? currValue - 2 * prevValue : currValue;\n        prevValue = currValue;\n    }\n\n    return total;\n}", "cpp": "int romanToInt(string s) {\n    unordered_map<char, int> roman_values = { {'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100}, {'D', 500}, {'M', 1000} };\n    int total = 0;\n    int prev_value = 0;\n\n    for (char c : s) {\n        int current_value = roman_values[c];\n        if (current_value > prev_value)\n            total += current_value - (2 * prev_value);\n        else\n            total += current_value;\n        prev_value = current_value;\n    }\n\n    return total;\n}", "javascript": "function romanToInt(s) {\n    const romanValues = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000};\n    let total = 0;\n    let prevValue = 0;\n\n    for (let i = 0; i < s.length; i++) {\n        let currValue = romanValues[s[i]];\n        if (currValue > prevValue)\n            total += currValue - (2 * prevValue);\n        else\n            total += currValue;\n        prevValue = currValue;\n    }\n\n    return total;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/14", "prompt": "Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string `\" \"`.\n\n**Example 1:**\n\n**Input:** strs = \\[ \"flower \", \"flow \", \"flight \"\\]\n**Output:**  \"fl \"\n\n**Example 2:**\n\n**Input:** strs = \\[ \"dog \", \"racecar \", \"car \"\\]\n**Output:**  \" \"\n**Explanation:** There is no common prefix among the input strings.\n\n**Constraints:**\n\n*   `1 <= strs.length <= 200`\n*   `0 <= strs[i].length <= 200`\n*   `strs[i]` consists of only lowercase English letters.", "entry_point": "longest_common_prefix", "canonical_solutions": {"python": "def longest_common_prefix(strs):\n    if not strs:\n        return \"\"\n\n    for i, c in enumerate(strs[0]):\n        for j in range(1, len(strs)):\n            if i == len(strs[j]) or strs[j][i] != c:\n                return strs[0][:i]\n    return strs[0]", "java": "public String longestCommonPrefix(String[] strs) {\n    if (strs.length == 0) return \"\";\n\n    for (int i = 0; i < strs[0].length(); ++i) {\n        char c = strs[0].charAt(i);\n        for (int j = 1; j < strs.length; ++j) {\n            if (i == strs[j].length() || strs[j].charAt(i) != c) {\n                return strs[0].substring(0, i);\n            }\n        }\n    }\n    return strs[0];\n}", "cpp": "#include <vector>\n#include <string>\nusing namespace std;\n\nstring longestCommonPrefix(vector<string>& strs) {\n    if (strs.empty()) return \"\";\n\n    for (int i = 0; i < strs[0].size(); ++i) {\n        char c = strs[0][i];\n        for (int j = 1; j < strs.size(); ++j) {\n            if (i == strs[j].size() || strs[j][i] != c) {\n                return strs[0].substr(0, i);\n            }\n        }\n    }\n    return strs[0];\n}", "javascript": "function longestCommonPrefix(strs) {\n    if (strs.length === 0) return \"\";\n\n    for (let i = 0; i < strs[0].length; ++i) {\n        const c = strs[0][i];\n        for (let j = 1; j < strs.length; ++j) {\n            if (i === strs[j].length || strs[j][i] !== c) {\n                return strs[0].substr(0, i);\n            }\n        }\n    }\n    return strs[0];\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/15", "prompt": "Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.\n\nNotice that the solution set must not contain duplicate triplets.\n\n**Example 1:**\n\n**Input:** nums = \\[-1,0,1,2,-1,-4\\]\n**Output:** \\[\\[-1,-1,2\\],\\[-1,0,1\\]\\]\n**Explanation:** \nnums\\[0\\] + nums\\[1\\] + nums\\[2\\] = (-1) + 0 + 1 = 0.\nnums\\[1\\] + nums\\[2\\] + nums\\[4\\] = 0 + 1 + (-1) = 0.\nnums\\[0\\] + nums\\[3\\] + nums\\[4\\] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are \\[-1,0,1\\] and \\[-1,-1,2\\].\nNotice that the order of the output and the order of the triplets does not matter.\n\n**Example 2:**\n\n**Input:** nums = \\[0,1,1\\]\n**Output:** \\[\\]\n**Explanation:** The only possible triplet does not sum up to 0.\n\n**Example 3:**\n\n**Input:** nums = \\[0,0,0\\]\n**Output:** \\[\\[0,0,0\\]\\]\n**Explanation:** The only possible triplet sums up to 0.\n\n**Constraints:**\n\n*   `3 <= nums.length <= 3000`\n*   `-105 <= nums[i] <= 105`", "entry_point": "3sum", "canonical_solutions": {"python": "def threeSum(nums):\n    nums.sort()\n    result = []\n\n    for i in range(len(nums) - 2):\n        if i == 0 or nums[i] != nums[i - 1]:\n            j, k = i + 1, len(nums) - 1\n            while j < k:\n                s = nums[i] + nums[j] + nums[k]\n                if s == 0:\n                    result.append([nums[i], nums[j], nums[k]])\n                    while j < k and nums[j] == nums[j + 1]:\n                        j += 1\n                    while j < k and nums[k] == nums[k - 1]:\n                        k -= 1\n                    j += 1\n                    k -= 1\n                elif s < 0:\n                    j += 1\n                else:\n                    k -= 1\n\n    return result", "java": "import java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> threeSum(int[] nums) {\n    Arrays.sort(nums);\n    List<List<Integer>> result = new ArrayList<>();\n\n    for (int i = 0; i < nums.length - 2; i++) {\n        if (i == 0 || nums[i] != nums[i - 1]) {\n            int j = i + 1, k = nums.length - 1;\n            while (j < k) {\n                int sum = nums[i] + nums[j] + nums[k];\n                if (sum == 0) {\n                    result.add(Arrays.asList(nums[i], nums[j], nums[k]));\n                    while (j < k && nums[j] == nums[j + 1]) j++;\n                    while (j < k && nums[k] == nums[k - 1]) k--;\n                    j++;\n                    k--;\n                } else if (sum < 0) {\n                    j++;\n                } else {\n                    k--;\n                }                    \n            }\n        }\n    }\n\n    return result;\n}", "cpp": "#include <vector>\n#include <algorithm>\n\nstd::vector<std::vector<int>> threeSum(std::vector<int>& nums) {\n    std::vector<std::vector<int>> result;\n    std::sort(nums.begin(), nums.end());\n\n    for (int i = 0; i < (int)nums.size() - 2; ++i) {\n        if (i == 0 || nums[i] != nums[i - 1]) {\n            int j = i + 1, k = nums.size() - 1;\n            while (j < k) {\n                int sum = nums[i] + nums[j] + nums[k];\n                if (sum == 0) {\n                    result.push_back({nums[i], nums[j], nums[k]});\n                    while (j < k && nums[j] == nums[j + 1]) ++j;\n                    while (j < k && nums[k] == nums[k - 1]) --k;\n                    ++j;\n                    --k;\n                } else if (sum < 0) {\n                    ++j;\n                } else {\n                    --k;\n                }\n            }\n        }\n    }\n\n    return result;\n}", "javascript": "function threeSum(nums) {\n    nums.sort((a, b) => a - b);\n    const result = [];\n\n    for (let i = 0; i < nums.length - 2; i++) {\n        if (i == 0 || nums[i] != nums[i - 1]) {\n            let j = i + 1, k = nums.length - 1;\n            while (j < k) {\n                const sum = nums[i] + nums[j] + nums[k];\n                if (sum === 0) {\n                    result.push([nums[i], nums[j], nums[k]]);\n                    while (j < k && nums[j] === nums[j + 1]) j++;\n                    while (j < k && nums[k] === nums[k - 1]) k--;\n                    j++;\n                    k--;\n                } else if (sum < 0) {\n                    j++;\n                } else {\n                    k--;\n                }\n            }\n        }\n    }\n\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/16", "prompt": "Given an integer array `nums` of length `n` and an integer `target`, find three integers in `nums` such that the sum is closest to `target`.\n\nReturn _the sum of the three integers_.\n\nYou may assume that each input would have exactly one solution.\n\n**Example 1:**\n\n**Input:** nums = \\[-1,2,1,-4\\], target = 1\n**Output:** 2\n**Explanation:** The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n\n**Example 2:**\n\n**Input:** nums = \\[0,0,0\\], target = 1\n**Output:** 0\n**Explanation:** The sum that is closest to the target is 0. (0 + 0 + 0 = 0).\n\n**Constraints:**\n\n*   `3 <= nums.length <= 500`\n*   `-1000 <= nums[i] <= 1000`\n*   `-104 <= target <= 104`", "entry_point": "3sum_closest", "canonical_solutions": {"python": "def threeSumClosest(nums, target):\n    nums.sort()\n    closest = sum(nums[:3])\n    for i in range(len(nums) - 2):\n        left, right = i + 1, len(nums) - 1\n        while left < right:\n            cur_sum = nums[i] + nums[left] + nums[right]\n            if cur_sum == target:\n                return cur_sum\n            if abs(target - cur_sum) < abs(target - closest):\n                closest = cur_sum\n            if cur_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return closest", "java": "import java.util.Arrays;\n\npublic int threeSumClosest(int[] nums, int target) {\n    Arrays.sort(nums);\n    int closest = nums[0] + nums[1] + nums[2];\n    for (int i = 0; i < nums.length - 2; ++i) {\n        int left = i + 1;\n        int right = nums.length - 1;\n        while (left < right) {\n            int sum = nums[i] + nums[left] + nums[right];\n            if (sum == target) {\n                return sum;\n            }\n            if (Math.abs(target - sum) < Math.abs(target - closest)) {\n                closest = sum;\n            }\n            if (sum < target) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return closest;\n}", "cpp": "#include <algorithm>\n#include <vector>\n\nint threeSumClosest(std::vector<int>& nums, int target) {\n    std::sort(nums.begin(), nums.end());\n    int closest = nums[0] + nums[1] + nums[2];\n    for (int i = 0; i < nums.size() - 2; ++i) {\n        int left = i + 1;\n        int right = nums.size() - 1;\n        while (left < right) {\n            int sum = nums[i] + nums[left] + nums[right];\n            if (sum == target) {\n                return sum;\n            }\n            if (abs(target - sum) < abs(target - closest)) {\n                closest = sum;\n            }\n            if (sum < target) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return closest;\n}", "javascript": "function threeSumClosest(nums, target) {\n    nums.sort((a, b) => a - b);\n    let closest = nums[0] + nums[1] + nums[2];\n    for (let i = 0; i < nums.length - 2; ++i) {\n        let left = i + 1;\n        let right = nums.length - 1;\n        while (left < right) {\n            let sum = nums[i] + nums[left] + nums[right];\n            if (sum === target) {\n                return sum;\n            }\n            if (Math.abs(target - sum) < Math.abs(target - closest)) {\n                closest = sum;\n            }\n            if (sum < target) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return closest;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/17", "prompt": "Given a string containing digits from `2-9` inclusive, return all possible letter combinations that the number could represent. Return the answer in **any order**.\n\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n\n**Example 1:**\n\n**Input:** digits =  \"23 \"\n**Output:** \\[ \"ad \", \"ae \", \"af \", \"bd \", \"be \", \"bf \", \"cd \", \"ce \", \"cf \"\\]\n\n**Example 2:**\n\n**Input:** digits =  \" \"\n**Output:** \\[\\]\n\n**Example 3:**\n\n**Input:** digits =  \"2 \"\n**Output:** \\[ \"a \", \"b \", \"c \"\\]\n\n**Constraints:**\n\n*   `0 <= digits.length <= 4`\n*   `digits[i]` is a digit in the range `['2', '9']`.", "entry_point": "letter_combinations_of_a_phone_number", "canonical_solutions": {"python": "def letter_combinations(digits: str):\n    if not digits: return []\n    phone = [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"]\n    result = [\"\"]\n\n    for digit in digits:\n        temp = []\n        for s in result:\n            for c in phone[int(digit) - 2]:\n                temp.append(s + c)\n        result = temp\n\n    return result", "java": "public List<String> letterCombinations(String digits) {\n    LinkedList<String> output = new LinkedList<>();\n    if(digits.isEmpty()) return output;\n    \n    String[] phone = new String[] {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n    output.add(\"\");\n    \n    for(char d : digits.toCharArray()){\n        while(output.peek().length() == digits.indexOf(d)){\n            String perm = output.remove();\n            for(char c : phone[d - '2'].toCharArray()){\n                output.add(perm + c);\n            }\n        }\n    }\n    \n    return output;\n}", "cpp": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> letterCombinations(string digits) {\n    if(digits.empty()) return {};\n    vector<string> phone = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n    vector<string> result = {\"\"};\n\n    for (char d : digits) {\n        vector<string> temp;\n        for (const string &s : result) {\n            for (char c : phone[d - '2']) {\n                temp.push_back(s + c);\n            }\n        }\n        result.swap(temp);\n    }\n    return result;\n}", "javascript": "function letterCombinations(digits) {\n    if (digits.length === 0) return [];\n    \n    let phone = [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"];\n    let result = [\"\"];\n\n    for (let i = 0; i < digits.length; i++) {\n        let digit = digits[i];\n        let temp = [];\n\n        for (let s of result) {\n            for (let c of phone[digit - 2]) {\n                temp.push(s + c);\n            }\n        }\n\n        result = temp;\n    }\n\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/18", "prompt": "Given an array `nums` of `n` integers, return _an array of all the **unique** quadruplets_ `[nums[a], nums[b], nums[c], nums[d]]` such that:\n\n*   `0 <= a, b, c, d < n`\n*   `a`, `b`, `c`, and `d` are **distinct**.\n*   `nums[a] + nums[b] + nums[c] + nums[d] == target`\n\nYou may return the answer in **any order**.\n\n**Example 1:**\n\n**Input:** nums = \\[1,0,-1,0,-2,2\\], target = 0\n**Output:** \\[\\[-2,-1,1,2\\],\\[-2,0,0,2\\],\\[-1,0,0,1\\]\\]\n\n**Example 2:**\n\n**Input:** nums = \\[2,2,2,2,2\\], target = 8\n**Output:** \\[\\[2,2,2,2\\]\\]\n\n**Constraints:**\n\n*   `1 <= nums.length <= 200`\n*   `-109 <= nums[i] <= 109`\n*   `-109 <= target <= 109`", "entry_point": "4sum", "canonical_solutions": {"python": "def fourSum(nums, target):\n    nums.sort()\n    result = []\n    for i in range(len(nums) - 3):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        for j in range(i + 1, len(nums) - 2):\n            if j > i + 1 and nums[j] == nums[j - 1]:\n                continue\n            left = j + 1\n            right = len(nums) - 1\n            while left < right:\n                cur_sum = nums[i] + nums[j] + nums[left] + nums[right]\n                if cur_sum == target:\n                    result.append([nums[i], nums[j], nums[left], nums[right]])\n                    left += 1\n                    right -= 1\n                    while left < right and nums[left] == nums[left - 1]: left += 1\n                    while left < right and nums[right] == nums[right + 1]: right -= 1\n                elif cur_sum < target:\n                    left += 1\n                else:\n                    right -= 1\n    return result", "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic List<List<Integer>> fourSum(int[] nums, int target) {\n    List<List<Integer>> result = new ArrayList<>();\n    if(nums == null || nums.length < 4)\n        return result;\n\n    Arrays.sort(nums);\n    for(int i = 0; i < nums.length - 3; i++) {\n        if(i > 0 && nums[i] == nums[i-1])\n            continue;\n\n        for(int j = i + 1; j < nums.length - 2; j++) {\n            if(j > i + 1 && nums[j] == nums[j-1])\n                continue;\n\n            int left = j + 1;\n            int right = nums.length - 1;\n            while(left < right) {\n                int sum = nums[i] + nums[j] + nums[left] + nums[right];\n                if(sum == target) {\n                    result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\n                    ++left;\n                    --right;\n                    while(left < right && nums[left] == nums[left - 1]) ++left;\n                    while(left < right && nums[right] == nums[right + 1]) --right;\n                } else if(sum < target) {\n                    ++left;\n                } else {\n                    --right;\n                }\n            }\n        }\n    }\n    return result;\n}", "cpp": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int>> fourSum(vector<int>& nums, int target) {\n    vector<vector<int>> result;\n    int n = nums.size();\n    if(n < 4)\n        return result;\n\n    sort(nums.begin(), nums.end());\n    for(int i = 0; i < n - 3; i++) {\n        if(i > 0 && nums[i] == nums[i-1])\n            continue;\n\n        for(int j = i + 1; j < n - 2; j++) {\n            if(j > i + 1 && nums[j] == nums[j-1])\n                continue;\n\n            int left = j + 1;\n            int right = n - 1;\n            while(left < right) {\n                int sum = nums[i] + nums[j] + nums[left] + nums[right];\n                if(sum == target) {\n                    result.push_back({nums[i], nums[j], nums[left], nums[right]});\n                    ++left;\n                    --right;\n                    while(left < right && nums[left] == nums[left-1]) ++left;\n                    while(left < right && nums[right] == nums[right+1]) --right;\n                } else if(sum < target) {\n                    ++left;\n                } else {\n                    --right;\n                }\n            }\n        }\n    }\n    return result;\n}", "javascript": "function fourSum(nums, target) {\n    nums.sort((a, b) => a - b);\n    let result = [];\n    for (let i = 0; i < nums.length - 3; i++) {\n        if (i > 0 && nums[i] === nums[i - 1]) continue;\n\n        for (let j = i + 1; j < nums.length - 2; j++) {\n            if (j > i + 1 && nums[j] === nums[j - 1]) continue;\n\n            let left = j + 1;\n            let right = nums.length - 1;\n            while (left < right) {\n                const sum = nums[i] + nums[j] + nums[left] + nums[right];\n                if (sum === target) {\n                    result.push([nums[i], nums[j], nums[left], nums[right]]);\n                    left++;\n                    right--;\n                    while (left < right && nums[left] === nums[left - 1]) left++;\n                    while (left < right && nums[right] === nums[right + 1]) right--;\n                } else if (sum < target) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n    }\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/19", "prompt": "Given the `head` of a linked list, remove the `nth` node from the end of the list and return its head.\n\n**Example 1:**\n\n**Input:** head = \\[1,2,3,4,5\\], n = 2\n**Output:** \\[1,2,3,5\\]\n\n**Example 2:**\n\n**Input:** head = \\[1\\], n = 1\n**Output:** \\[\\]\n\n**Example 3:**\n\n**Input:** head = \\[1,2\\], n = 1\n**Output:** \\[1\\]\n\n**Constraints:**\n\n*   The number of nodes in the list is `sz`.\n*   `1 <= sz <= 30`\n*   `0 <= Node.val <= 100`\n*   `1 <= n <= sz`\n\n**Follow up:** Could you do this in one pass?", "entry_point": "remove_nth_node_from_end_of_list", "canonical_solutions": {"python": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef removeNthFromEnd(head, n):\n    first = head\n    second = head\n    \n    for i in range(n):\n        first = first.next\n    \n    if not first:\n        head = head.next\n        return head\n    \n    while first.next:\n        first = first.next\n        second = second.next\n    \n    second.next = second.next.next\n    \n    return head", "java": "public class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) { val = x; }\n}\n\npublic ListNode removeNthFromEnd(ListNode head, int n) {\n    ListNode first = head;\n    ListNode second = head;\n    \n    for (int i = 0; i < n; i++) {\n        first = first.next;\n    }\n    \n    if (first == null) {\n        head = head.next;\n        return head;\n    }\n    \n    while (first.next != null) {\n        first = first.next;\n        second = second.next;\n    }\n\n    second.next = second.next.next;\n    \n    return head;\n}", "cpp": "class ListNode {\npublic:\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n}; \n\nListNode* removeNthFromEnd(ListNode* head, int n) {\n    ListNode* first = head;\n    ListNode* second = head;\n    \n    for (int i = 0; i < n; i++) {\n        first = first->next;\n    }\n    \n    if (first == NULL) {\n        head = head->next;\n        return head;\n    }\n    \n    while (first->next != NULL) {\n        first = first->next;\n        second = second->next;\n    }\n\n    second->next = second->next->next;\n    \n    return head;\n}", "javascript": "class ListNode {\n    constructor(val = 0, next = null) {\n        this.val = val;\n        this.next = next;\n    }\n}\n\nfunction removeNthFromEnd(head, n) {\n    let first = head;\n    let second = head;\n    \n    for (let i = 0; i < n; i++) {\n        first = first.next;\n    }\n    \n    if (first === null) {\n        head = head.next;\n        return head;\n    }\n    \n    while (first.next !== null) {\n        first = first.next;\n        second = second.next;\n    }\n\n    second.next = second.next.next;\n    \n    return head;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/20", "prompt": "Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.\n\nAn input string is valid if:\n\n1.  Open brackets must be closed by the same type of brackets.\n2.  Open brackets must be closed in the correct order.\n3.  Every close bracket has a corresponding open bracket of the same type.\n\n**Example 1:**\n\n**Input:** s =  \"() \"\n**Output:** true\n\n**Example 2:**\n\n**Input:** s =  \"()\\[\\]{} \"\n**Output:** true\n\n**Example 3:**\n\n**Input:** s =  \"(\\] \"\n**Output:** false\n\n**Constraints:**\n\n*   `1 <= s.length <= 104`\n*   `s` consists of parentheses only `'()[]{}'`.", "entry_point": "valid_parentheses", "canonical_solutions": {"python": "def is_valid(s: str) -> bool:\n    stack = []\n\n    for c in s:\n        if c in '([{':\n            stack.append(c)\n        else:\n            if not stack:\n                return False\n            if c == ')' and stack[-1] != '(':\n                return False\n            if c == '}' and stack[-1] != '{':\n                return False\n            if c == ']' and stack[-1] != '[':\n                return False\n            stack.pop()\n\n    return not stack", "java": "boolean isValid(String s) {\n    Stack<Character> stack = new Stack<>();\n\n    for (char c : s.toCharArray()) {\n        if (c == '(' || c == '{' || c == '[') {\n            stack.push(c);\n        } else {\n            if (stack.empty()) return false;\n            if (c == ')' && stack.peek() != '(') return false;\n            if (c == '}' && stack.peek() != '{') return false;\n            if (c == ']' && stack.peek() != '[') return false;\n            stack.pop();\n        }\n    }\n\n    return stack.empty();\n}", "cpp": "bool isValid(std::string s) {\n    std::stack<char> stack;\n\n    for (char c : s) {\n        if (c == '(' || c == '{' || c == '[') {\n            stack.push(c);\n        } else {\n            if (stack.empty()) return false;\n            if (c == ')' && stack.top() != '(') return false;\n            if (c == '}' && stack.top() != '{') return false;\n            if (c == ']' && stack.top() != '[') return false;\n            stack.pop();\n        }\n    }\n\n    return stack.empty();\n}", "javascript": "function isValid(s) {\n    const stack = [];\n\n    for (const c of s) {\n        if (c === '(' || c === '{' || c === '[') {\n            stack.push(c);\n        } else {\n            if (!stack.length) return false;\n            if (c === ')' && stack[stack.length - 1] !== '(') return false;\n            if (c === '}' && stack[stack.length - 1] !== '{') return false;\n            if (c === ']' && stack[stack.length - 1] !== '[') return false;\n            stack.pop();\n        }\n    }\n\n    return stack.length === 0;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/21", "prompt": "You are given the heads of two sorted linked lists `list1` and `list2`.\n\nMerge the two lists in a one **sorted** list. The list should be made by splicing together the nodes of the first two lists.\n\nReturn _the head of the merged linked list_.\n\n**Example 1:**\n\n**Input:** list1 = \\[1,2,4\\], list2 = \\[1,3,4\\]\n**Output:** \\[1,1,2,3,4,4\\]\n\n**Example 2:**\n\n**Input:** list1 = \\[\\], list2 = \\[\\]\n**Output:** \\[\\]\n\n**Example 3:**\n\n**Input:** list1 = \\[\\], list2 = \\[0\\]\n**Output:** \\[0\\]\n\n**Constraints:**\n\n*   The number of nodes in both lists is in the range `[0, 50]`.\n*   `-100 <= Node.val <= 100`\n*   Both `list1` and `list2` are sorted in **non-decreasing** order.", "entry_point": "merge_two_sorted_lists", "canonical_solutions": {"python": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n         \ndef merge_two_lists(list1, list2):\n    if list1 is None:\n        return list2\n    if list2 is None:\n        return list1\n\n    if list1.val < list2.val:\n        list1.next = merge_two_lists(list1.next, list2)\n        return list1\n    else:\n        list2.next = merge_two_lists(list1, list2.next)\n        return list2", "java": "public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n    if (list1 == null) return list2;\n    if (list2 == null) return list1;\n\n    if (list1.val < list2.val) {\n        list1.next = mergeTwoLists(list1.next, list2);\n        return list1;\n    } else {\n        list2.next = mergeTwoLists(list1, list2.next);\n        return list2;\n    }\n}", "cpp": "ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n    if (list1 == nullptr) return list2;\n    if (list2 == nullptr) return list1;\n\n    if (list1->val < list2->val) {\n        list1->next = mergeTwoLists(list1->next, list2);\n        return list1;\n    } else {\n        list2->next = mergeTwoLists(list1, list2->next);\n        return list2;\n    }\n}", "javascript": "function ListNode(val, next) {\n    this.val = val === undefined ? 0 : val;\n    this.next = next === undefined ? null : next;\n}\n\nfunction mergeTwoLists(list1, list2) {\n    if (list1 === null) return list2;\n    if (list2 === null) return list1;\n\n    if (list1.val < list2.val) {\n        list1.next = mergeTwoLists(list1.next, list2);\n        return list1;\n    } else {\n        list2.next = mergeTwoLists(list1, list2.next);\n        return list2;\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/22", "prompt": "Given `n` pairs of parentheses, write a function to _generate all combinations of well-formed parentheses_.\n\n**Example 1:**\n\n**Input:** n = 3\n**Output:** \\[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"\\]\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** \\[\"()\"\\]\n\n**Constraints:**\n\n*   `1 <= n <= 8`", "entry_point": "generate_parentheses", "canonical_solutions": {"python": "def generate_parenthesis(n):\n    def generate_parenthesis_helper(open, close, current):\n        if open == 0 and close == 0:\n            result.append(current)\n            return\n        if open > 0:\n            generate_parenthesis_helper(open - 1, close + 1, current + '(')\n        if close > 0:\n            generate_parenthesis_helper(open, close - 1, current + ')')\n\n    result = []\n    generate_parenthesis_helper(n, 0, '')\n    return result", "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> generateParenthesis(int n) {\n    List<String> result = new ArrayList<>();\n    generateParenthesisHelper(n, 0, \"\", result);\n    return result;\n}\n\nprivate void generateParenthesisHelper(int open, int close, String current, List<String> result) {\n    if (open == 0 && close == 0) {\n        result.add(current);\n        return;\n    }\n    if (open > 0) {\n        generateParenthesisHelper(open - 1, close + 1, current + '(', result);\n    }\n    if (close > 0) {\n        generateParenthesisHelper(open, close - 1, current + ')', result);\n    }\n}", "cpp": "#include <vector>\n#include <string>\n\nvoid generateParenthesisHelper(int open, int close, std::string current, std::vector<std::string>& result) {\n    if (open == 0 && close == 0) {\n        result.push_back(current);\n        return;\n    }\n    if (open > 0) {\n        generateParenthesisHelper(open - 1, close + 1, current + '(', result);\n    }\n    if (close > 0) {\n        generateParenthesisHelper(open, close - 1, current + ')', result);\n    }\n}\n\nstd::vector<std::string> generateParenthesis(int n) {\n    std::vector<std::string> result;\n    generateParenthesisHelper(n, 0, \"\", result);\n    return result;\n}", "javascript": "function generateParenthesis(n) {\n    function generateParenthesisHelper(open, close, current, result) {\n        if (open === 0 && close === 0) {\n            result.push(current);\n            return;\n        }\n        if (open > 0) {\n            generateParenthesisHelper(open - 1, close + 1, current + '(', result);\n        }\n        if (close > 0) {\n            generateParenthesisHelper(open, close - 1, current + ')', result);\n        }\n    }\n\n    let result = [];\n    generateParenthesisHelper(n, 0, '', result);\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/23", "prompt": "You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order.\n\n_Merge all the linked-lists into one sorted linked-list and return it._\n\n**Example 1:**\n\n**Input:** lists = \\[\\[1,4,5\\],\\[1,3,4\\],\\[2,6\\]\\]\n**Output:** \\[1,1,2,3,4,4,5,6\\]\n**Explanation:** The linked-lists are:\n\\[\n  1->4->5,\n  1->3->4,\n  2->6\n\\]\nmerging them into one sorted list:\n1->1->2->3->4->4->5->6\n\n**Example 2:**\n\n**Input:** lists = \\[\\]\n**Output:** \\[\\]\n\n**Example 3:**\n\n**Input:** lists = \\[\\[\\]\\]\n**Output:** \\[\\]\n\n**Constraints:**\n\n*   `k == lists.length`\n*   `0 <= k <= 104`\n*   `0 <= lists[i].length <= 500`\n*   `-104 <= lists[i][j] <= 104`\n*   `lists[i]` is sorted in **ascending order**.\n*   The sum of `lists[i].length` will not exceed `104`.", "entry_point": "merge_k_sorted_lists", "canonical_solutions": {"python": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n        \nclass Solution:\n    def mergeKLists(self, lists):\n        if not lists: return None\n        while len(lists) > 1:\n            lists.append(self.merge2Lists(lists.pop(0), lists.pop(0)))\n        return lists[0]\n        \n    def merge2Lists(self, l1, l2):\n        if not l1: return l2\n        if not l2: return l1\n        if l1.val <= l2.val:\n            l1.next = self.merge2Lists(l1.next, l2)\n            return l1\n        else:\n            l2.next = self.merge2Lists(l1, l2.next)\n            return l2", "java": "public class ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        if(lists.length == 0) return null;\n        while(lists.length > 1){\n            List<ListNode> tempList = new ArrayList<>();\n            tempList.add(mergeTwoLists(lists[0],lists[1]));\n            tempList.addAll(Arrays.asList(lists).subList(2, lists.length));\n            lists = tempList.toArray(new ListNode[tempList.size()]);\n        }\n        return lists[0];\n    }\n\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if(l1 == null) return l2;\n        if(l2 == null) return l1;\n        if(l1.val <= l2.val){\n            l1.next = mergeTwoLists(l1.next, l2);\n            return l1;\n        } else {\n            l2.next = mergeTwoLists(l1, l2.next);\n            return l2;\n        }\n    }\n}", "cpp": "struct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        if(lists.empty()) return nullptr;\n        while(lists.size()>1){\n            lists.push_back(merge2Lists(lists[0],lists[1]));\n            lists.erase(lists.begin());\n            lists.erase(lists.begin());\n        }\n        return lists[0];\n    }\n    \n     ListNode* merge2Lists(ListNode* l1, ListNode* l2){\n        if(!l1) return l2;\n        if(!l2) return l1;\n        if(l1->val <= l2->val){\n            l1->next = merge2Lists(l1->next, l2);\n            return l1;\n        }\n        else{\n            l2->next = merge2Lists(l1, l2->next);\n            return l2;\n        }\n    }\n};", "javascript": "class ListNode {\n    constructor(val=0, next=null) {\n        this.val = val;\n        this.next = next;\n    }\n}\n\nfunction mergeKLists(lists) {\n    if(lists.length === 0) return null;\n    while(lists.length > 1){\n        lists.push(merge2Lists(lists.shift(), lists.shift()));\n    }\n    return lists[0];\n}\n\nfunction merge2Lists(l1, l2){\n    if(!l1) return l2;\n    if(!l2) return l1;\n    if(l1.val <= l2.val){\n        l1.next = merge2Lists(l1.next, l2);\n        return l1;\n    }\n    else{\n        l2.next = merge2Lists(l1, l2.next);\n        return l2;\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/24", "prompt": "Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)\n\n**Example 1:**\n\n**Input:** head = \\[1,2,3,4\\]\n**Output:** \\[2,1,4,3\\]\n\n**Example 2:**\n\n**Input:** head = \\[\\]\n**Output:** \\[\\]\n\n**Example 3:**\n\n**Input:** head = \\[1\\]\n**Output:** \\[1\\]\n\n**Constraints:**\n\n*   The number of nodes in the list is in the range `[0, 100]`.\n*   `0 <= Node.val <= 100`", "entry_point": "swap_nodes_in_pairs", "canonical_solutions": {"python": "def swapPairs(head: Optional[ListNode]) -> Optional[ListNode]:\n    if not head or not head.next:\n        return head\n\n    second = head.next\n    head.next = swapPairs(second.next)\n    second.next = head\n\n    return second", "java": "public ListNode swapPairs(ListNode head) {\n    if (head == null || head.next == null) return head;\n    \n    ListNode second = head.next;\n    head.next = swapPairs(second.next);\n    second.next = head;\n    \n    return second;\n}", "cpp": "ListNode* swapPairs(ListNode* head) {\n    if (!head || !head->next) return head;\n\n    ListNode* second = head->next;\n    head->next = swapPairs(second->next);\n    second->next = head;\n    \n    return second;\n}", "javascript": "function swapPairs(head) {\n    if (!head || !head.next) return head;\n\n    let second = head.next;\n    head.next = swapPairs(second.next);\n    second.next = head;\n\n    return second;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/25", "prompt": "Given the `head` of a linked list, reverse the nodes of the list `k` at a time, and return _the modified list_.\n\n`k` is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of `k` then left-out nodes, in the end, should remain as it is.\n\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.\n\n**Example 1:**\n\n**Input:** head = \\[1,2,3,4,5\\], k = 2\n**Output:** \\[2,1,4,3,5\\]\n\n**Example 2:**\n\n**Input:** head = \\[1,2,3,4,5\\], k = 3\n**Output:** \\[3,2,1,4,5\\]\n\n**Constraints:**\n\n*   The number of nodes in the list is `n`.\n*   `1 <= k <= n <= 5000`\n*   `0 <= Node.val <= 1000`\n\n**Follow-up:** Can you solve the problem in `O(1)` extra memory space?", "entry_point": "reverse_nodes_in_k_group", "canonical_solutions": {"python": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef reverseKGroup(head, k):\n    if not head or k == 1:\n        return head\n        \n    cur = head\n    length = 0\n    while cur:\n        length += 1\n        cur = cur.next\n        \n    dummy = ListNode(0)\n    dummy.next = head\n    prev = dummy\n    cur = head\n    \n    while length >= k:\n        for _ in range(1, k):\n            temp = cur.next\n            cur.next = temp.next\n            temp.next = prev.next\n            prev.next = temp\n            \n        prev = cur\n        cur = cur.next\n        length -= k\n        \n    return dummy.next", "java": "public class ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\npublic ListNode reverseKGroup(ListNode head, int k) {\n    if (head == null || k == 1) return head;\n    \n    int len = 0;\n    ListNode cur = head;\n    while (cur != null) {\n        len++;\n        cur = cur.next;\n    }\n    \n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    ListNode prev = dummy;\n    cur = head;\n    \n    while (len >= k) {\n        for (int i = 1; i < k; i++) {\n            ListNode temp = cur.next;\n            cur.next = temp.next;\n            temp.next = prev.next;\n            prev.next = temp;\n        }\n        prev = cur;\n        cur = cur.next;\n        len -= k;\n    }\n    \n    return dummy.next;\n}", "cpp": "struct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nListNode* reverseKGroup(ListNode* head, int k) {\n    if (head == nullptr || k == 1) return head;\n    \n    int len = 0;\n    ListNode *cur = head;\n    while (cur != nullptr) {\n        len++;\n        cur = cur->next;\n    }\n    \n    ListNode dummy(0);\n    dummy.next = head;\n    ListNode *prev = &dummy;\n    cur = head;\n    \n    while (len >= k) {\n        for (int i = 1; i < k; i++) {\n            ListNode *temp = cur->next;\n            cur->next = temp->next;\n            temp->next = prev->next;\n            prev->next = temp;\n        }\n        prev = cur;\n        cur = cur->next;\n        len -= k;\n    }\n    \n    return dummy.next;\n}", "javascript": "class ListNode {\n    constructor(val = 0, next = null) {\n        this.val = val;\n        this.next = next;\n    }\n}\n\nfunction reverseKGroup(head, k) {\n    if (!head || k === 1) return head;\n    \n    let len = 0;\n    let cur = head;\n    while (cur) {\n        len++;\n        cur = cur.next;\n    }\n    \n    const dummy = new ListNode(0);\n    dummy.next = head;\n    let prev = dummy;\n    cur = head;\n    \n    while (len >= k) {\n        for (let i = 1; i < k; i++) {\n            let temp = cur.next;\n            cur.next = temp.next;\n            temp.next = prev.next;\n            prev.next = temp;\n        }\n        prev = cur;\n        cur = cur.next;\n        len -= k;\n    }\n    \n    return dummy.next;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/26", "prompt": "Given an integer array `nums` sorted in **non-decreasing order**, remove the duplicates [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm) such that each unique element appears only **once**. The **relative order** of the elements should be kept the **same**. Then return _the number of unique elements in_ `nums`.\n\nConsider the number of unique elements of `nums` be `k`, to get accepted, you need to do the following things:\n\n*   Change the array `nums` such that the first `k` elements of `nums` contain the unique elements in the order they were present in `nums` initially. The remaining elements of `nums` are not important as well as the size of `nums`.\n*   Return `k`.\n\n**Custom Judge:**\n\nThe judge will test your solution with the following code:\n\nint\\[\\] nums = \\[...\\]; // Input array\nint\\[\\] expectedNums = \\[...\\]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums\\[i\\] == expectedNums\\[i\\];\n}\n\nIf all assertions pass, then your solution will be **accepted**.\n\n**Example 1:**\n\n**Input:** nums = \\[1,1,2\\]\n**Output:** 2, nums = \\[1,2,\\_\\]\n**Explanation:** Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n**Example 2:**\n\n**Input:** nums = \\[0,0,1,1,1,2,2,3,3,4\\]\n**Output:** 5, nums = \\[0,1,2,3,4,\\_,\\_,\\_,\\_,\\_\\]\n**Explanation:** Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n**Constraints:**\n\n*   `1 <= nums.length <= 3 * 104`\n*   `-100 <= nums[i] <= 100`\n*   `nums` is sorted in **non-decreasing** order.", "entry_point": "remove_duplicates_from_sorted_array", "canonical_solutions": {"python": "def removeDuplicates(nums):\n    if not nums: return 0\n    i = 0\n    for j in range(1, len(nums)):\n        if nums[j] != nums[i]:\n            i += 1\n            nums[i] = nums[j]\n    return i + 1", "java": "public int removeDuplicates(int[] nums) {\n    if (nums.length == 0) return 0;\n    int i = 0;\n    for (int j = 1; j < nums.length; j++) {\n        if (nums[j] != nums[i]) {\n            i++;\n            nums[i] = nums[j];\n        }\n    }\n    return i + 1;\n}", "cpp": "int removeDuplicates(vector<int>& nums) {\n    if (nums.empty()) return 0;\n    int i = 0;\n    for (int j = 1; j < nums.size(); j++) {\n        if (nums[j] != nums[i]) {\n            i++;\n            nums[i] = nums[j];\n        }\n    }\n    return i + 1;\n}", "javascript": "function removeDuplicates(nums) {\n    if (nums.length === 0) return 0;\n    let i = 0;\n    for (let j = 1; j < nums.length; j++) {\n        if (nums[j] !== nums[i]) {\n            i++;\n            nums[i] = nums[j];\n        }\n    }\n    return i + 1;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/27", "prompt": "Given an integer array `nums` and an integer `val`, remove all occurrences of `val` in `nums` [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm). The order of the elements may be changed. Then return _the number of elements in_ `nums` _which are not equal to_ `val`.\n\nConsider the number of elements in `nums` which are not equal to `val` be `k`, to get accepted, you need to do the following things:\n\n*   Change the array `nums` such that the first `k` elements of `nums` contain the elements which are not equal to `val`. The remaining elements of `nums` are not important as well as the size of `nums`.\n*   Return `k`.\n\n**Custom Judge:**\n\nThe judge will test your solution with the following code:\n\nint\\[\\] nums = \\[...\\]; // Input array\nint val = ...; // Value to remove\nint\\[\\] expectedNums = \\[...\\]; // The expected answer with correct length.\n                            // It is sorted with no values equaling val.\n\nint k = removeElement(nums, val); // Calls your implementation\n\nassert k == expectedNums.length;\nsort(nums, 0, k); // Sort the first k elements of nums\nfor (int i = 0; i < actualLength; i++) {\n    assert nums\\[i\\] == expectedNums\\[i\\];\n}\n\nIf all assertions pass, then your solution will be **accepted**.\n\n**Example 1:**\n\n**Input:** nums = \\[3,2,2,3\\], val = 3\n**Output:** 2, nums = \\[2,2,\\_,\\_\\]\n**Explanation:** Your function should return k = 2, with the first two elements of nums being 2.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n**Example 2:**\n\n**Input:** nums = \\[0,1,2,2,3,0,4,2\\], val = 2\n**Output:** 5, nums = \\[0,1,4,0,3,\\_,\\_,\\_\\]\n**Explanation:** Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\nNote that the five elements can be returned in any order.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n**Constraints:**\n\n*   `0 <= nums.length <= 100`\n*   `0 <= nums[i] <= 50`\n*   `0 <= val <= 100`", "entry_point": "remove_element", "canonical_solutions": {"python": "def removeElement(nums, val):\n    i = 0\n    for j in range(len(nums)):\n        if nums[j] != val:\n            nums[i] = nums[j]\n            i += 1\n    return i", "java": "public int removeElement(int[] nums, int val) {\n    int i = 0;\n    for (int j = 0; j < nums.length; j++) {\n        if (nums[j] != val) {\n            nums[i] = nums[j];\n            i++;\n        }\n    }\n    return i;\n}", "cpp": "int removeElement(vector<int>& nums, int val) {\n    int i = 0;\n    for (int j = 0; j < nums.size(); j++) {\n        if (nums[j] != val) {\n            nums[i] = nums[j];\n            i++;\n        }\n    }\n    return i;\n}", "javascript": "function removeElement(nums, val) {\n    let i = 0;\n    for (let j = 0; j < nums.length; j++) {\n        if (nums[j] !== val) {\n            nums[i] = nums[j];\n            i++;\n        }\n    }\n    return i;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/28", "prompt": "Given two strings `needle` and `haystack`, return the index of the first occurrence of `needle` in `haystack`, or `-1` if `needle` is not part of `haystack`.\n\n**Example 1:**\n\n**Input:** haystack =  \"sadbutsad \", needle =  \"sad \"\n**Output:** 0\n**Explanation:**  \"sad \" occurs at index 0 and 6.\nThe first occurrence is at index 0, so we return 0.\n\n**Example 2:**\n\n**Input:** haystack =  \"leetcode \", needle =  \"leeto \"\n**Output:** -1\n**Explanation:**  \"leeto \" did not occur in  \"leetcode \", so we return -1.\n\n**Constraints:**\n\n*   `1 <= haystack.length, needle.length <= 104`\n*   `haystack` and `needle` consist of only lowercase English characters.", "entry_point": "find_the_index_of_the_first_occurrence_in_a_string", "canonical_solutions": {"python": "def strStr(haystack: str, needle: str) -> int:\n    if not needle:\n        return 0\n    try:\n        index = haystack.index(needle)\n        return index\n    except ValueError:\n        return -1", "java": "public int strStr(String haystack, String needle) {\n    if (needle.isEmpty()) return 0;\n    \n    int index = haystack.indexOf(needle);\n    return index;\n}", "cpp": "int strStr(string haystack, string needle) {\n    if(needle.empty()) return 0;\n\n    size_t pos = haystack.find(needle);\n    if(pos != string::npos)\n        return pos;\n    return -1;\n}", "javascript": "function strStr(haystack, needle) {\n    if (needle === '') return 0;\n\n    let index = haystack.indexOf(needle);\n    return index;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/29", "prompt": "Given two integers `dividend` and `divisor`, divide two integers **without** using multiplication, division, and mod operator.\n\nThe integer division should truncate toward zero, which means losing its fractional part. For example, `8.345` would be truncated to `8`, and `-2.7335` would be truncated to `-2`.\n\nReturn _the **quotient** after dividing_ `dividend` _by_ `divisor`.\n\n**Note:** Assume we are dealing with an environment that could only store integers within the **32-bit** signed integer range: `[-231, 231 - 1]`. For this problem, if the quotient is **strictly greater than** `231 - 1`, then return `231 - 1`, and if the quotient is **strictly less than** `-231`, then return `-231`.\n\n**Example 1:**\n\n**Input:** dividend = 10, divisor = 3\n**Output:** 3\n**Explanation:** 10/3 = 3.33333.. which is truncated to 3.\n\n**Example 2:**\n\n**Input:** dividend = 7, divisor = -3\n**Output:** -2\n**Explanation:** 7/-3 = -2.33333.. which is truncated to -2.\n\n**Constraints:**\n\n*   `-231 <= dividend, divisor <= 231 - 1`\n*   `divisor != 0`", "entry_point": "divide_two_integers", "canonical_solutions": {"python": "def divide(dividend: int, divisor: int) -> int:\n    if dividend == -(2**31) and divisor == -1:\n        return 2**31 - 1\n\n    sign = -1 if (dividend > 0) ^ (divisor > 0) else 1\n\n    dvd = abs(dividend)\n    dvs = abs(divisor)\n    ans = 0\n\n    while dvd >= dvs:\n        temp = dvs\n        multiple = 1\n        while dvd >= (temp << 1):\n            temp <<= 1\n            multiple <<= 1\n        dvd -= temp\n        ans += multiple\n\n    return ans * sign", "java": "public int divide(int dividend, int divisor) {\n    if (dividend == Integer.MIN_VALUE && divisor == -1) {\n        return Integer.MAX_VALUE;\n    }\n\n    int sign = (dividend > 0) ^ (divisor > 0) ? -1 : 1;\n\n    long dvd = Math.abs((long) dividend);\n    long dvs = Math.abs((long) divisor);\n    int ans = 0;\n\n    while (dvd >= dvs) {\n        long temp = dvs, multiple = 1;\n        while (dvd >= (temp << 1)) {\n            temp <<= 1;\n            multiple <<= 1;\n        }\n        dvd -= temp;\n        ans += multiple;\n    }\n\n    return ans * sign;\n}", "cpp": "int divide(int dividend, int divisor) {\n    if (dividend == INT_MIN && divisor == -1) {\n        return INT_MAX;\n    }\n\n    int sign = (dividend > 0) ^ (divisor > 0) ? -1 : 1;\n\n    long long dvd = labs(dividend);\n    long long dvs = labs(divisor);\n    int ans = 0;\n\n    while (dvd >= dvs) {\n        long long temp = dvs, multiple = 1;\n        while (dvd >= (temp << 1)) {\n            temp <<= 1;\n            multiple <<= 1;\n        }\n        dvd -= temp;\n        ans += multiple;\n    }\n\n    return ans * sign;\n}", "javascript": "function divide(dividend, divisor) {\n    if (dividend === -Math.pow(2, 31) && divisor === -1) {\n        return Math.pow(2, 31) - 1;\n    }\n\n    const sign = (dividend > 0) ^ (divisor > 0) ? -1 : 1;\n\n    let dvd = Math.abs(dividend);\n    let dvs = Math.abs(divisor);\n    let ans = 0;\n\n    while (dvd >= dvs) {\n        let temp = dvs;\n        let multiple = 1;\n        while (dvd >= (temp << 1)) {\n            temp <<= 1;\n            multiple <<= 1;\n        }\n        dvd -= temp;\n        ans += multiple;\n    }\n\n    return ans * sign;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/30", "prompt": "You are given a string `s` and an array of strings `words`. All the strings of `words` are of **the same length**.\n\nA **concatenated substring** in `s` is a substring that contains all the strings of any permutation of `words` concatenated.\n\n*   For example, if `words = [ \"ab \", \"cd \", \"ef \"]`, then `\"abcdef \"`, `\"abefcd \"`, `\"cdabef \"`, `\"cdefab \"`, `\"efabcd \"`, and `\"efcdab \"` are all concatenated strings. `\"acdbef \"` is not a concatenated substring because it is not the concatenation of any permutation of `words`.\n\nReturn _the starting indices of all the concatenated substrings in_ `s`. You can return the answer in **any order**.\n\n**Example 1:**\n\n**Input:** s =  \"barfoothefoobarman \", words = \\[ \"foo \", \"bar \"\\]\n**Output:** \\[0,9\\]\n**Explanation:** Since words.length == 2 and words\\[i\\].length == 3, the concatenated substring has to be of length 6.\nThe substring starting at 0 is  \"barfoo \". It is the concatenation of \\[ \"bar \", \"foo \"\\] which is a permutation of words.\nThe substring starting at 9 is  \"foobar \". It is the concatenation of \\[ \"foo \", \"bar \"\\] which is a permutation of words.\nThe output order does not matter. Returning \\[9,0\\] is fine too.\n\n**Example 2:**\n\n**Input:** s =  \"wordgoodgoodgoodbestword \", words = \\[ \"word \", \"good \", \"best \", \"word \"\\]\n**Output:** \\[\\]\n**Explanation:** Since words.length == 4 and words\\[i\\].length == 4, the concatenated substring has to be of length 16.\nThere is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\nWe return an empty array.\n\n**Example 3:**\n\n**Input:** s =  \"barfoofoobarthefoobarman \", words = \\[ \"bar \", \"foo \", \"the \"\\]\n**Output:** \\[6,9,12\\]\n**Explanation:** Since words.length == 3 and words\\[i\\].length == 3, the concatenated substring has to be of length 9.\nThe substring starting at 6 is  \"foobarthe \". It is the concatenation of \\[ \"foo \", \"bar \", \"the \"\\] which is a permutation of words.\nThe substring starting at 9 is  \"barthefoo \". It is the concatenation of \\[ \"bar \", \"the \", \"foo \"\\] which is a permutation of words.\nThe substring starting at 12 is  \"thefoobar \". It is the concatenation of \\[ \"the \", \"foo \", \"bar \"\\] which is a permutation of words.\n\n**Constraints:**\n\n*   `1 <= s.length <= 104`\n*   `1 <= words.length <= 5000`\n*   `1 <= words[i].length <= 30`\n*   `s` and `words[i]` consist of lowercase English letters.", "entry_point": "substring_with_concatenation_of_all_words", "canonical_solutions": {"python": "from collections import Counter\n\ndef findSubstring(s, words):\n    if not s or not words:\n        return []\n\n    word_count = Counter(words)\n    word_length = len(words[0])\n    total_words = len(words)\n    total_length = word_length * total_words\n    result = []\n\n    for i in range(len(s) - total_length + 1):\n        temp_word_count = Counter()\n        for j in range(total_words):\n            current_word = s[i + j * word_length:i + (j + 1) * word_length]\n            if current_word not in word_count:\n                break\n            temp_word_count[current_word] += 1\n            if temp_word_count[current_word] > word_count[current_word]:\n                break\n            if j + 1 == total_words:\n                result.append(i)\n\n    return result", "java": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic List<Integer> findSubstring(String s, String[] words) {\n    if (s == null || s.length() == 0 || words == null || words.length == 0) return new ArrayList<>();\n    \n    Map<String, Integer> word_count = new HashMap<>();\n    for (String word : words) {\n        word_count.put(word, word_count.getOrDefault(word, 0) + 1);\n    }\n    \n    int word_length = words[0].length();\n    int total_words = words.length;\n    int total_length = word_length * total_words;\n    List<Integer> result = new ArrayList<>();\n    \n    for (int i = 0; i <= s.length() - total_length; i++) {\n        Map<String, Integer> temp_word_count = new HashMap<>();\n        for (int j = 0; j < total_words; j++) {\n            String current_word = s.substring(i + j * word_length, i + (j + 1) * word_length);\n            if (!word_count.containsKey(current_word)) break;\n            temp_word_count.put(current_word, temp_word_count.getOrDefault(current_word, 0) + 1);\n            if (temp_word_count.get(current_word) > word_count.get(current_word)) break;\n            if (j + 1 == total_words) result.add(i);\n        }\n    }\n    \n    return result;\n}", "cpp": "#include <vector>\n#include <string>\n#include <unordered_map>\n\nstd::vector<int> findSubstring(std::string s, std::vector<std::string>& words) {\n    if (s.empty() || words.empty()) return {};\n    \n    std::unordered_map<std::string, int> word_count;\n    for (const auto& word : words) {\n        ++word_count[word];\n    }\n    \n    int word_length = words[0].size();\n    int total_words = words.size();\n    int total_length = word_length * total_words;\n    std::vector<int> result;\n    \n    for (int i = 0; i <= (int)s.size() - total_length; ++i) {\n        std::unordered_map<std::string, int> temp_word_count;\n        for (int j = 0; j < total_words; ++j) {\n            std::string current_word = s.substr(i + j * word_length, word_length);\n            if (word_count.find(current_word) == word_count.end()) break;\n            ++temp_word_count[current_word];\n            if (temp_word_count[current_word] > word_count[current_word]) break;\n            if (j + 1 == total_words) result.push_back(i);\n        }\n    }\n    \n    return result;\n}", "javascript": "function findSubstring(s, words) {\n    if (!s || !words || words.length === 0) return [];\n\n    const word_count = new Map();\n    for (const word of words) {\n        word_count.set(word, (word_count.get(word) || 0) + 1);\n    }\n\n    const word_length = words[0].length;\n    const total_words = words.length;\n    const total_length = word_length * total_words;\n    const result = [];\n\n    for (let i = 0; i <= s.length - total_length; i++) {\n        const temp_word_count = new Map();\n        for (let j = 0; j < total_words; j++) {\n            const current_word = s.substr(i + j * word_length, word_length);\n            if (!word_count.has(current_word)) break;\n            temp_word_count.set(current_word, (temp_word_count.get(current_word) || 0) + 1);\n            if (temp_word_count.get(current_word) > word_count.get(current_word)) break;\n            if (j + 1 === total_words) result.push(i);\n        }\n    }\n\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/31", "prompt": "A **permutation** of an array of integers is an arrangement of its members into a sequence or linear order.\n\n*   For example, for `arr = [1,2,3]`, the following are all the permutations of `arr`: `[1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1]`.\n\nThe **next permutation** of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the **next permutation** of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n\n*   For example, the next permutation of `arr = [1,2,3]` is `[1,3,2]`.\n*   Similarly, the next permutation of `arr = [2,3,1]` is `[3,1,2]`.\n*   While the next permutation of `arr = [3,2,1]` is `[1,2,3]` because `[3,2,1]` does not have a lexicographical larger rearrangement.\n\nGiven an array of integers `nums`, _find the next permutation of_ `nums`.\n\nThe replacement must be **[in place](http://en.wikipedia.org/wiki/In-place_algorithm)** and use only constant extra memory.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3\\]\n**Output:** \\[1,3,2\\]\n\n**Example 2:**\n\n**Input:** nums = \\[3,2,1\\]\n**Output:** \\[1,2,3\\]\n\n**Example 3:**\n\n**Input:** nums = \\[1,1,5\\]\n**Output:** \\[1,5,1\\]\n\n**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 100`", "entry_point": "next_permutation", "canonical_solutions": {"python": "def nextPermutation(nums):\n    n, k = len(nums), -1\n    for i in range(n - 1, 0, -1):\n        if nums[i - 1] < nums[i]:\n            k = i - 1\n            break\n    if k == -1:\n        nums.reverse()\n    else:\n        l = 0\n        for i in range(n - 1, k, -1):\n            if nums[i] > nums[k]:\n                l = i\n                break\n        nums[k], nums[l] = nums[l], nums[k]\n        nums[k + 1:] = reversed(nums[k + 1:])", "java": "public void nextPermutation(int[] nums) {\n    int n = nums.length, k = n - 2, l;\n    while(k >= 0 && nums[k] >= nums[k + 1]) k--;\n\n    if(k < 0) {\n        Arrays.sort(nums);\n    } else {\n        for (l = n - 1; l > k; l--) {\n            if (nums[l] > nums[k]) break;\n        }\n        int temp = nums[k];\n        nums[k] = nums[l];\n        nums[l] = temp;\n        Arrays.sort(nums, k + 1, n);\n    }\n}", "cpp": "#include <algorithm>\nvoid nextPermutation(vector<int>& nums) {\n    int n = nums.size(), k, l;\n    for (k = n - 2; k >= 0; k--) {\n        if (nums[k] < nums[k + 1]) break;\n    }\n    if (k < 0) {\n        reverse(nums.begin(), nums.end());\n    } else {\n        for (l = n - 1; l > k; l--) {\n            if (nums[l] > nums[k]) break;\n        }\n        swap(nums[k], nums[l]);\n        reverse(nums.begin() + k + 1, nums.end());\n    }\n}", "javascript": "function nextPermutation(nums) {\n    let n = nums.length, k = n - 2, l;\n    while(k >= 0 && nums[k] >= nums[k + 1]) k--;\n\n    if(k < 0) {\n        nums.sort((a, b) => a - b);\n    } else {\n        for (l = n - 1; l > k; l--) {\n            if (nums[l] > nums[k]) break;\n        }\n        [nums[k], nums[l]] = [nums[l], nums[k]];\n        let tempArr = nums.slice(k + 1).sort((a, b) => a - b);\n        nums.splice(k + 1, n - k - 1, ...tempArr);\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/32", "prompt": "Given a string containing just the characters `'('` and `')'`, return _the length of the longest valid (well-formed) parentheses_ _substring_.\n\n**Example 1:**\n\n**Input:** s =  \"(() \"\n**Output:** 2\n**Explanation:** The longest valid parentheses substring is  \"() \".\n\n**Example 2:**\n\n**Input:** s =  \")()()) \"\n**Output:** 4\n**Explanation:** The longest valid parentheses substring is  \"()() \".\n\n**Example 3:**\n\n**Input:** s =  \" \"\n**Output:** 0\n\n**Constraints:**\n\n*   `0 <= s.length <= 3 * 104`\n*   `s[i]` is `'('`, or `')'`.", "entry_point": "longest_valid_parentheses", "canonical_solutions": {"python": "def longest_valid_parentheses(s: str) -> int:\n    n = len(s)\n    result = 0\n    st = []\n\n    for i in range(n):\n        if s[i] == '(':\n            st.append(i)\n        else:\n            if st and s[st[-1]] == '(':\n                st.pop()\n            else:\n                st.append(i)\n\n    if not st:\n        result = n\n    else:\n        right, left = n, 0\n        while st:\n            left = st.pop()\n            result = max(result, right - left - 1)\n            right = left\n        result = max(result, right)\n\n    return result", "java": "import java.util.Stack;\n\npublic int longestValidParentheses(String s) {\n    int n = s.length();\n    int result = 0;\n    Stack<Integer> st = new Stack<>();\n\n    for (int i = 0; i < n; ++i) {\n        if (s.charAt(i) == '(') {\n            st.push(i);\n        } else {\n            if (!st.empty() && s.charAt(st.peek()) == '(') {\n                st.pop();\n            } else {\n                st.push(i);\n            }\n        }\n    }\n\n    if (st.empty()) {\n        result = n;\n    } else {\n        int right = n, left = 0;\n        while (!st.empty()) {\n            left = st.pop();\n            result = Math.max(result, right - left - 1);\n            right = left;\n        }\n        result = Math.max(result, right);\n    }\n\n    return result;\n}", "cpp": "#include <stack>\n\nint longestValidParentheses(string s) {\n    int n = s.length();\n    int result = 0;\n    std::stack<int> st;\n\n    for (int i = 0; i < n; ++i) {\n        if (s[i] == '(') {\n            st.push(i);\n        } else {\n            if (!st.empty() && s[st.top()] == '(') {\n                st.pop();\n            } else {\n                st.push(i);\n            }\n        }\n    }\n\n    if (st.empty()) {\n        result = n;\n    } else {\n        int right = n, left = 0;\n        while (!st.empty()) {\n            left = st.top();\n            st.pop();\n            result = std::max(result, right - left - 1);\n            right = left;\n        }\n        result = std::max(result, right);\n    }\n\n    return result;\n}", "javascript": "function longestValidParentheses(s) {\n    const n = s.length;\n    let result = 0;\n    const st = [];\n\n    for (let i = 0; i < n; ++i) {\n        if (s[i] === '(') {\n            st.push(i);\n        } else {\n            if (st.length > 0 && s[st[st.length - 1]] === '(') {\n                st.pop();\n            } else {\n                st.push(i);\n            }\n        }\n    }\n\n    if (st.length === 0) {\n        result = n;\n    } else {\n        let right = n, left = 0;\n        while (st.length > 0) {\n            left = st.pop();\n            result = Math.max(result, right - left - 1);\n            right = left;\n        }\n        result = Math.max(result, right);\n    }\n\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/33", "prompt": "There is an integer array `nums` sorted in ascending order (with **distinct** values).\n\nPrior to being passed to your function, `nums` is **possibly rotated** at an unknown pivot index `k` (`1 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (**0-indexed**). For example, `[0,1,2,4,5,6,7]` might be rotated at pivot index `3` and become `[4,5,6,7,0,1,2]`.\n\nGiven the array `nums` **after** the possible rotation and an integer `target`, return _the index of_ `target` _if it is in_ `nums`_, or_ `-1` _if it is not in_ `nums`.\n\nYou must write an algorithm with `O(log n)` runtime complexity.\n\n**Example 1:**\n\n**Input:** nums = \\[4,5,6,7,0,1,2\\], target = 0\n**Output:** 4\n\n**Example 2:**\n\n**Input:** nums = \\[4,5,6,7,0,1,2\\], target = 3\n**Output:** -1\n\n**Example 3:**\n\n**Input:** nums = \\[1\\], target = 0\n**Output:** -1\n\n**Constraints:**\n\n*   `1 <= nums.length <= 5000`\n*   `-104 <= nums[i] <= 104`\n*   All values of `nums` are **unique**.\n*   `nums` is an ascending array that is possibly rotated.\n*   `-104 <= target <= 104`", "entry_point": "search_in_rotated_sorted_array", "canonical_solutions": {"python": "def search(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] >= nums[left]:\n            if target >= nums[left] and target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if target > nums[mid] and target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    return -1", "java": "public int search(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) {\n            return mid;\n        }\n        if (nums[mid] >= nums[left]) {\n            if (target >= nums[left] && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else {\n            if (target > nums[mid] && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    return -1;\n}", "cpp": "int search(vector<int>& nums, int target) {\n    int left = 0, right = nums.size() - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) {\n            return mid;\n        }\n        if (nums[mid] >= nums[left]) {\n            if (target >= nums[left] && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else {\n            if (target > nums[mid] && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    return -1;\n}", "javascript": "function search(nums, target) {\n    let left = 0, right = nums.length - 1;\n    while (left <= right) {\n        let mid = left + Math.floor((right - left) / 2);\n        if (nums[mid] === target) {\n            return mid;\n        }\n        if (nums[mid] >= nums[left]) {\n            if (target >= nums[left] && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else {\n            if (target > nums[mid] && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    return -1;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/34", "prompt": "Given an array of integers `nums` sorted in non-decreasing order, find the starting and ending position of a given `target` value.\n\nIf `target` is not found in the array, return `[-1, -1]`.\n\nYou must write an algorithm with `O(log n)` runtime complexity.\n\n**Example 1:**\n\n**Input:** nums = \\[5,7,7,8,8,10\\], target = 8\n**Output:** \\[3,4\\]\n\n**Example 2:**\n\n**Input:** nums = \\[5,7,7,8,8,10\\], target = 6\n**Output:** \\[-1,-1\\]\n\n**Example 3:**\n\n**Input:** nums = \\[\\], target = 0\n**Output:** \\[-1,-1\\]\n\n**Constraints:**\n\n*   `0 <= nums.length <= 105`\n*   `-109 <= nums[i] <= 109`\n*   `nums` is a non-decreasing array.\n*   `-109 <= target <= 109`", "entry_point": "find_first_and_last_position_of_element_in_sorted_array", "canonical_solutions": {"python": "def searchRange(nums, target):\n    start, end = -1, -1\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n            if nums[mid] == target:\n                start = mid\n\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] > target:right = mid - 1\n        else:\n            left = mid + 1\n            if nums[mid] == target:\n                end = mid\n    \n    return [start, end]", "java": "public int[] searchRange(int[] nums, int target) {\n    int start = -1, end = -1;\n    int left = 0, right = nums.length - 1;\n    \n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n            if (nums[mid] == target) {\n                start = mid;\n            }\n        }\n    }\n    \n    left = 0;\n    right = nums.length - 1;\n    \n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] > target) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n            if (nums[mid] == target) {\n                end = mid;\n            }\n        }\n    }\n    \n    return new int[] {start, end};\n}", "cpp": "#include <vector>\n\nstd::vector<int> searchRange(std::vector<int>& nums, int target) {\n    int start = -1, end = -1;\n    int left = 0, right = nums.size() - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n            if (nums[mid] == target) {\n                start = mid;\n            }\n        }\n    }\n    \n    left = 0, right = nums.size() - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] > target) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n            if (nums[mid] == target) {\n                end = mid;\n            }\n        }\n    }\n    \n    return {start, end};\n}", "javascript": "function searchRange(nums, target) {\n    let start = -1, end = -1;\n    let left = 0, right = nums.length - 1;\n\n    while (left <= right) {\n        const mid = left + Math.floor((right - left) / 2);\n        if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n            if (nums[mid] === target) {\n                start = mid;\n            }\n        }\n    }\n\n    left = 0;\n    right = nums.length - 1;\n\n    while (left <= right) {\n        const mid = left + Math.floor((right - left) / 2);\n        if (nums[mid] > target) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n            if (nums[mid] === target) {\n                end = mid;\n            }\n        }\n    }\n\n    return [start, end];\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/35", "prompt": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\nYou must write an algorithm with `O(log n)` runtime complexity.\n\n**Example 1:**\n\n**Input:** nums = \\[1,3,5,6\\], target = 5\n**Output:** 2\n\n**Example 2:**\n\n**Input:** nums = \\[1,3,5,6\\], target = 2\n**Output:** 1\n\n**Example 3:**\n\n**Input:** nums = \\[1,3,5,6\\], target = 7\n**Output:** 4\n\n**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-104 <= nums[i] <= 104`\n*   `nums` contains **distinct** values sorted in **ascending** order.\n*   `-104 <= target <= 104`", "entry_point": "search_insert_position", "canonical_solutions": {"python": "def searchInsert(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left", "java": "public int searchInsert(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) return mid;\n        if (nums[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return left;\n}", "cpp": "int searchInsert(vector<int>& nums, int target) {\n    int left = 0, right = nums.size() - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) return mid;\n        if (nums[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return left;\n}", "javascript": "function searchInsert(nums, target) {\n    let left = 0, right = nums.length - 1;\n    while (left <= right) {\n        let mid = left + Math.floor((right - left) / 2);\n        if (nums[mid] === target) return mid;\n        if (nums[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return left;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/36", "prompt": "Determine if a `9 x 9` Sudoku board is valid. Only the filled cells need to be validated **according to the following rules**:\n\n1.  Each row must contain the digits `1-9` without repetition.\n2.  Each column must contain the digits `1-9` without repetition.\n3.  Each of the nine `3 x 3` sub-boxes of the grid must contain the digits `1-9` without repetition.\n\n**Note:**\n\n*   A Sudoku board (partially filled) could be valid but is not necessarily solvable.\n*   Only the filled cells need to be validated according to the mentioned rules.\n\n**Example 1:**\n\n**Input:** board = \n\\[\\[ \"5 \", \"3 \", \". \", \". \", \"7 \", \". \", \". \", \". \", \". \"\\]\n,\\[ \"6 \", \". \", \". \", \"1 \", \"9 \", \"5 \", \". \", \". \", \". \"\\]\n,\\[ \". \", \"9 \", \"8 \", \". \", \". \", \". \", \". \", \"6 \", \". \"\\]\n,\\[ \"8 \", \". \", \". \", \". \", \"6 \", \". \", \". \", \". \", \"3 \"\\]\n,\\[ \"4 \", \". \", \". \", \"8 \", \". \", \"3 \", \". \", \". \", \"1 \"\\]\n,\\[ \"7 \", \". \", \". \", \". \", \"2 \", \". \", \". \", \". \", \"6 \"\\]\n,\\[ \". \", \"6 \", \". \", \". \", \". \", \". \", \"2 \", \"8 \", \". \"\\]\n,\\[ \". \", \". \", \". \", \"4 \", \"1 \", \"9 \", \". \", \". \", \"5 \"\\]\n,\\[ \". \", \". \", \". \", \". \", \"8 \", \". \", \". \", \"7 \", \"9 \"\\]\\]\n**Output:** true\n\n**Example 2:**\n\n**Input:** board = \n\\[\\[ \"8 \", \"3 \", \". \", \". \", \"7 \", \". \", \". \", \". \", \". \"\\]\n,\\[ \"6 \", \". \", \". \", \"1 \", \"9 \", \"5 \", \". \", \". \", \". \"\\]\n,\\[ \". \", \"9 \", \"8 \", \". \", \". \", \". \", \". \", \"6 \", \". \"\\]\n,\\[ \"8 \", \". \", \". \", \". \", \"6 \", \". \", \". \", \". \", \"3 \"\\]\n,\\[ \"4 \", \". \", \". \", \"8 \", \". \", \"3 \", \". \", \". \", \"1 \"\\]\n,\\[ \"7 \", \". \", \". \", \". \", \"2 \", \". \", \". \", \". \", \"6 \"\\]\n,\\[ \". \", \"6 \", \". \", \". \", \". \", \". \", \"2 \", \"8 \", \". \"\\]\n,\\[ \". \", \". \", \". \", \"4 \", \"1 \", \"9 \", \". \", \". \", \"5 \"\\]\n,\\[ \". \", \". \", \". \", \". \", \"8 \", \". \", \". \", \"7 \", \"9 \"\\]\\]\n**Output:** false\n**Explanation:** Same as Example 1, except with the **5** in the top left corner being modified to **8**. Since there are two 8's in the top left 3x3 sub-box, it is invalid.\n\n**Constraints:**\n\n*   `board.length == 9`\n*   `board[i].length == 9`\n*   `board[i][j]` is a digit `1-9` or `'.'`.", "entry_point": "valid_sudoku", "canonical_solutions": {"python": "def isValidSudoku(board):\n    seen = set()\n\n    for i in range(9):\n        for j in range(9):\n            current_val = board[i][j]\n            \n            if current_val != '.':\n                row = f\"{current_val} in row {i}\"\n                col = f\"{current_val} in col {j}\"\n                box = f\"{current_val} in box {i // 3}-{j // 3}\"\n                \n                if row in seen or col in seen or box in seen:\n                    return False\n\n                seen.add(row)\n                seen.add(col)\n                seen.add(box)\n\n    return True", "java": "public boolean isValidSudoku(char[][] board) {\n    HashSet<String> seen = new HashSet<>();\n    \n    for(int i = 0; i < 9; i++) {\n        for(int j = 0; j < 9; j++) {\n            char current_val = board[i][j];\n            if(current_val != '.') {\n                String row = current_val + \" in row \" + i;\n                String col = current_val + \" in col \" + j;\n                String box = current_val + \" in box \" + i / 3 + \"-\" + j / 3;\n                if(seen.contains(row) || seen.contains(col) || seen.contains(box)) {\n                    return false;\n                }\n                seen.add(row);\n                seen.add(col);\n                seen.add(box);\n            }\n        }\n    }\n    return true;\n}", "cpp": "bool isValidSudoku(vector<vector<char>>& board) {\n    unordered_set<string> seen;\n    \n    for(int i = 0; i < 9; i++) {\n        for(int j = 0; j < 9; j++) {\n            char current_val = board[i][j];\n            if(current_val != '.') {\n                string row = to_string(current_val) + \" in row \" + to_string(i);\n                string col = to_string(current_val) + \" in col \" + to_string(j);\n                string box = to_string(current_val) + \" in box \" + to_string(i/3) + \"-\" + to_string(j/3);\n                if(seen.count(row) || seen.count(col) || seen.count(box)) {\n                    return false;\n                }\n                seen.insert(row);\n                seen.insert(col);\n                seen.insert(box);\n            }\n        }\n    }\n    return true;\n}", "javascript": "function isValidSudoku(board) {\n    let seen = new Set();\n    \n    for(let i = 0; i < 9; i++) {\n        for(let j = 0; j < 9; j++) {\n            let current_val = board[i][j];\n            if(current_val !== '.') {\n                let row = `${current_val} in row ${i}`;\n                let col = `${current_val} in col ${j}`;\n                let box = `${current_val} in box ${Math.floor(i/3)}-${Math.floor(j/3)}`;\n                \n                if(seen.has(row) || seen.has(col) || seen.has(box)) {\n                    return false;\n                }\n                seen.add(row);\n                seen.add(col);\n                seen.add(box);\n            }\n        }\n    }\n    return true;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/37", "prompt": "Write a program to solve a Sudoku puzzle by filling the empty cells.\n\nA sudoku solution must satisfy **all of the following rules**:\n\n1.  Each of the digits `1-9` must occur exactly once in each row.\n2.  Each of the digits `1-9` must occur exactly once in each column.\n3.  Each of the digits `1-9` must occur exactly once in each of the 9 `3x3` sub-boxes of the grid.\n\nThe `'.'` character indicates empty cells.\n\n**Example 1:**\n\n**Input:** board = \\[\\[ \"5 \", \"3 \", \". \", \". \", \"7 \", \". \", \". \", \". \", \". \"\\],\\[ \"6 \", \". \", \". \", \"1 \", \"9 \", \"5 \", \". \", \". \", \". \"\\],\\[ \". \", \"9 \", \"8 \", \". \", \". \", \". \", \". \", \"6 \", \". \"\\],\\[ \"8 \", \". \", \". \", \". \", \"6 \", \". \", \". \", \". \", \"3 \"\\],\\[ \"4 \", \". \", \". \", \"8 \", \". \", \"3 \", \". \", \". \", \"1 \"\\],\\[ \"7 \", \". \", \". \", \". \", \"2 \", \". \", \". \", \". \", \"6 \"\\],\\[ \". \", \"6 \", \". \", \". \", \". \", \". \", \"2 \", \"8 \", \". \"\\],\\[ \". \", \". \", \". \", \"4 \", \"1 \", \"9 \", \". \", \". \", \"5 \"\\],\\[ \". \", \". \", \". \", \". \", \"8 \", \". \", \". \", \"7 \", \"9 \"\\]\\]\n**Output:** \\[\\[ \"5 \", \"3 \", \"4 \", \"6 \", \"7 \", \"8 \", \"9 \", \"1 \", \"2 \"\\],\\[ \"6 \", \"7 \", \"2 \", \"1 \", \"9 \", \"5 \", \"3 \", \"4 \", \"8 \"\\],\\[ \"1 \", \"9 \", \"8 \", \"3 \", \"4 \", \"2 \", \"5 \", \"6 \", \"7 \"\\],\\[ \"8 \", \"5 \", \"9 \", \"7 \", \"6 \", \"1 \", \"4 \", \"2 \", \"3 \"\\],\\[ \"4 \", \"2 \", \"6 \", \"8 \", \"5 \", \"3 \", \"7 \", \"9 \", \"1 \"\\],\\[ \"7 \", \"1 \", \"3 \", \"9 \", \"2 \", \"4 \", \"8 \", \"5 \", \"6 \"\\],\\[ \"9 \", \"6 \", \"1 \", \"5 \", \"3 \", \"7 \", \"2 \", \"8 \", \"4 \"\\],\\[ \"2 \", \"8 \", \"7 \", \"4 \", \"1 \", \"9 \", \"6 \", \"3 \", \"5 \"\\],\\[ \"3 \", \"4 \", \"5 \", \"2 \", \"8 \", \"6 \", \"1 \", \"7 \", \"9 \"\\]\\]\n**Explanation:** The input board is shown above and the only valid solution is shown below:\n\n \n\n**Constraints:**\n\n*   `board.length == 9`\n*   `board[i].length == 9`\n*   `board[i][j]` is a digit or `'.'`.\n*   It is **guaranteed** that the input board has only one solution.", "entry_point": "sudoku_solver", "canonical_solutions": {"python": "def isValid(board, row, col, c):\n    for i in range(9):\n        if board[i][col] == c:\n            return False\n        if board[row][i] == c:\n            return False\n        if board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == c:\n            return False\n    return True\n\ndef solveSudokuHelper(board):\n    for i in range(9):\n        for j in range(9):\n            if board[i][j] == '.':\n                for c in '123456789':\n                    if isValid(board, i, j, c):\n                        board[i][j] = c\n\n                        if solveSudokuHelper(board):\n                            return True\n\n                        board[i][j] = '.'\n                return False\n\n    return True\n\ndef solveSudoku(board):\n    solveSudokuHelper(board)", "java": "import java.util.*;\n\nclass Solution {\n    public boolean isValid(char[][] board, int row, int col, char c) {\n        for (int i = 0; i < 9; i++) {\n            if (board[i][col] == c) return false;\n            if (board[row][i] == c) return false;\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) return false;\n        }\n        return true;\n    }\n\n    public boolean solveSudokuHelper(char[][] board) {\n        for (int i = 0; i < 9; i++) {\n            for (int j = 0; j < 9; j++) {\n                if (board[i][j] == '.') {\n                    for (char c = '1'; c <= '9'; c++) {\n                        if (isValid(board, i, j, c)) {\n                            board[i][j] = c;\n\n                            if (solveSudokuHelper(board)) {\n                                return true;\n                            }\n\n                            board[i][j] = '.';\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public void solveSudoku(char[][] board) {\n        solveSudokuHelper(board);\n    }\n}", "cpp": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nbool isValid(vector<vector<char>>& board, int row, int col, char c) {\n    for (int i = 0; i < 9; i++) {\n        if (board[i][col] == c) return false; \n        if (board[row][i] == c) return false; \n        if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) return false; \n    }\n    return true;\n}\n\nbool solveSudokuHelper(vector<vector<char>>& board) {\n    for (int i = 0; i < 9; i++) {\n        for (int j = 0; j < 9; j++) {\n            if (board[i][j] == '.') {\n                for (char c = '1'; c <= '9'; c++) {\n                    if (isValid(board, i, j, c)) {\n                        board[i][j] = c;\n\n                        if (solveSudokuHelper(board))\n                            return true;\n\n                        board[i][j] = '.';\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nvoid solveSudoku(vector<vector<char>>& board) {\n    solveSudokuHelper(board);\n}", "javascript": "function isValid(board, row, col, c) {\n    for (let i = 0; i < 9; i++) {\n        if (board[i][col] === c) return false;\n        if (board[row][i] === c) return false;\n        if (board[3 * Math.floor(row / 3) + Math.floor(i / 3)][3 * Math.floor(col / 3) + i % 3] === c) return false;\n    }\n    return true;\n}\n\nfunction solveSudokuHelper(board) {\n    for (let i = 0; i < 9; i++) {\n        for (let j = 0; j < 9; j++) {\n            if (board[i][j] === '.') {\n                for (let c = 1; c <= 9; c++) {\n                    if (isValid(board, i, j, c.toString())) {\n                        board[i][j] = c.toString();\n\n                        if (solveSudokuHelper(board)) {\n                            return true;\n                        }\n\n                        board[i][j] = '.';\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nfunction solveSudoku(board) {\n    solveSudokuHelper(board);\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/38", "prompt": "The **count-and-say** sequence is a sequence of digit strings defined by the recursive formula:\n\n*   `countAndSay(1) = \"1 \"`\n*   `countAndSay(n)` is the way you would \"say \" the digit string from `countAndSay(n-1)`, which is then converted into a different digit string.\n\nTo determine how you \"say \" a digit string, split it into the **minimal** number of substrings such that each substring contains exactly **one** unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.\n\nFor example, the saying and conversion for digit string `\"3322251 \"`:\n\nGiven a positive integer `n`, return _the_ `nth` _term of the **count-and-say** sequence_.\n\n**Example 1:**\n\n**Input:** n = 1\n**Output:**  \"1 \"\n**Explanation:** This is the base case.\n\n**Example 2:**\n\n**Input:** n = 4\n**Output:**  \"1211 \"\n**Explanation:**\ncountAndSay(1) =  \"1 \"\ncountAndSay(2) = say  \"1 \" = one 1 =  \"11 \"\ncountAndSay(3) = say  \"11 \" = two 1's =  \"21 \"\ncountAndSay(4) = say  \"21 \" = one 2 + one 1 =  \"12 \" +  \"11 \" =  \"1211 \"\n\n**Constraints:**\n\n*   `1 <= n <= 30`", "entry_point": "count_and_say", "canonical_solutions": {"python": "def count_and_say(n):\n    if n == 1:\n        return \"1\"\n    previous = count_and_say(n - 1)\n    result = []\n    count = 1\n    for i in range(1, len(previous)):\n        if previous[i] == previous[i - 1]:\n            count += 1\n        else:\n            result.append(str(count))\n            result.append(previous[i - 1])\n            count = 1\n    result.append(str(count))\n    result.append(previous[-1])\n    return \"\".join(result)", "java": "public String countAndSay(int n) {\n    if (n == 1) return \"1\";\n    String previous = countAndSay(n-1);\n    StringBuilder result = new StringBuilder();\n    int count = 1;\n    for (int i = 1; i < previous.length(); i++) {\n        if (previous.charAt(i) == previous.charAt(i-1)) {\n            count++;\n        } else {\n            result.append(count).append(previous.charAt(i-1));\n            count = 1;\n        }\n    }\n    result.append(count).append(previous.charAt(previous.length()-1));\n    return result.toString();\n}", "cpp": "#include <string>\n\nstd::string countAndSay(int n) {\n    if (n == 1) return \"1\";\n    std::string previous = countAndSay(n-1);\n    std::string result = \"\";\n    int count = 1;\n    for (int i = 1; i < previous.length(); i++) {\n        if (previous[i] == previous[i-1]) {\n            count++;\n        } else {\n            result += std::to_string(count) + previous[i-1];\n            count = 1;\n        }\n    }\n    result += std::to_string(count) + previous.back();\n    return result;\n}", "javascript": "function countAndSay(n) {\n    if (n === 1) return \"1\";\n    let previous = countAndSay(n - 1);\n    let result = \"\";\n    let count = 1;\n    for (let i = 1; i < previous.length; i++) {\n        if (previous[i] === previous[i - 1]) {\n            count++;\n        } else {\n            result += count.toString() + previous[i - 1];\n            count = 1;\n        }\n    }\n    result += count.toString() + previous[previous.length - 1];\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/39", "prompt": "Given an array of **distinct** integers `candidates` and a target integer `target`, return _a list of all **unique combinations** of_ `candidates` _where the chosen numbers sum to_ `target`_._ You may return the combinations in **any order**.\n\nThe **same** number may be chosen from `candidates` an **unlimited number of times**. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\n\nThe test cases are generated such that the number of unique combinations that sum up to `target` is less than `150` combinations for the given input.\n\n**Example 1:**\n\n**Input:** candidates = \\[2,3,6,7\\], target = 7\n**Output:** \\[\\[2,2,3\\],\\[7\\]\\]\n**Explanation:**\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n7 is a candidate, and 7 = 7.\nThese are the only two combinations.\n\n**Example 2:**\n\n**Input:** candidates = \\[2,3,5\\], target = 8\n**Output:** \\[\\[2,2,2,2\\],\\[2,3,3\\],\\[3,5\\]\\]\n\n**Example 3:**\n\n**Input:** candidates = \\[2\\], target = 1\n**Output:** \\[\\]\n\n**Constraints:**\n\n*   `1 <= candidates.length <= 30`\n*   `2 <= candidates[i] <= 40`\n*   All elements of `candidates` are **distinct**.\n*   `1 <= target <= 40`", "entry_point": "combination_sum", "canonical_solutions": {"python": "def combinationSum(candidates, target):\n    def findCombinations(startIndex, remaining):\n        if remaining == 0:\n            return [[]]\n        if startIndex == len(candidates) or remaining < 0:\n            return []\n\n        result = []\n        result.extend(findCombinations(startIndex + 1, remaining))\n        result.extend([x + [candidates[startIndex]] for x in findCombinations(startIndex, remaining - candidates[startIndex])])\n        \n        return result\n\n    return findCombinations(0, target)", "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> combinationSum(int[] candidates, int target) {\n    List<List<Integer>> result = new ArrayList<>();\n    findCombinations(candidates, target, 0, new ArrayList<>(), result);\n    return result;\n}\n\nprivate void findCombinations(int[] candidates, int target, int startIndex, List<Integer> current, List<List<Integer>> result) {\n    if (target == 0) {\n        result.add(new ArrayList<>(current));\n        return;\n    }\n    if (startIndex == candidates.length || target < 0) {\n        return;\n    }\n\n    findCombinations(candidates, target, startIndex + 1, current, result);\n\n    current.add(candidates[startIndex]);\n    findCombinations(candidates, target - candidates[startIndex], startIndex, current, result);\n    current.remove(current.size() - 1);\n}", "cpp": "#include <vector>\n\nvoid findCombinations(std::vector<int>& candidates, int target, int startIndex, std::vector<int>& current, std::vector<std::vector<int>>& result) {\n    if (target == 0) {\n        result.push_back(current);\n        return;\n    }\n    if (startIndex == candidates.size() || target < 0) {\n        return;\n    }\n\n    findCombinations(candidates, target, startIndex + 1, current, result);\n\n    current.push_back(candidates[startIndex]);\n    findCombinations(candidates, target - candidates[startIndex], startIndex, current, result);\n    current.pop_back();\n}\n\nstd::vector<std::vector<int>> combinationSum(std::vector<int>& candidates, int target) {\n    std::vector<int> current;\n    std::vector<std::vector<int>> result;\n    findCombinations(candidates, target, 0, current, result);\n    return result;\n}", "javascript": "function combinationSum(candidates, target) {\n    function findCombinations(startIndex, remaining) {\n        if (remaining === 0) {\n            return [[]];\n        }\n        if (startIndex === candidates.length || remaining < 0) {\n            return [];\n        }\n\n        let result = [];\n        result = result.concat(findCombinations(startIndex + 1, remaining));\n        result = result.concat(findCombinations(startIndex, remaining - candidates[startIndex]).map(x => x.concat([candidates[startIndex]])));\n\n        return result;\n    }\n\n    return findCombinations(0, target);\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/40", "prompt": "Given a collection of candidate numbers (`candidates`) and a target number (`target`), find all unique combinations in `candidates` where the candidate numbers sum to `target`.\n\nEach number in `candidates` may only be used **once** in the combination.\n\n**Note:** The solution set must not contain duplicate combinations.\n\n**Example 1:**\n\n**Input:** candidates = \\[10,1,2,7,6,1,5\\], target = 8\n**Output:** \n\\[\n\\[1,1,6\\],\n\\[1,2,5\\],\n\\[1,7\\],\n\\[2,6\\]\n\\]\n\n**Example 2:**\n\n**Input:** candidates = \\[2,5,2,1,2\\], target = 5\n**Output:** \n\\[\n\\[1,2,2\\],\n\\[5\\]\n\\]\n\n**Constraints:**\n\n*   `1 <= candidates.length <= 100`\n*   `1 <= candidates[i] <= 50`\n*   `1 <= target <= 30`", "entry_point": "combination_sum_ii", "canonical_solutions": {"python": "def combinationSum2(candidates, target):\n    def combine(candidates, target, start, path, res):\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(start, len(candidates)):\n            if i > start and candidates[i] == candidates[i - 1]:\n                continue\n            if candidates[i] > target:\n                break\n            combine(candidates, target - candidates[i], i+1, path + [candidates[i]], res)\n\n    candidates.sort()\n    res = []\n    combine(candidates, target, 0, [], res)\n    return res", "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic List<List<Integer>> combinationSum2(int[] candidates, int target) {\n    List<List<Integer>> result = new ArrayList<>();\n    Arrays.sort(candidates);\n    combine(candidates, target, 0, result, new ArrayList<Integer>());\n    return result;\n}\n\nprivate void combine(int[] candidates, int target, int start, List<List<Integer>> result, List<Integer> current) {\n    if (target == 0) {\n        result.add(new ArrayList<>(current));\n        return;\n    }\n\n    for (int i = start; i < candidates.length && target >= candidates[i]; i++) {\n        if (i == start || candidates[i] != candidates[i - 1]) {\n            current.add(candidates[i]);\n            combine(candidates, target - candidates[i], i + 1, result, current);\n            current.remove(current.size() - 1);\n        }\n    }\n}", "cpp": "#include <vector>\n#include <algorithm>\n\nvoid combine(std::vector<int>& candidates, int target, std::vector<std::vector<int>>& result, std::vector<int>& combination, int index) {\n    if (target == 0) {\n        result.push_back(combination);\n        return;\n    }\n\n    for (int i = index; i < candidates.size() && target >= candidates[i]; ++i) {\n        if (i == index || candidates[i] != candidates[i - 1]) {\n            combination.push_back(candidates[i]);\n            combine(candidates, target - candidates[i], result, combination, i + 1);\n            combination.pop_back();\n        }\n    }\n}\n\nstd::vector<std::vector<int>> combinationSum2(std::vector<int>& candidates, int target) {\n    std::vector<std::vector<int>> result;\n    std::vector<int> combination;\n    std::sort(candidates.begin(), candidates.end());\n    combine(candidates, target, result, combination, 0);\n    return result;\n}", "javascript": "function combinationSum2(candidates, target) {\n    const result = [];\n    candidates.sort((a, b) => a - b);\n    combine(candidates, target, 0, [], result);\n    return result;\n}\n\nfunction combine(candidates, target, start, current, result) {\n    if (target === 0) {\n        result.push([...current]);\n        return;\n    }\n\n    for (let i = start; i < candidates.length && target >= candidates[i]; i++) {\n        if (i === start || candidates[i] !== candidates[i - 1]) {\n            current.push(candidates[i]);\n            combine(candidates, target - candidates[i], i + 1, current, result);\n            current.pop();\n        }\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/41", "prompt": "Given an unsorted integer array `nums`, return the smallest missing positive integer.\n\nYou must implement an algorithm that runs in `O(n)` time and uses constant extra space.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,0\\]\n**Output:** 3\n**Explanation:** The numbers in the range \\[1,2\\] are all in the array.\n\n**Example 2:**\n\n**Input:** nums = \\[3,4,-1,1\\]\n**Output:** 2\n**Explanation:** 1 is in the array but 2 is missing.\n\n**Example 3:**\n\n**Input:** nums = \\[7,8,9,11,12\\]\n**Output:** 1\n**Explanation:** The smallest positive integer 1 is missing.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-231 <= nums[i] <= 231 - 1`", "entry_point": "first_missing_positive", "canonical_solutions": {"python": "def firstMissingPositive(nums):\n    n = len(nums)\n    for i in range(n):\n        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n\n    for i in range(n):\n        if nums[i] != i + 1:\n            return i + 1\n    return n + 1", "java": "public int firstMissingPositive(int[] nums) {\n    int n = nums.length;\n    for(int i = 0; i < n; i++) {\n        while(nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {\n            int temp = nums[i];\n            nums[i] = nums[temp - 1];\n            nums[temp - 1] = temp;\n        }\n    }\n\n    for(int i = 0; i < n; i++) {\n        if(nums[i] != i + 1) {\n            return i + 1;\n        }\n    }\n    return n + 1;\n}", "cpp": "int firstMissingPositive(vector<int>& nums) {\n    int n = nums.size();\n    for(int i = 0; i < n; ++i)\n        while(nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i])\n            swap(nums[i], nums[nums[i] - 1]);\n\n    for(int i = 0; i < n; ++i)\n        if(nums[i] != i + 1)\n            return i + 1;\n    return n + 1;\n}", "javascript": "function firstMissingPositive(nums) {\n    let n = nums.length;\n    for(let i = 0; i < n; i++) {\n        while(nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] !== nums[i]) {\n            let temp = nums[i];\n            nums[i] = nums[temp - 1];\n            nums[temp - 1] = temp;\n        }\n    }\n\n    for(let i = 0; i < n; i++) {\n        if(nums[i] !== i + 1) {\n            return i + 1;\n        }\n    }\n    return n + 1;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/42", "prompt": "Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.\n\n**Example 1:**\n\n**Input:** height = \\[0,1,0,2,1,0,1,3,2,1,2,1\\]\n**Output:** 6\n**Explanation:** The above elevation map (black section) is represented by array \\[0,1,0,2,1,0,1,3,2,1,2,1\\]. In this case, 6 units of rain water (blue section) are being trapped.\n\n**Example 2:**\n\n**Input:** height = \\[4,2,0,3,2,5\\]\n**Output:** 9\n\n**Constraints:**\n\n*   `n == height.length`\n*   `1 <= n <= 2 * 104`\n*   `0 <= height[i] <= 105`", "entry_point": "trapping_rain_water", "canonical_solutions": {"python": "def trap(height):\n    n = len(height)\n    left, right, max_left, max_right, water = 0, n - 1, 0, 0, 0\n\n    while left < right:\n        if height[left] <= height[right]:\n            max_left = max(max_left, height[left])\n            water += max_left - height[left]\n            left += 1\n        else:\n            max_right = max(max_right, height[right])\n            water += max_right - height[right]\n            right -= 1\n\n    return water", "java": "public int trap(int[] height) {\n    int n = height.length, left = 0, right = n - 1, maxLeft = 0, maxRight = 0, water = 0;\n\n    while (left < right) {\n        if (height[left] <= height[right]) {\n            maxLeft = Math.max(maxLeft, height[left]);\n            water += maxLeft - height[left];\n            left++;\n        } else {\n            maxRight = Math.max(maxRight, height[right]);\n            water += maxRight - height[right];\n            right--;\n        }\n    }\n\n    return water;\n}", "cpp": "#include <vector>\nusing namespace std;\n\nint trap(vector<int>& height) {\n    int n = height.size();\n    int left = 0, right = n - 1, maxLeft = 0, maxRight = 0, water = 0;\n\n    while (left < right) {\n        if (height[left] <= height[right]) {\n            maxLeft = max(maxLeft, height[left]);\n            water += maxLeft - height[left];\n            left++;\n        } else {\n            maxRight = max(maxRight, height[right]);\n            water += maxRight - height[right];\n            right--;\n        }\n    }\n\n    return water;\n}", "javascript": "function trap(height) {\n    const n = height.length;\n    let left = 0, right = n - 1, maxLeft = 0, maxRight = 0, water = 0;\n\n    while (left < right) {\n        if (height[left] <= height[right]) {\n            maxLeft = Math.max(maxLeft, height[left]);\n            water += maxLeft - height[left];\n            left++;\n        } else {\n            maxRight = Math.max(maxRight, height[right]);\n            water += maxRight - height[right];\n            right--;\n        }\n    }\n\n    return water;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/43", "prompt": "Given two non-negative integers `num1` and `num2` represented as strings, return the product of `num1` and `num2`, also represented as a string.\n\n**Note:** You must not use any built-in BigInteger library or convert the inputs to integer directly.\n\n**Example 1:**\n\n**Input:** num1 = \"2\", num2 = \"3\"\n**Output:** \"6\"\n\n**Example 2:**\n\n**Input:** num1 = \"123\", num2 = \"456\"\n**Output:** \"56088\"\n\n**Constraints:**\n\n*   `1 <= num1.length, num2.length <= 200`\n*   `num1` and `num2` consist of digits only.\n*   Both `num1` and `num2` do not contain any leading zero, except the number `0` itself.", "entry_point": "multiply_strings", "canonical_solutions": {"python": "def multiply(num1, num2):\n    m, n = len(num1), len(num2)\n    pos = [0] * (m + n)\n    \n    for i in range(m-1, -1, -1):\n        for j in range(n-1, -1, -1):\n            mult = (ord(num1[i]) - ord('0')) * (ord(num2[j]) - ord('0'))\n            p1, p2 = i + j, i + j + 1\n            total_pos = mult + pos[p2]\n            pos[p1] += total_pos // 10\n            pos[p2] = total_pos % 10\n            \n    res = ''.join(str(p) for p in pos if not (len(res) == 0 and p == 0))            \n    return '0' if len(res) == 0 else res", "java": "public String multiply(String num1, String num2) {\n    int m = num1.length(), n = num2.length();\n    int[] pos = new int[m + n];\n    \n    for (int i = m - 1; i >= 0; i--) {\n        for (int j = n - 1; j >= 0; j--) {\n            int mult = (num1.charAt(i) - '0') * (num2.charAt(j) - '0');\n            int p1 = i + j, p2 = i + j + 1;\n            int sum = mult + pos[p2];\n            pos[p1] += sum / 10;\n            pos[p2] = sum % 10;\n        }\n    }\n    \n    StringBuilder res = new StringBuilder();\n    for (int p : pos) if (!(res.length() == 0 && p == 0)) res.append(p);\n    return res.length() == 0 ? \"0\" : res.toString();\n}", "cpp": "string multiply(string num1, string num2) {\n    int m = num1.size(), n = num2.size();\n    string res(m + n, '0');\n    for (int i = m - 1; i >= 0; i--) {\n        for (int j = n - 1; j >= 0; j--) {\n            int p1 = i + j, p2 = i + j + 1;\n            int mult = (num1[i] - '0') * (num2[j] - '0') + (res[p2] - '0');\n            res[p1] += mult / 10;\n            res[p2] = (mult % 10) + '0';\n        }\n    }\n    while (res.size() > 1 && res[0] == '0')\n        res.erase(res.begin());\n    return res;\n}", "javascript": "function multiply(num1, num2) {\n    let m = num1.length, n = num2.length;\n    let pos = new Array(m + n).fill(0);\n    \n    for (let i = m - 1; i >= 0; i--) {\n        for (let j = n - 1; j >= 0; j--) {\n            let mult = (num1[i] - '0') * (num2[j] - '0');\n            let p1 = i + j, p2 = i + j + 1;\n            let sum = mult + pos[p2];\n            pos[p1] += Math.floor(sum / 10);\n            pos[p2] = sum % 10;\n        }\n    }\n    \n    while (pos.length > 1 && pos[0] == 0)\n        pos.shift();\n    return pos.join('');\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/44", "prompt": "Given an input string (`s`) and a pattern (`p`), implement wildcard pattern matching with support for `'?'` and `'*'` where:\n\n*   `'?'` Matches any single character.\n*   `'*'` Matches any sequence of characters (including the empty sequence).\n\nThe matching should cover the **entire** input string (not partial).\n\n**Example 1:**\n\n**Input:** s =  \"aa \", p =  \"a \"\n**Output:** false\n**Explanation:**  \"a \" does not match the entire string  \"aa \".\n\n**Example 2:**\n\n**Input:** s =  \"aa \", p =  \"\\* \"\n**Output:** true\n**Explanation:** '\\*' matches any sequence.\n\n**Example 3:**\n\n**Input:** s =  \"cb \", p =  \"?a \"\n**Output:** false\n**Explanation:** '?' matches 'c', but the second letter is 'a', which does not match 'b'.\n\n**Constraints:**\n\n*   `0 <= s.length, p.length <= 2000`\n*   `s` contains only lowercase English letters.\n*   `p` contains only lowercase English letters, `'?'` or `'*'`.", "entry_point": "wildcard_matching", "canonical_solutions": {"python": "def is_match(s: str, p: str) -> bool:\n    m, n = len(s), len(p)\n    i = j = 0\n    match = asterisk = -1\n    while i < m:\n        if j < n and (s[i] == p[j] or p[j] == '?'):\n            i, j = i + 1, j + 1\n        elif j < n and p[j] == '*':\n            match, asterisk = i, j\n            j += 1\n        elif asterisk >= 0:\n            i, j = match + 1, asterisk + 1\n            match += 1\n        else:\n            return False\n    while j < n and p[j] == '*':\n        j += 1\n    return j == n", "java": "public boolean isMatch(String s, String p) {\n    int m = s.length(), n = p.length();\n    int i = 0, j = 0, asterisk = -1, match = 0;\n    while (i < m) {\n        if (j < n && (s.charAt(i) == p.charAt(j) || p.charAt(j) == '?')) {\n            i++; j++;\n        } else if (j < n && p.charAt(j) == '*') {\n            match = i;\n            asterisk = j++;\n        } else if (asterisk != -1) {\n            i = ++match;\n            j = asterisk + 1;\n        } else {\n            return false;\n        }\n    }\n    while (j < n && p.charAt(j) == '*') j++;\n    return j == n;\n}", "cpp": "bool isMatch(const std::string& s, const std::string& p) {\n    int m = s.size(), n = p.size();\n    int i = 0, j = 0, asterisk = -1, match;\n    while (i < m) {\n        if (j < n && (s[i] == p[j] || p[j] == '?')) {\n            i++; j++;\n        } else if (j < n && p[j] == '*') {\n            match = i;\n            asterisk = j++;\n        } else if (asterisk >= 0) {\n            i = ++match;\n            j = asterisk + 1;\n        } else {\n            return false;\n        }\n    }\n    while (j < n && p[j] == '*') j++;\n    return j == n;\n}", "javascript": "function isMatch(s, p) {\n    let m = s.length,\n        n = p.length;\n    let i = 0,\n        j = 0,\n        asterisk = -1,\n        match = 0;\n    while (i < m) {\n        if (j < n && (s[i] === p[j] || p[j] === '?')) {\n            i++;\n            j++;\n        } else if (j < n && p[j] === '*') {\n            match = i;\n            asterisk = j++;\n        } else if (asterisk >= 0) {\n            i = ++match;\n            j = asterisk + 1;\n        } else {\n            return false;\n        }\n    }\n    while (j < n && p[j] === '*') j++;\n    return j === n;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/45", "prompt": "You are given a **0-indexed** array of integers `nums` of length `n`. You are initially positioned at `nums[0]`.\n\nEach element `nums[i]` represents the maximum length of a forward jump from index `i`. In other words, if you are at `nums[i]`, you can jump to any `nums[i + j]` where:\n\n*   `0 <= j <= nums[i]` and\n*   `i + j < n`\n\nReturn _the minimum number of jumps to reach_ `nums[n - 1]`. The test cases are generated such that you can reach `nums[n - 1]`.\n\n**Example 1:**\n\n**Input:** nums = \\[2,3,1,1,4\\]\n**Output:** 2\n**Explanation:** The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\n**Example 2:**\n\n**Input:** nums = \\[2,3,0,1,4\\]\n**Output:** 2\n\n**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `0 <= nums[i] <= 1000`\n*   It's guaranteed that you can reach `nums[n - 1]`.", "entry_point": "jump_game_ii", "canonical_solutions": {"python": "def jump(nums):\n    jumps = 0\n    current_end = 0\n    current_farthest = 0\n\n    for i in range(len(nums) - 1):\n        current_farthest = max(current_farthest, i + nums[i])\n        if i == current_end:\n            jumps += 1\n            current_end = current_farthest\n\n    return jumps", "java": "public int jump(int[] nums) {\n    int jumps = 0, currentEnd = 0, currentFarthest = 0;\n    \n    for (int i = 0; i < nums.length - 1; i++) {\n        currentFarthest = Math.max(currentFarthest, i + nums[i]);\n        if (i == currentEnd) {\n            jumps++;\n            currentEnd = currentFarthest;\n        }\n    }\n    return jumps;\n}", "cpp": "int jump(vector<int>& nums) {\n    int jumps = 0, current_end = 0, current_farthest = 0;\n    \n    for (int i = 0; i < nums.size() - 1; i++) {\n        current_farthest = max(current_farthest, i + nums[i]);\n        if (i == current_end) {\n            jumps++;\n            current_end = current_farthest;\n        }\n    }\n    return jumps;\n}", "javascript": "function jump(nums) {\n    let jumps = 0, currentEnd = 0, currentFarthest = 0;\n\n    for (let i = 0; i < nums.length - 1; i++) {\n        currentFarthest = Math.max(currentFarthest, i + nums[i]);\n        if (i === currentEnd) {\n            jumps++;\n            currentEnd = currentFarthest;\n        }\n    }\n    return jumps;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/46", "prompt": "Given an array `nums` of distinct integers, return _all the possible permutations_. You can return the answer in **any order**.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3\\]\n**Output:** \\[\\[1,2,3\\],\\[1,3,2\\],\\[2,1,3\\],\\[2,3,1\\],\\[3,1,2\\],\\[3,2,1\\]\\]\n\n**Example 2:**\n\n**Input:** nums = \\[0,1\\]\n**Output:** \\[\\[0,1\\],\\[1,0\\]\\]\n\n**Example 3:**\n\n**Input:** nums = \\[1\\]\n**Output:** \\[\\[1\\]\\]\n\n**Constraints:**\n\n*   `1 <= nums.length <= 6`\n*   `-10 <= nums[i] <= 10`\n*   All the integers of `nums` are **unique**.", "entry_point": "permutations", "canonical_solutions": {"python": "from typing import List\n\ndef permute(nums: List[int]) -> List[List[int]]:\n    def helper(index):\n        if index == len(nums) - 1:\n            results.append(nums[:])\n            return\n\n        for i in range(index, len(nums)):\n            nums[index], nums[i] = nums[i], nums[index]\n            helper(index + 1)\n            nums[index], nums[i] = nums[i], nums[index]\n\n    results = []\n    helper(0)\n    return results", "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> permute(int[] nums) {\n    List<List<Integer>> results = new ArrayList<>();\n    helper(nums, 0, results);\n    return results;\n}\n\nprivate void helper(int[] nums, int index, List<List<Integer>> results) {\n    if (index == nums.length - 1) {\n        List<Integer> tempList = new ArrayList<>();\n        for (int n : nums) {\n            tempList.add(n);\n        }\n        results.add(tempList);\n        return;\n    }\n\n    for (int i = index; i < nums.length; i++) {\n        swap(nums, index, i);\n        helper(nums, index + 1, results);\n        swap(nums, index, i);\n    }\n}\n\nprivate void swap(int[] nums, int i, int j) {\n    int temp = nums[i];\n    nums[i] = nums[j];\n    nums[j] = temp;\n}", "cpp": "#include <vector>\n\nvoid helper(std::vector<int>& nums, int index, std::vector<std::vector<int>>& results) {\n    if (index == nums.size() - 1) {\n        results.push_back(nums);\n        return;\n    }\n\n    for (int i = index; i < nums.size(); i++) {\n        std::swap(nums[index], nums[i]);\n        helper(nums, index + 1, results);\n        std::swap(nums[index], nums[i]);\n    }\n}\n\nstd::vector<std::vector<int>> permute(std::vector<int>& nums) {\n    std::vector<std::vector<int>> results;\n    helper(nums, 0, results);\n    return results;\n}", "javascript": "function permute(nums) {\n  const results = [];\n  helper(nums, 0, results);\n  return results;\n}\n\nfunction helper(nums, index, results) {\n  if (index === nums.length - 1) {\n    results.push(nums.slice());\n    return;\n  }\n\n  for (let i = index; i < nums.length; i++) {\n    [nums[index], nums[i]] = [nums[i], nums[index]];\n    helper(nums, index + 1, results);\n    [nums[index], nums[i]] = [nums[i], nums[index]];\n  }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/47", "prompt": "Given a collection of numbers, `nums`, that might contain duplicates, return _all possible unique permutations **in any order**._\n\n**Example 1:**\n\n**Input:** nums = \\[1,1,2\\]\n**Output:**\n\\[\\[1,1,2\\],\n \\[1,2,1\\],\n \\[2,1,1\\]\\]\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,3\\]\n**Output:** \\[\\[1,2,3\\],\\[1,3,2\\],\\[2,1,3\\],\\[2,3,1\\],\\[3,1,2\\],\\[3,2,1\\]\\]\n\n**Constraints:**\n\n*   `1 <= nums.length <= 8`\n*   `-10 <= nums[i] <= 10`", "entry_point": "permutations_ii", "canonical_solutions": {"python": "from typing import List\n\ndef permuteUnique(nums: List[int]) -> List[List[int]]:\n    def backtrack(start):\n        if start == len(nums):\n            result.append(nums[:])\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[start]:\n                continue\n            nums[start], nums[i] = nums[i], nums[start]\n            backtrack(start + 1)\n            nums[start], nums[i] = nums[i], nums[start]\n\n    nums.sort()\n    result = []\n    backtrack(0)\n    return result", "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic List<List<Integer>> permuteUnique(int[] nums) {\n    Arrays.sort(nums);\n    List<List<Integer>> result = new ArrayList<>();\n    boolean[] visited = new boolean[nums.length];\n    backtrack(result, new ArrayList<>(), nums, visited);\n    return result;\n}\n\nprivate void backtrack(List<List<Integer>> result, List<Integer> tempList, int[] nums, boolean[] visited) {\n    if (tempList.size() == nums.length) {\n        result.add(new ArrayList<>(tempList));\n    } else {\n        for (int i = 0; i < nums.length; i++) {\n            if (visited[i] || (i > 0 && nums[i] == nums[i - 1] && !visited[i - 1])) continue;\n            visited[i] = true;\n            tempList.add(nums[i]);\n            backtrack(result, tempList, nums, visited);\n            tempList.remove(tempList.size() - 1);\n            visited[i] = false;\n        }\n    }\n}", "cpp": "#include <vector>\n#include <algorithm>\n\nvoid backtrack(std::vector<std::vector<int>>& result, std::vector<int>& nums, int start) {\n    if (start == nums.size()) {\n        result.push_back(nums);\n        return;\n    }\n    for (int i = start; i < nums.size(); i++) {\n        if (i > start && nums[i] == nums[start]) continue;\n        std::swap(nums[start], nums[i]);\n        backtrack(result, nums, start + 1);\n        std::swap(nums[start], nums[i]);\n    }\n}\n\nstd::vector<std::vector<int>> permuteUnique(std::vector<int>& nums) {\n    std::sort(nums.begin(), nums.end());\n    std::vector<std::vector<int>> result;\n    backtrack(result, nums, 0);\n    return result;\n}", "javascript": "function permuteUnique(nums) {\n    nums.sort((a, b) => a - b);\n    const result = [];\n    const visited = new Array(nums.length).fill(false);\n\n    function backtrack(tempList) {\n        if (tempList.length === nums.length) {\n            result.push([...tempList]);\n            return;\n        }\n        for (let i = 0; i < nums.length; i++) {\n            if (visited[i] || (i > 0 && nums[i] === nums[i - 1] && !visited[i - 1])) continue;\n            visited[i] = true;\n            tempList.push(nums[i]);\n            backtrack(tempList);\n            tempList.pop();\n            visited[i] = false;\n        }\n    }\n\n    backtrack([]);\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/48", "prompt": "You are given an `n x n` 2D `matrix` representing an image, rotate the image by **90** degrees (clockwise).\n\nYou have to rotate the image [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm), which means you have to modify the input 2D matrix directly. **DO NOT** allocate another 2D matrix and do the rotation.\n\n**Example 1:**\n\n**Input:** matrix = \\[\\[1,2,3\\],\\[4,5,6\\],\\[7,8,9\\]\\]\n**Output:** \\[\\[7,4,1\\],\\[8,5,2\\],\\[9,6,3\\]\\]\n\n**Example 2:**\n\n**Input:** matrix = \\[\\[5,1,9,11\\],\\[2,4,8,10\\],\\[13,3,6,7\\],\\[15,14,12,16\\]\\]\n**Output:** \\[\\[15,13,2,5\\],\\[14,3,4,1\\],\\[12,6,8,9\\],\\[16,7,10,11\\]\\]\n\n**Constraints:**\n\n*   `n == matrix.length == matrix[i].length`\n*   `1 <= n <= 20`\n*   `-1000 <= matrix[i][j] <= 1000`", "entry_point": "rotate_image", "canonical_solutions": {"python": "def rotate(matrix):\n    n = len(matrix)\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp", "java": "public void rotate(int[][] matrix) {\n    int n = matrix.length;\n    for (int i = 0; i < n / 2; i++) {\n        for (int j = i; j < n - i - 1; j++) {\n            int temp = matrix[i][j];\n            matrix[i][j] = matrix[n - j - 1][i];\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];\n            matrix[j][n - i - 1] = temp;\n        }\n    }\n}", "cpp": "void rotate(vector<vector<int>>& matrix) {\n    int n = matrix.size();\n    for (int i = 0; i < n / 2; i++) {\n        for (int j = i; j < n - i - 1; j++) {\n            int temp = matrix[i][j];\n            matrix[i][j] = matrix[n - j - 1][i];\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];\n            matrix[j][n - i - 1] = temp;\n        }\n    }\n}", "javascript": "function rotate(matrix) {\n    let n = matrix.length;\n    for (let i = 0; i < Math.floor(n / 2); i++) {\n        for (let j = i; j < n - i - 1; j++) {\n            let temp = matrix[i][j];\n            matrix[i][j] = matrix[n - j - 1][i];\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];\n            matrix[j][n - i - 1] = temp;\n        }\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/49", "prompt": "Given an array of strings `strs`, group **the anagrams** together. You can return the answer in **any order**.\n\nAn **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\n**Example 1:**\n\n**Input:** strs = \\[\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"\\]\n**Output:** \\[\\[\"bat\"\\],\\[\"nat\",\"tan\"\\],\\[\"ate\",\"eat\",\"tea\"\\]\\]\n\n**Example 2:**\n\n**Input:** strs = \\[\"\"\\]\n**Output:** \\[\\[\"\"\\]\\]\n\n**Example 3:**\n\n**Input:** strs = \\[\"a\"\\]\n**Output:** \\[\\[\"a\"\\]\\]\n\n**Constraints:**\n\n*   `1 <= strs.length <= 104`\n*   `0 <= strs[i].length <= 100`\n*   `strs[i]` consists of lowercase English letters.", "entry_point": "group_anagrams", "canonical_solutions": {"python": "from collections import defaultdict\n\ndef group_anagrams(strs):\n    anagram_map = defaultdict(list)\n\n    for s in strs:\n        key = ''.join(sorted(s))\n        anagram_map[key].append(s)\n\n    return list(anagram_map.values())", "java": "import java.util.*;\n\npublic List<List<String>> groupAnagrams(String[] strs) {\n    Map<String, List<String>> anagramMap = new HashMap<>();\n\n    for (String str : strs) {\n        char[] keyChars = str.toCharArray();\n        Arrays.sort(keyChars);\n        String key = new String(keyChars);\n\n        anagramMap.putIfAbsent(key, new ArrayList<>());\n        anagramMap.get(key).add(str);\n    }\n\n    return new ArrayList<>(anagramMap.values());\n}", "cpp": "#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\nstd::vector<std::vector<std::string>> groupAnagrams(std::vector<std::string>& strs) {\n    std::map<std::string, std::vector<std::string>> anagramMap;\n\n    for (std::string str : strs) {\n        std::string key = str;\n        std::sort(key.begin(), key.end());\n        anagramMap[key].push_back(str);\n    }\n\n    std::vector<std::vector<std::string>> result;\n    for (auto &entry : anagramMap) {\n        result.push_back(entry.second);\n    }\n\n    return result;\n}", "javascript": "function groupAnagrams(strs) {\n    const anagramMap = new Map();\n\n    for (const str of strs) {\n        const key = str.split('').sort().join('');\n\n        if (!anagramMap.has(key)) {\n            anagramMap.set(key, []);\n        }\n        anagramMap.get(key).push(str);\n    }\n\n    return Array.from(anagramMap.values());\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/50", "prompt": "Implement [pow(x, n)](http://www.cplusplus.com/reference/valarray/pow/), which calculates `x` raised to the power `n` (i.e., `xn`).\n\n**Example 1:**\n\n**Input:** x = 2.00000, n = 10\n**Output:** 1024.00000\n\n**Example 2:**\n\n**Input:** x = 2.10000, n = 3\n**Output:** 9.26100\n\n**Example 3:**\n\n**Input:** x = 2.00000, n = -2\n**Output:** 0.25000\n**Explanation:** 2\\-2 = 1/22 = 1/4 = 0.25\n\n**Constraints:**\n\n*   `-100.0 < x < 100.0`\n*   `-231 <= n <= 231-1`\n*   `n` is an integer.\n*   `-104 <= xn <= 104`", "entry_point": "powx_n", "canonical_solutions": {"python": "def myPow(x: float, n: int) -> float:\n    if n == 0:\n        return 1\n    if n < 0:\n        x = 1 / x\n        n = -n\n    result = 1\n    currentProduct = x\n    i = n\n    while i:\n        if i % 2 == 1:\n            result *= currentProduct\n        currentProduct *= currentProduct\n        i //= 2\n    return result", "java": "double myPow(double x, int n) {\n    if (n == 0) return 1;\n    if (n < 0) {\n        x = 1 / x;\n        n = -n;\n    }\n    double result = 1;\n    double currentProduct = x;\n    for (long i = n; i > 0; i /= 2) {\n        if ((i % 2) == 1) {\n            result *= currentProduct;\n        }\n        currentProduct *= currentProduct;\n    }\n    return result;\n}", "cpp": "double myPow(double x, int n) {\n    if (n == 0) return 1;\n    if (n < 0) {\n        x = 1 / x;\n        n = -n;\n    }\n    double result = 1;\n    double currentProduct = x;\n    for (long long i = n; i; i /= 2) {\n        if ((i % 2) == 1) {\n            result = result * currentProduct;\n        }\n        currentProduct = currentProduct * currentProduct;\n    }\n    return result;\n}", "javascript": "function myPow(x, n) {\n    if (n === 0) return 1;\n    if (n < 0) {\n        x = 1 / x;\n        n = -n;\n    }\n    let result = 1;\n    let currentProduct = x;\n    for (let i = n; i > 0; i = Math.floor(i / 2)) {\n        if (i % 2 === 1) {\n            result *= currentProduct;\n        }\n        currentProduct *= currentProduct;\n    }\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/51", "prompt": "The **n-queens** puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other.\n\nGiven an integer `n`, return _all distinct solutions to the **n-queens puzzle**_. You may return the answer in **any order**.\n\nEach solution contains a distinct board configuration of the n-queens' placement, where `'Q'` and `'.'` both indicate a queen and an empty space, respectively.\n\n**Example 1:**\n\n**Input:** n = 4\n**Output:** \\[\\[ \".Q.. \", \"...Q \", \"Q... \", \"..Q. \"\\],\\[ \"..Q. \", \"Q... \", \"...Q \", \".Q.. \"\\]\\]\n**Explanation:** There exist two distinct solutions to the 4-queens puzzle as shown above\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** \\[\\[ \"Q \"\\]\\]\n\n**Constraints:**\n\n*   `1 <= n <= 9`", "entry_point": "n_queens", "canonical_solutions": {"python": "def solveNQueens(n):\n    def isSafe(board, row, col):\n        for i in range(col):\n            if board[row][i] == 'Q': return False\n        i, j = row, col\n        while i >= 0 and j >= 0:\n            if board[i][j] == 'Q': return False\n            i, j = i - 1, j - 1\n        i, j = row, col\n        while i < n and j >= 0:\n            if board[i][j] == 'Q': return False\n            i, j = i + 1, j - 1\n        return True\n\n    def solve(result, board, n, col):\n        if col == n:\n            result.append(board.copy())\n            return\n        for row in range(n):\n            if isSafe(board, row, col):\n                board[row] = board[row][:col] + 'Q' + board[row][col + 1:]\n                solve(result, board, n, col + 1)\n                board[row] = board[row][:col] + '.' + board[row][col + 1:]\n\n    result, board = [], ['.' * n for _ in range(n)]\n    solve(result, board, n, 0)\n    return result", "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<String>> solveNQueens(int n) {\n    List<List<String>> result = new ArrayList<>();\n    solve(result, new ArrayList<>(), n, 0);\n    return result;\n}\n\nprivate void solve(List<List<String>> result, List<Integer> current, int n, int col) {\n    if (col == n) {\n        result.add(generateBoard(current, n));\n        return;\n    }\n    for (int row = 0; row < n; row++) {\n        if(isSafe(current, row, col)) {\n            current.add(row);\n            solve(result, current, n, col + 1);\n            current.remove(col);\n        }\n    }\n}\n\nprivate boolean isSafe(List<Integer> current, int row, int col) {\n    for (int i = 0; i < col; i++) {\n        int prevRow = current.get(i);\n        if (prevRow == row || (Math.abs(col - i) == Math.abs(row - prevRow))) {\n            return false;\n        }\n    }\n    return true;\n}\n\nprivate List<String> generateBoard(List<Integer> current, int n) {\n    List<String> board = new ArrayList<>();\n    for (int row : current) {\n        StringBuilder sb = new StringBuilder();\n        for (int col = 0; col < n; col++)\n            sb.append((col == row) ? \"Q\" : \".\");\n        board.add(sb.toString());\n    }\n    return board;\n}", "cpp": "#include <vector>\n#include <string>\n\nbool isSafe(const std::vector<std::string>& board, int row, int col, int n) {\n    for (int i = 0; i < col; ++i) {\n        if (board[row][i] == 'Q') return false;\n    }\n    for (int i = row, j = col; i >= 0 && j >= 0; --i, --j) {\n        if (board[i][j] == 'Q') return false;\n    }\n    for (int i = row, j = col; i < n && j >= 0; ++i, --j) {\n        if (board[i][j] == 'Q') return false;\n    }\n    return true;\n}\n\nvoid solve(std::vector<std::vector<std::string>>& result, std::vector<std::string>& board, int n, int col) {\n    if (col == n) {\n        result.push_back(board);\n        return;\n    }\n    for (int row = 0; row < n; ++row) {\n        if (isSafe(board, row, col, n)) {\n            board[row][col] = 'Q';\n            solve(result, board, n, col + 1);\n            board[row][col] = '.';\n        }\n    }\n}\n\nstd::vector<std::vector<std::string>> solveNQueens(int n) {\n    std::vector<std::vector<std::string>> result;\n    std::vector<std::string> board(n, std::string(n, '.'));\n    solve(result, board, n, 0);\n    return result;\n}", "javascript": "function solveNQueens(n) {\n  function isSafe(board, row, col) {\n    for (let i = 0; i < col; i++)\n      if (board[row][i] == 'Q') return false;\n    for (let i = row, j = col; i >= 0 && j >= 0; i--, j--)\n      if (board[i][j] == 'Q') return false;\n    for (let i = row, j = col; i < n && j >= 0; i++, j--)\n      if (board[i][j] == 'Q') return false;\n    return true;\n  }\n\n  function solve(result, board, n, col) {\n    if (col == n) {\n      result.push(board.map(row => row.join('')));\n      return;\n    }\n    for (let row = 0; row < n; row++) {\n      if (isSafe(board, row, col)) {\n        board[row][col] = 'Q';\n        solve(result, board, n, col + 1);\n        board[row][col] = '.';\n      }\n    }\n  }\n\n  const result = [];\n  const board = Array.from({ length: n }, () => Array(n).fill('.'));\n  solve(result, board, n, 0);\n  return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/52", "prompt": "The **n-queens** puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other.\n\nGiven an integer `n`, return _the number of distinct solutions to the **n-queens puzzle**_.\n\n**Example 1:**\n\n**Input:** n = 4\n**Output:** 2\n**Explanation:** There are two distinct solutions to the 4-queens puzzle as shown.\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= n <= 9`", "entry_point": "n_queens_ii", "canonical_solutions": {"python": "def is_safe(cols, row):\n    col = len(cols)\n    for i, r in enumerate(cols):\n        if r == row or abs(i - col) == abs(r - row):\n            return False\n    return True\n\n\ndef backtrack(n, cols):\n    if len(cols) == n:\n        return 1\n\n    count = 0\n    for i in range(n):\n        if is_safe(cols, i):\n            cols.append(i)\n            count += backtrack(n, cols)\n            cols.pop()\n\n    return count\n\n\ndef total_n_queens(n):\n    cols = []\n    return backtrack(n, cols)", "java": "import java.util.ArrayList;\n\npublic int totalNQueens(int n) {\n    ArrayList<Integer> cols = new ArrayList<>();\n    return backtrack(n, cols);\n}\n\npublic int backtrack(int n, ArrayList<Integer> cols) {\n    if (cols.size() == n) {\n        return 1;\n    }\n\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (isSafe(cols, i)) {\n            cols.add(i);\n            count += backtrack(n, cols);\n            cols.remove(cols.size() - 1);\n        }\n    }\n    return count;\n}\n\npublic boolean isSafe(ArrayList<Integer> cols, int row) {\n    int col = cols.size();\n    for (int i = 0; i < cols.size(); i++) {\n        if (cols.get(i) == row || Math.abs(i - col) == Math.abs(cols.get(i) - row)) {\n            return false;\n        }\n    }\n    return true;\n}", "cpp": "#include <vector>\nusing namespace std;\n\nbool isSafe(vector<int> &cols, int row) {\n    int col = cols.size();\n    for (int i = 0; i < cols.size(); i++) {\n        if (cols[i] == row || abs(i - col) == abs(cols[i] - row)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid backtrack(int n, vector<int> &cols, int &count) {\n    if (cols.size() == n) {\n        count++;\n        return;\n    }\n\n    for (int i = 0; i < n; i++) {\n        if (isSafe(cols, i)) {\n            cols.push_back(i);\n            backtrack(n, cols, count);\n            cols.pop_back();\n        }\n    }\n}\n\nint totalNQueens(int n) {\n    vector<int> cols;\n    int count = 0;\n    backtrack(n, cols, count);\n    return count;\n}", "javascript": "function isSafe(cols, row) {\n    let col = cols.length;\n    for (let i = 0; i < cols.length; i++) {\n        if (cols[i] === row || Math.abs(i - col) === Math.abs(cols[i] - row)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction backtrack(n, cols) {\n    if (cols.length === n) {\n        return 1;\n    }\n\n    let count = 0;\n    for (let i = 0; i < n; i++) {\n        if (isSafe(cols, i)) {\n            cols.push(i);\n            count += backtrack(n, cols);\n            cols.pop();\n        }\n    }\n    return count;\n}\n\nfunction totalNQueens(n) {\n    let cols = [];\n    return backtrack(n, cols);\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/53", "prompt": "Given an integer array `nums`, find the subarray with the largest sum, and return _its sum_.\n\n**Example 1:**\n\n**Input:** nums = \\[-2,1,-3,4,-1,2,1,-5,4\\]\n**Output:** 6\n**Explanation:** The subarray \\[4,-1,2,1\\] has the largest sum 6.\n\n**Example 2:**\n\n**Input:** nums = \\[1\\]\n**Output:** 1\n**Explanation:** The subarray \\[1\\] has the largest sum 1.\n\n**Example 3:**\n\n**Input:** nums = \\[5,4,-1,7,8\\]\n**Output:** 23\n**Explanation:** The subarray \\[5,4,-1,7,8\\] has the largest sum 23.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-104 <= nums[i] <= 104`\n\n**Follow up:** If you have figured out the `O(n)` solution, try coding another solution using the **divide and conquer** approach, which is more subtle.", "entry_point": "maximum_subarray", "canonical_solutions": {"python": "def maxSubArray(nums):\n    max_sum = current_sum = nums[0]\n\n    for num in nums[1:]:\n        current_sum = max(current_sum + num, num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum", "java": "public int maxSubArray(int[] nums) {\n    int max_sum = nums[0];\n    int current_sum = max_sum;\n\n    for (int i = 1; i < nums.length; i++) {\n        current_sum = Math.max(current_sum + nums[i], nums[i]);\n        max_sum = Math.max(max_sum, current_sum);\n    }\n\n    return max_sum;\n}", "cpp": "int maxSubArray(vector<int>& nums) {\n    int max_sum = nums[0];\n    int current_sum = max_sum;\n    \n    for (int i = 1; i < nums.size(); i++) {\n        current_sum = max(current_sum + nums[i], nums[i]);\n        max_sum = max(max_sum, current_sum);\n    }\n    \n    return max_sum;\n}", "javascript": "function maxSubArray(nums) {\n    let max_sum = nums[0];\n    let current_sum = max_sum;\n\n    for (let i = 1; i < nums.length; i++) {\n        current_sum = Math.max(current_sum + nums[i], nums[i]);\n        max_sum = Math.max(max_sum, current_sum);\n    }\n\n    return max_sum;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/54", "prompt": "Given an `m x n` `matrix`, return _all elements of the_ `matrix` _in spiral order_.\n\n**Example 1:**\n\n**Input:** matrix = \\[\\[1,2,3\\],\\[4,5,6\\],\\[7,8,9\\]\\]\n**Output:** \\[1,2,3,6,9,8,7,4,5\\]\n\n**Example 2:**\n\n**Input:** matrix = \\[\\[1,2,3,4\\],\\[5,6,7,8\\],\\[9,10,11,12\\]\\]\n**Output:** \\[1,2,3,4,8,12,11,10,9,5,6,7\\]\n\n**Constraints:**\n\n*   `m == matrix.length`\n*   `n == matrix[i].length`\n*   `1 <= m, n <= 10`\n*   `-100 <= matrix[i][j] <= 100`", "entry_point": "spiral_matrix", "canonical_solutions": {"python": "def spiralOrder(matrix):\n    result = []\n    if not matrix: return result\n    m, n = len(matrix), len(matrix[0])\n    rowStart, colStart, rowEnd, colEnd = 0, 0, m - 1, n - 1\n\n    while rowStart <= rowEnd and colStart <= colEnd:\n        for i in range(colStart, colEnd + 1): \n            result.append(matrix[rowStart][i])\n        rowStart += 1\n        \n        for i in range(rowStart, rowEnd + 1): \n            result.append(matrix[i][colEnd]) \n        colEnd -= 1\n        \n        if rowStart <= rowEnd:\n            for i in range(colEnd, colStart - 1, -1): \n                result.append(matrix[rowEnd][i]) \n        rowEnd -= 1\n        \n        if colStart <= colEnd:\n            for i in range(rowEnd, rowStart - 1, -1): \n                result.append(matrix[i][colStart]) \n        colStart += 1\n        \n    return result", "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> spiralOrder(int[][] matrix) {\n    List<Integer> result = new ArrayList<>();\n    if (matrix == null || matrix.length == 0) return result;\n    int m = matrix.length, n = matrix[0].length;\n    int rowStart = 0, colStart = 0, rowEnd = m - 1, colEnd = n - 1;\n\n    while (rowStart <= rowEnd && colStart <= colEnd) {\n        for (int i = colStart; i <= colEnd; i++) {\n            result.add(matrix[rowStart][i]);\n        }\n        rowStart++;\n        for (int i = rowStart; i <= rowEnd; i++) {\n            result.add(matrix[i][colEnd]);\n        }\n        colEnd--;\n        if (rowStart <= rowEnd) {\n            for (int i = colEnd; i >= colStart; i--) {\n                result.add(matrix[rowEnd][i]);\n            }\n        }\n        rowEnd--;\n        if (colStart <= colEnd) {\n            for (int i = rowEnd; i >= rowStart; i--) {\n                result.add(matrix[i][colStart]);\n            }\n        }\n        colStart++;\n    }\n    return result;\n}", "cpp": "#include <vector>\nusing namespace std;\n\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\n    vector<int> result;\n    if (matrix.empty()) return result;\n    int m = matrix.size(), n = matrix[0].size();\n    int rowStart = 0, colStart = 0, rowEnd = m - 1, colEnd = n - 1;\n\n    while (rowStart <= rowEnd && colStart <= colEnd) {\n        for (int i = colStart; i <= colEnd; ++i) {\n            result.push_back(matrix[rowStart][i]);\n        }\n        rowStart++;\n        for (int i = rowStart; i <= rowEnd; ++i) {\n            result.push_back(matrix[i][colEnd]);\n        }\n        colEnd--;\n        if (rowStart <= rowEnd) {\n            for (int i = colEnd; i >= colStart; --i) {\n                result.push_back(matrix[rowEnd][i]);\n            }\n        }\n        rowEnd--;\n        if (colStart <= colEnd) {\n            for (int i = rowEnd; i >= rowStart; --i) {\n                result.push_back(matrix[i][colStart]);\n            }\n        }\n        colStart++;\n    }\n    return result;\n}", "javascript": "function spiralOrder(matrix) {\n    const result = [];\n    if (!matrix.length) return result;\n    let m = matrix.length, n = matrix[0].length;\n    let rowStart = 0, colStart = 0, rowEnd = m - 1, colEnd = n - 1;\n\n    while (rowStart <= rowEnd && colStart <= colEnd) {\n        for (let i = colStart; i <= colEnd; i++) {\n            result.push(matrix[rowStart][i]);\n        }\n        rowStart++;\n        for (let i = rowStart; i <= rowEnd; i++) {\n            result.push(matrix[i][colEnd]);\n        }\n        colEnd--;\n        if (rowStart <= rowEnd) {\n            for (let i = colEnd; i >= colStart; i--) {\n                result.push(matrix[rowEnd][i]);\n            }\n        }\n        rowEnd--;\n        if (colStart <= colEnd) {\n            for (let i = rowEnd; i >= rowStart; i--) {\n                result.push(matrix[i][colStart]);\n            }\n        }\n        colStart++;\n    }\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/55", "prompt": "You are given an integer array `nums`. You are initially positioned at the array's **first index**, and each element in the array represents your maximum jump length at that position.\n\nReturn `true` _if you can reach the last index, or_ `false` _otherwise_.\n\n**Example 1:**\n\n**Input:** nums = \\[2,3,1,1,4\\]\n**Output:** true\n**Explanation:** Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\n**Example 2:**\n\n**Input:** nums = \\[3,2,1,0,4\\]\n**Output:** false\n**Explanation:** You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `0 <= nums[i] <= 105`", "entry_point": "jump_game", "canonical_solutions": {"python": "def canJump(nums):\n    max_reach = 0\n    for i, num in enumerate(nums):\n        if i > max_reach:\n            return False\n        max_reach = max(max_reach, i + num)\n    return True", "java": "public boolean canJump(int[] nums) {\n    int maxReach = 0;\n    for (int i = 0; i < nums.length; ++i) {\n        if (i > maxReach) return false;\n        maxReach = Math.max(maxReach, i + nums[i]);\n    }\n    return true;\n}", "cpp": "bool canJump(vector<int>& nums) {\n    int maxReach = 0;\n    for (int i = 0; i < nums.size(); ++i) {\n        if (i > maxReach) return false;\n        maxReach = max(maxReach, i + nums[i]);\n    }\n    return true;\n}", "javascript": "function canJump(nums) {\n    let maxReach = 0;\n    for (let i = 0; i < nums.length; ++i) {\n        if (i > maxReach) return false;\n        maxReach = Math.max(maxReach, i + nums[i]);\n    }\n    return true;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/56", "prompt": "Given an array of `intervals` where `intervals[i] = [starti, endi]`, merge all overlapping intervals, and return _an array of the non-overlapping intervals that cover all the intervals in the input_.\n\n**Example 1:**\n\n**Input:** intervals = \\[\\[1,3\\],\\[2,6\\],\\[8,10\\],\\[15,18\\]\\]\n**Output:** \\[\\[1,6\\],\\[8,10\\],\\[15,18\\]\\]\n**Explanation:** Since intervals \\[1,3\\] and \\[2,6\\] overlap, merge them into \\[1,6\\].\n\n**Example 2:**\n\n**Input:** intervals = \\[\\[1,4\\],\\[4,5\\]\\]\n**Output:** \\[\\[1,5\\]\\]\n**Explanation:** Intervals \\[1,4\\] and \\[4,5\\] are considered overlapping.\n\n**Constraints:**\n\n*   `1 <= intervals.length <= 104`\n*   `intervals[i].length == 2`\n*   `0 <= starti <= endi <= 104`", "entry_point": "merge_intervals", "canonical_solutions": {"python": "def merge(intervals):\n    if not intervals:\n        return []\n\n    intervals.sort()\n    result = [intervals[0]]\n\n    for i in range(1, len(intervals)):\n        if result[-1][1] >= intervals[i][0]:\n            result[-1][1] = max(result[-1][1], intervals[i][1])\n        else:\n            result.append(intervals[i])\n\n    return result", "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic List<int[]> merge(int[][] intervals) {\n    if (intervals.length == 0) return new ArrayList<>();\n\n    Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\n    List<int[]> result = new ArrayList<>();\n    result.add(intervals[0]);\n\n    for (int i = 1; i < intervals.length; i++) {\n        if (result.get(result.size() - 1)[1] >= intervals[i][0]) {\n            result.get(result.size() - 1)[1] = Math.max(result.get(result.size() - 1)[1], intervals[i][1]);\n        } else {\n            result.add(intervals[i]);\n        }\n    }\n\n    return result;\n}", "cpp": "#include <vector>\n#include <algorithm>\n\nstd::vector<std::vector<int>> merge(std::vector<std::vector<int>>& intervals) {\n    if (intervals.empty()) return {};\n\n    std::sort(intervals.begin(), intervals.end());\n    std::vector<std::vector<int>> result;\n    result.push_back(intervals[0]);\n\n    for (int i = 1; i < intervals.size(); i++) {\n        if (result.back()[1] >= intervals[i][0]) {\n            result.back()[1] = std::max(result.back()[1], intervals[i][1]);\n        } else {\n            result.push_back(intervals[i]);\n        }\n    }\n\n    return result;\n}", "javascript": "function merge(intervals) {\n    if (intervals.length === 0) return [];\n\n    intervals.sort((a, b) => a[0] - b[0]);\n    const result = [intervals[0]];\n\n    for (let i = 1; i < intervals.length; i++) {\n        if (result[result.length - 1][1] >= intervals[i][0]) {\n            result[result.length - 1][1] = Math.max(result[result.length - 1][1], intervals[i][1]);\n        } else {\n            result.push(intervals[i]);\n        }\n    }\n\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/57", "prompt": "You are given an array of non-overlapping intervals `intervals` where `intervals[i] = [starti, endi]` represent the start and the end of the `ith` interval and `intervals` is sorted in ascending order by `starti`. You are also given an interval `newInterval = [start, end]` that represents the start and end of another interval.\n\nInsert `newInterval` into `intervals` such that `intervals` is still sorted in ascending order by `starti` and `intervals` still does not have any overlapping intervals (merge overlapping intervals if necessary).\n\nReturn `intervals` _after the insertion_.\n\n**Example 1:**\n\n**Input:** intervals = \\[\\[1,3\\],\\[6,9\\]\\], newInterval = \\[2,5\\]\n**Output:** \\[\\[1,5\\],\\[6,9\\]\\]\n\n**Example 2:**\n\n**Input:** intervals = \\[\\[1,2\\],\\[3,5\\],\\[6,7\\],\\[8,10\\],\\[12,16\\]\\], newInterval = \\[4,8\\]\n**Output:** \\[\\[1,2\\],\\[3,10\\],\\[12,16\\]\\]\n**Explanation:** Because the new interval \\[4,8\\] overlaps with \\[3,5\\],\\[6,7\\],\\[8,10\\].\n\n**Constraints:**\n\n*   `0 <= intervals.length <= 104`\n*   `intervals[i].length == 2`\n*   `0 <= starti <= endi <= 105`\n*   `intervals` is sorted by `starti` in **ascending** order.\n*   `newInterval.length == 2`\n*   `0 <= start <= end <= 105`", "entry_point": "insert_interval", "canonical_solutions": {"python": "from typing import List\n\ndef insert(intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n    result = []\n    start_pos = 0\n\n    while start_pos < len(intervals) and intervals[start_pos][1] < newInterval[0]:\n        result.append(intervals[start_pos])\n        start_pos += 1\n\n    while start_pos < len(intervals) and intervals[start_pos][0] <= newInterval[1]:\n        newInterval[0] = min(newInterval[0], intervals[start_pos][0])\n        newInterval[1] = max(newInterval[1], intervals[start_pos][1])\n        start_pos += 1\n\n    result.append(newInterval)\n\n    while start_pos < len(intervals):\n        result.append(intervals[start_pos])\n        start_pos += 1\n\n    return result", "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<int[]> insert(int[][] intervals, int[] newInterval) {\n    List<int[]> result = new ArrayList<>();\n    int start_pos = 0;\n\n    while (start_pos < intervals.length && intervals[start_pos][1] < newInterval[0]) {\n        result.add(intervals[start_pos]);\n        start_pos++;\n    }\n\n    while (start_pos < intervals.length && intervals[start_pos][0] <= newInterval[1]) {\n        newInterval[0] = Math.min(newInterval[0], intervals[start_pos][0]);\n        newInterval[1] = Math.max(newInterval[1], intervals[start_pos][1]);\n        start_pos++;\n    }\n\n    result.add(newInterval);\n\n    while (start_pos < intervals.length) {\n        result.add(intervals[start_pos]);\n        start_pos++;\n    }\n\n    return result;\n}", "cpp": "#include <vector>\nusing namespace std;\n\nvector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n    vector<vector<int>> result;\n    int start_pos = 0;\n\n    while (start_pos < intervals.size() && intervals[start_pos][1] < newInterval[0]) {\n        result.push_back(intervals[start_pos]);\n        start_pos++;\n    }\n\n    while (start_pos < intervals.size() && intervals[start_pos][0] <= newInterval[1]) {\n        newInterval[0] = min(newInterval[0], intervals[start_pos][0]);\n        newInterval[1] = max(newInterval[1], intervals[start_pos][1]);\n        start_pos++;\n    }\n\n    result.push_back(newInterval);\n\n    while (start_pos < intervals.size()) {\n        result.push_back(intervals[start_pos]);\n        start_pos++;\n    }\n\n    return result;\n}", "javascript": "function insert(intervals, newInterval) {\n    const result = [];\n    let start_pos = 0;\n\n    while (start_pos < intervals.length && intervals[start_pos][1] < newInterval[0]) {\n        result.push(intervals[start_pos]);\n        start_pos++;\n    }\n\n    while (start_pos < intervals.length && intervals[start_pos][0] <= newInterval[1]) {\n        newInterval[0] = Math.min(newInterval[0], intervals[start_pos][0]);\n        newInterval[1] = Math.max(newInterval[1], intervals[start_pos][1]);\n        start_pos++;\n    }\n\n    result.push(newInterval);\n\n    while (start_pos < intervals.length) {\n        result.push(intervals[start_pos]);\n        start_pos++;\n    }\n\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/58", "prompt": "Given a string `s` consisting of words and spaces, return _the length of the **last** word in the string._\n\nA **word** is a maximal substring consisting of non-space characters only.\n\n**Example 1:**\n\n**Input:** s =  \"Hello World \"\n**Output:** 5\n**Explanation:** The last word is  \"World \" with length 5.\n\n**Example 2:**\n\n**Input:** s =  \"   fly me   to   the moon   \"\n**Output:** 4\n**Explanation:** The last word is  \"moon \" with length 4.\n\n**Example 3:**\n\n**Input:** s =  \"luffy is still joyboy \"\n**Output:** 6\n**Explanation:** The last word is  \"joyboy \" with length 6.\n\n**Constraints:**\n\n*   `1 <= s.length <= 104`\n*   `s` consists of only English letters and spaces `' '`.\n*   There will be at least one word in `s`.", "entry_point": "length_of_last_word", "canonical_solutions": {"python": "def length_of_last_word(s: str) -> int:\n    length = 0\n    tail = len(s) - 1\n    while tail >= 0 and s[tail] == ' ':\n        tail -= 1\n    while tail >= 0 and s[tail] != ' ':\n        length += 1\n        tail -= 1\n    return length", "java": "public int lengthOfLastWord(String s) {\n    int length = 0;\n    int tail = s.length() - 1;\n    while (tail >= 0 && s.charAt(tail) == ' ') tail--;\n    while (tail >= 0 && s.charAt(tail) != ' ') {\n        length++;\n        tail--;\n    }\n    return length;\n}", "cpp": "int lengthOfLastWord(string s) {\n    int length = 0;\n    int tail = s.length() - 1;\n    while (tail >= 0 && s[tail] == ' ') tail--;\n    while (tail >= 0 && s[tail] != ' ') {\n        length++;\n        tail--;\n    }\n    return length;\n}", "javascript": "function lengthOfLastWord(s) {\n    let length = 0;\n    let tail = s.length - 1;\n    while (tail >= 0 && s[tail] === ' ') tail--;\n    while (tail >= 0 && s[tail] !== ' ') {\n        length++;\n        tail--;\n    }\n    return length;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/59", "prompt": "Given a positive integer `n`, generate an `n x n` `matrix` filled with elements from `1` to `n2` in spiral order.\n\n**Example 1:**\n\n**Input:** n = 3\n**Output:** \\[\\[1,2,3\\],\\[8,9,4\\],\\[7,6,5\\]\\]\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** \\[\\[1\\]\\]\n\n**Constraints:**\n\n*   `1 <= n <= 20`", "entry_point": "spiral_matrix_ii", "canonical_solutions": {"python": "def generateMatrix(n: int) -> List[List[int]]:\n    matrix = [[0] * n for _ in range(n)]\n    value, top, bottom, left, right = 1, 0, n - 1, 0, n - 1\n\n    while value <= n * n:\n        for i in range(left, right + 1):\n            matrix[top][i] = value\n            value += 1\n\n        for i in range(top + 1, bottom + 1):\n            matrix[i][right] = value\n            value += 1\n\n        if top < bottom and left < right:\n            for i in range(right - 1, left - 1, -1):\n                matrix[bottom][i] = value\n                value += 1\n\n            for i in range(bottom - 1, top, -1):\n                matrix[i][left] = value\n                value += 1\n\n        top, bottom, left, right = top + 1, bottom - 1, left + 1, right - 1\n\n    return matrix", "java": "import java.util.ArrayList;\nimport java.util.Arrays;\n\npublic int[][] generateMatrix(int n) {\n    int[][] matrix = new int[n][n];\n    int value = 1, top = 0, bottom = n - 1, left = 0, right = n - 1;\n\n    while (value <= n * n) {\n        for (int i = left; i <= right; i++) {\n            matrix[top][i] = value++;\n        }\n\n        for (int i = top + 1; i <= bottom; i++) {\n            matrix[i][right] = value++;\n        }\n\n        if (top < bottom && left < right) {\n            for (int i = right - 1; i >= left; i--) {\n                matrix[bottom][i] = value++;\n            }\n\n            for (int i = bottom - 1; i > top; i--) {\n                matrix[i][left] = value++;\n            }\n        }\n\n        top++; bottom--; left++; right--;\n    }\n\n    return matrix;\n}", "cpp": "#include <vector>\n\nstd::vector<std::vector<int>> generateMatrix(int n) {\n    std::vector<std::vector<int>> matrix(n, std::vector<int>(n));\n    int value = 1, top = 0, bottom = n - 1, left = 0, right = n - 1;\n\n    while (value <= n * n) {\n        for (int i = left; i <= right; i++) {\n            matrix[top][i] = value++;\n        }\n\n        for (int i = top + 1; i <= bottom; i++) {\n            matrix[i][right] = value++;\n        }\n\n        if (top < bottom && left < right) {\n            for (int i = right - 1; i >= left; i--) {\n                matrix[bottom][i] = value++;\n            }\n\n            for (int i = bottom - 1; i > top; i--) {\n                matrix[i][left] = value++;\n            }\n        }\n\n        top++, bottom--, left++, right--;\n    }\n\n    return matrix;\n}", "javascript": "function generateMatrix(n) {\n    const matrix = Array.from({ length: n }, () => new Array(n).fill(0));\n    let value = 1, top = 0, bottom = n - 1, left = 0, right = n - 1;\n\n    while (value <= n * n) {\n        for (let i = left; i <= right; i++) {\n            matrix[top][i] = value++;\n        }\n\n        for (let i = top + 1; i <= bottom; i++) {\n            matrix[i][right] = value++;\n        }\n\n        if (top < bottom && left < right) {\n            for (let i = right - 1; i >= left; i--) {\n                matrix[bottom][i] = value++;\n            }\n\n            for (let i = bottom - 1; i > top; i--) {\n                matrix[i][left] = value++;\n            }\n        }\n\n        top++, bottom--, left++, right--;\n    }\n\n    return matrix;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/60", "prompt": "The set `[1, 2, 3, ..., n]` contains a total of `n!` unique permutations.\n\nBy listing and labeling all of the permutations in order, we get the following sequence for `n = 3`:\n\n1.  `\"123 \"`\n2.  `\"132 \"`\n3.  `\"213 \"`\n4.  `\"231 \"`\n5.  `\"312 \"`\n6.  `\"321 \"`\n\nGiven `n` and `k`, return the `kth` permutation sequence.\n\n**Example 1:**\n\n**Input:** n = 3, k = 3\n**Output:** \"213\"\n\n**Example 2:**\n\n**Input:** n = 4, k = 9\n**Output:** \"2314\"\n\n**Example 3:**\n\n**Input:** n = 3, k = 1\n**Output:** \"123\"\n\n**Constraints:**\n\n*   `1 <= n <= 9`\n*   `1 <= k <= n!`", "entry_point": "permutation_sequence", "canonical_solutions": {"python": "def getPermutation(n, k):\n    factorials = [1]\n    nums = list(range(1, n + 1))\n    result = []\n\n    for i in range(1, n):\n        factorials.append(factorials[-1] * i)\n\n    k -= 1\n\n    for i in range(n, 0, -1):\n        index = k // factorials[i - 1]\n        k %= factorials[i - 1]\n        result.append(str(nums.pop(index)))\n\n    return ''.join(result)", "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic String getPermutation(int n, int k) {\n    List<Integer> nums = new ArrayList<>();\n    int[] factorials = new int[n];\n    StringBuilder sb = new StringBuilder();\n    int index;\n\n    factorials[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        nums.add(i);\n        factorials[i - 1] = i * factorials[i - 1];\n    }\n\n    k--;\n\n    for (int i = n; i >= 1; --i) {\n        index = k / factorials[i - 1];\n        k %= factorials[i - 1];\n        sb.append(nums.get(index));\n        nums.remove(index);\n    }\n\n    return sb.toString();\n}", "cpp": "#include <string>\n#include <vector>\n\nstd::string getPermutation(int n, int k) {\n    std::vector<int> factorials(n, 1);\n    std::vector<char> nums(n, '1');\n    std::string result;\n    int index;\n\n    for (int i = 1; i <= n; ++i) {\n        nums[i - 1] += i - 1;\n        factorials[i - 1] *= i;\n    }\n\n    k--;\n\n    for (int i = n; i >= 1; --i) {\n        index = k / factorials[i - 1];\n        k %= factorials[i - 1];\n        result.push_back(nums[index]);\n        nums.erase(nums.begin() + index);\n    }\n\n    return result;\n}", "javascript": "function getPermutation(n, k) {\n    const factorials = [1];\n    const nums = [...Array(n)].map((_, i) => i + 1);\n    let result = '';\n\n    for (let i = 1; i < n; i++) {\n        factorials[i] = factorials[i - 1] * i;\n    }\n\n    k--;\n\n    for (let i = n; i >= 1; i--) {\n        const index = Math.floor(k / factorials[i - 1]);\n        k %= factorials[i - 1];\n        result += nums[index];\n        nums.splice(index, 1);\n    }\n\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/61", "prompt": "Given the `head` of a linked list, rotate the list to the right by `k` places.\n\n**Example 1:**\n\n**Input:** head = \\[1,2,3,4,5\\], k = 2\n**Output:** \\[4,5,1,2,3\\]\n\n**Example 2:**\n\n**Input:** head = \\[0,1,2\\], k = 4\n**Output:** \\[2,0,1\\]\n\n**Constraints:**\n\n*   The number of nodes in the list is in the range `[0, 500]`.\n*   `-100 <= Node.val <= 100`\n*   `0 <= k <= 2 * 109`", "entry_point": "rotate_list", "canonical_solutions": {"python": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef rotateRight(head, k):\n    if not head or not head.next or k == 0:\n        return head\n\n    current = head\n    length = 1\n    while current.next:\n        length += 1\n        current = current.next\n    current.next = head\n    k = length - k % length\n\n    while k:\n        k -= 1\n        current = current.next\n    head = current.next\n    current.next = None\n\n    return head", "java": "public class ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) {\n        this.val = val;\n    }\n    ListNode(int val, ListNode next) {\n        this.val = val;\n        this.next = next;\n    }\n}\n\npublic ListNode rotateRight(ListNode head, int k) {\n    if (head == null || head.next == null || k == 0) return head;\n\n    ListNode current = head;\n    int len = 1;\n    while (current.next != null) {\n        len++;\n        current = current.next;\n    }\n    current.next = head;\n    k = len - k % len;\n\n    while (k-- > 0) {\n        current = current.next;\n    }\n    head = current.next;\n    current.next = null;\n\n    return head;\n}", "cpp": "class ListNode {\npublic:\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n\n};\n\nListNode* rotateRight(ListNode* head, int k) {\n    if (!head || !head->next || k == 0) return head;\n\n    ListNode *current = head;\n    int len = 1;\n    while (current->next) {\n        len++;\n        current = current->next;\n    }\n    current->next = head;\n    k = len - k % len;\n\n    while (k--) {\n        current = current->next;\n    }\n    head = current->next;\n    current->next = nullptr;\n\n    return head;\n}", "javascript": "class ListNode {\n    constructor(val, next) {\n        this.val = (val === undefined ? 0 : val);\n        this.next = (next === undefined ? null : next);\n    }\n}\n\nfunction rotateRight(head, k) {\n    if (!head || !head.next || k === 0) return head;\n\n    let current = head;\n    let len = 1;\n    while (current.next) {\n        len++;\n        current = current.next;\n    }\n    current.next = head;\n    k = len - k % len;\n\n    while (k--) {\n        current = current.next;\n    }\n    head = current.next;\n    current.next = null;\n\n    return head;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/62", "prompt": "There is a robot on an `m x n` grid. The robot is initially located at the **top-left corner** (i.e., `grid[0][0]`). The robot tries to move to the **bottom-right corner** (i.e., `grid[m - 1][n - 1]`). The robot can only move either down or right at any point in time.\n\nGiven the two integers `m` and `n`, return _the number of possible unique paths that the robot can take to reach the bottom-right corner_.\n\nThe test cases are generated so that the answer will be less than or equal to `2 * 109`.\n\n**Example 1:**\n\n**Input:** m = 3, n = 7\n**Output:** 28\n\n**Example 2:**\n\n**Input:** m = 3, n = 2\n**Output:** 3\n**Explanation:** From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n1. Right -> Down -> Down\n2. Down -> Down -> Right\n3. Down -> Right -> Down\n\n**Constraints:**\n\n*   `1 <= m, n <= 100`", "entry_point": "unique_paths", "canonical_solutions": {"python": "def uniquePaths(m, n):\n    dp = [[1] * n for _ in range(m)]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    return dp[m - 1][n - 1]", "java": "public int uniquePaths(int m, int n) {\n    int[][] dp = new int[m][n];\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == 0 || j == 0) {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n    }\n    return dp[m - 1][n - 1];\n}", "cpp": "int uniquePaths(int m, int n) {\n    vector<vector<int>> dp(m, vector<int>(n, 1));\n    for (int i = 1; i < m; i++) {\n        for (int j = 1; j < n; j++) {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n    return dp[m - 1][n - 1];\n}", "javascript": "function uniquePaths(m, n) {\n    const dp = Array.from({ length: m }, () => Array(n).fill(1));\n    for (let i = 1; i < m; i++) {\n        for (let j = 1; j < n; j++) {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n    return dp[m - 1][n - 1];\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/63", "prompt": "You are given an `m x n` integer array `grid`. There is a robot initially located at the **top-left corner** (i.e., `grid[0][0]`). The robot tries to move to the **bottom-right corner** (i.e., `grid[m - 1][n - 1]`). The robot can only move either down or right at any point in time.\n\nAn obstacle and space are marked as `1` or `0` respectively in `grid`. A path that the robot takes cannot include **any** square that is an obstacle.\n\nReturn _the number of possible unique paths that the robot can take to reach the bottom-right corner_.\n\nThe testcases are generated so that the answer will be less than or equal to `2 * 109`.\n\n**Example 1:**\n\n**Input:** obstacleGrid = \\[\\[0,0,0\\],\\[0,1,0\\],\\[0,0,0\\]\\]\n**Output:** 2\n**Explanation:** There is one obstacle in the middle of the 3x3 grid above.\nThere are two ways to reach the bottom-right corner:\n1. Right -> Right -> Down -> Down\n2. Down -> Down -> Right -> Right\n\n**Example 2:**\n\n**Input:** obstacleGrid = \\[\\[0,1\\],\\[0,0\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `m == obstacleGrid.length`\n*   `n == obstacleGrid[i].length`\n*   `1 <= m, n <= 100`\n*   `obstacleGrid[i][j]` is `0` or `1`.", "entry_point": "unique_paths_ii", "canonical_solutions": {"python": "def uniquePathsWithObstacles(grid):\n    m, n = len(grid), len(grid[0])\n    if grid[0][0] == 1:\n        return 0\n\n    grid[0][0] = 1\n    for i in range(1, m):\n        grid[i][0] = 1 if grid[i][0] == 0 and grid[i - 1][0] == 1 else 0\n    for i in range(1, n):\n        grid[0][i] = 1 if grid[0][i] == 0 and grid[0][i - 1] == 1 else 0\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if grid[i][j] == 0:\n                grid[i][j] = grid[i - 1][j] + grid[i][j - 1]\n            else:\n                grid[i][j] = 0\n\n    return grid[m - 1][n - 1]", "java": "public int uniquePathsWithObstacles(int[][] grid) {\n    int m = grid.length;\n    int n = grid[0].length;\n    if (grid[0][0] == 1) return 0;\n    \n    grid[0][0] = 1;\n    for (int i = 1; i < m; ++i)\n        grid[i][0] = (grid[i][0] == 0 && grid[i - 1][0] == 1) ? 1 : 0;\n    for (int i = 1; i < n; ++i)\n        grid[0][i] = (grid[0][i] == 0 && grid[0][i - 1] == 1) ? 1 : 0;\n\n    for (int i = 1; i < m; ++i)\n        for (int j = 1; j < n; ++j)\n            if (grid[i][j] == 0)\n                grid[i][j] = grid[i - 1][j] + grid[i][j - 1];\n            else\n                grid[i][j] = 0;\n\n    return grid[m - 1][n - 1];\n}", "cpp": "int uniquePathsWithObstacles(vector<vector<int>>& grid) {\n    int m = grid.size();\n    int n = grid[0].size();\n    if (grid[0][0] == 1) return 0;\n    \n    grid[0][0] = 1;\n    for (int i = 1; i < m; ++i)\n        grid[i][0] = (grid[i][0] == 0 && grid[i - 1][0] == 1) ? 1 : 0;\n    for (int i = 1; i < n; ++i)\n        grid[0][i] = (grid[0][i] == 0 && grid[0][i - 1] == 1) ? 1 : 0;\n\n    for (int i = 1; i < m; ++i)\n        for (int j = 1; j < n; ++j)\n            if (grid[i][j] == 0) \n                grid[i][j] = grid[i - 1][j] + grid[i][j - 1];\n            else \n                grid[i][j] = 0;\n\n    return grid[m - 1][n - 1];\n}", "javascript": "function uniquePathsWithObstacles(grid) {\n    const m = grid.length;\n    const n = grid[0].length;\n    if (grid[0][0] === 1) return 0;\n\n    grid[0][0] = 1;\n    for (let i = 1; i < m; ++i) {\n        grid[i][0] = (grid[i][0] === 0 && grid[i - 1][0] === 1) ? 1 : 0;\n    }\n    for (let i = 1; i < n; ++i) {\n        grid[0][i] = (grid[0][i] === 0 && grid[0][i - 1] === 1) ? 1 : 0;\n    }\n\n    for (let i = 1; i < m; ++i) {\n        for (let j = 1; j < n; ++j) {\n            if (grid[i][j] === 0) {\n                grid[i][j] = grid[i - 1][j] + grid[i][j - 1];\n            } else {\n                grid[i][j] = 0;\n            }\n        }\n    }\n\n    return grid[m - 1][n - 1];\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/64", "prompt": "Given a `m x n` `grid` filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n\n**Note:** You can only move either down or right at any point in time.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[1,3,1\\],\\[1,5,1\\],\\[4,2,1\\]\\]\n**Output:** 7\n**Explanation:** Because the path 1 -> 3 -> 1 -> 1 -> 1 minimizes the sum.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,2,3\\],\\[4,5,6\\]\\]\n**Output:** 12\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 200`\n*   `0 <= grid[i][j] <= 100`", "entry_point": "minimum_path_sum", "canonical_solutions": {"python": "def minPathSum(grid):\n    m, n = len(grid), len(grid[0])\n\n    for i in range(1, m):\n        grid[i][0] += grid[i - 1][0]\n\n    for i in range(1, n):\n        grid[0][i] += grid[0][i - 1]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\n\n    return grid[m - 1][n - 1]", "java": "public int minPathSum(int[][] grid) {\n    int m = grid.length, n = grid[0].length;\n        \n    for(int i = 1; i < m; i++)\n        grid[i][0] += grid[i - 1][0];\n        \n    for(int i = 1; i < n; i++)\n        grid[0][i] += grid[0][i - 1];\n        \n    for(int i = 1; i < m; i++){\n        for(int j = 1; j < n; j++){\n            grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);\n        }\n    }\n    return grid[m - 1][n - 1];\n}", "cpp": "int minPathSum(vector<vector<int>>& grid) {\n    int m = grid.size(), n = grid[0].size();\n        \n    for(int i = 1; i < m; i++)\n        grid[i][0] += grid[i - 1][0];\n        \n    for(int i = 1; i < n; i++)\n        grid[0][i] += grid[0][i - 1];\n        \n    for(int i = 1; i < m; i++){\n        for(int j = 1; j < n; j++){\n            grid[i][j] += min(grid[i - 1][j], grid[i][j - 1]);\n        }\n    }\n    return grid[m - 1][n - 1];\n}", "javascript": "function minPathSum(grid) {\n    let m = grid.length, n = grid[0].length;\n        \n    for(let i = 1; i < m; i++)\n        grid[i][0] += grid[i - 1][0];\n        \n    for(let i = 1; i < n; i++)\n        grid[0][i] += grid[0][i - 1];\n        \n    for(let i = 1; i < m; i++){\n        for(let j = 1; j < n; j++){\n            grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);\n        }\n    }\n    return grid[m - 1][n - 1];\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/65", "prompt": "A **valid number** can be split up into these components (in order):\n\n1.  A **decimal number** or an **integer**.\n2.  (Optional) An `'e'` or `'E'`, followed by an **integer**.\n\nA **decimal number** can be split up into these components (in order):\n\n1.  (Optional) A sign character (either `'+'` or `'-'`).\n2.  One of the following formats:\n    1.  One or more digits, followed by a dot `'.'`.\n    2.  One or more digits, followed by a dot `'.'`, followed by one or more digits.\n    3.  A dot `'.'`, followed by one or more digits.\n\nAn **integer** can be split up into these components (in order):\n\n1.  (Optional) A sign character (either `'+'` or `'-'`).\n2.  One or more digits.\n\nFor example, all the following are valid numbers: `[ \"2 \", \"0089 \", \"-0.1 \", \"+3.14 \", \"4. \", \"-.9 \", \"2e10 \", \"-90E3 \", \"3e+7 \", \"+6e-1 \", \"53.5e93 \", \"-123.456e789 \"]`, while the following are not valid numbers: `[ \"abc \", \"1a \", \"1e \", \"e3 \", \"99e2.5 \", \"--6 \", \"-+3 \", \"95a54e53 \"]`.\n\nGiven a string `s`, return `true` _if_ `s` _is a **valid number**_.\n\n**Example 1:**\n\n**Input:** s =  \"0 \"\n**Output:** true\n\n**Example 2:**\n\n**Input:** s =  \"e \"\n**Output:** false\n\n**Example 3:**\n\n**Input:** s =  \". \"\n**Output:** false\n\n**Constraints:**\n\n*   `1 <= s.length <= 20`\n*   `s` consists of only English letters (both uppercase and lowercase), digits (`0-9`), plus `'+'`, minus `'-'`, or dot `'.'`.", "entry_point": "valid_number", "canonical_solutions": {"python": "import re\n\ndef is_number(s: str) -> bool:\n    pattern = re.compile(r'^[-+]?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(e[-+]?[0-9]+)?$')\n    return bool(pattern.match(s))", "java": "import java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\npublic class Solution {\n    public boolean isNumber(String s) {\n        String pattern = \"^[-+]?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(e[-+]?[0-9]+)?$\";\n        return Pattern.matches(pattern, s);\n    }\n}", "cpp": "#include <regex>\n#include <string>\n\nbool isNumber(const std::string& s) {\n    std::regex pattern(\"^[-+]?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(e[-+]?[0-9]+)?$\");\n    return std::regex_match(s, pattern);\n}", "javascript": "function isNumber(s) {\n    const pattern = /^[-+]?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(e[-+]?[0-9]+)?$/;\n    return pattern.test(s);\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/66", "prompt": "You are given a **large integer** represented as an integer array `digits`, where each `digits[i]` is the `ith` digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading `0`'s.\n\nIncrement the large integer by one and return _the resulting array of digits_.\n\n**Example 1:**\n\n**Input:** digits = \\[1,2,3\\]\n**Output:** \\[1,2,4\\]\n**Explanation:** The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be \\[1,2,4\\].\n\n**Example 2:**\n\n**Input:** digits = \\[4,3,2,1\\]\n**Output:** \\[4,3,2,2\\]\n**Explanation:** The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be \\[4,3,2,2\\].\n\n**Example 3:**\n\n**Input:** digits = \\[9\\]\n**Output:** \\[1,0\\]\n**Explanation:** The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be \\[1,0\\].\n\n**Constraints:**\n\n*   `1 <= digits.length <= 100`\n*   `0 <= digits[i] <= 9`\n*   `digits` does not contain any leading `0`'s.", "entry_point": "plus_one", "canonical_solutions": {"python": "def plusOne(digits: List[int]) -> List[int]:\n    n = len(digits)\n\n    for i in range(n - 1, -1, -1):\n        if digits[i] < 9:\n            digits[i] += 1\n            return digits\n        digits[i] = 0\n\n    digits.insert(0, 1)\n    return digits", "java": "public int[] plusOne(int[] digits) {\n    int n = digits.length;\n\n    for(int i = n - 1; i >= 0; i--) {\n        if(digits[i] < 9) {\n            digits[i]++;\n            return digits;\n        }\n        digits[i] = 0;\n    }\n\n    int[] newDigits = new int[n + 1];\n    newDigits[0] = 1;\n    return newDigits;\n}", "cpp": "#include <vector>\n\nstd::vector<int> plusOne(std::vector<int>& digits) {\n    int n = digits.size();\n\n    for(int i = n - 1; i >= 0; i--) {\n        if(digits[i] < 9) {\n            digits[i]++;\n            return digits;\n        }\n        digits[i] = 0;\n    }\n\n    digits.insert(digits.begin(), 1);\n    return digits;\n}", "javascript": "function plusOne(digits) {\n    let n = digits.length;\n\n    for(let i = n - 1; i >= 0; i--) {\n        if(digits[i] < 9) {\n            digits[i]++;\n            return digits;\n        }\n        digits[i] = 0;\n    }\n\n    digits.unshift(1);\n    return digits;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/67", "prompt": "Given two binary strings `a` and `b`, return _their sum as a binary string_.\n\n**Example 1:**\n\n**Input:** a = \"11\", b = \"1\"\n**Output:** \"100\"\n\n**Example 2:**\n\n**Input:** a = \"1010\", b = \"1011\"\n**Output:** \"10101\"\n\n**Constraints:**\n\n*   `1 <= a.length, b.length <= 104`\n*   `a` and `b` consist only of `'0'` or `'1'` characters.\n*   Each string does not contain leading zeros except for the zero itself.", "entry_point": "add_binary", "canonical_solutions": {"python": "def addBinary(a: str, b: str) -> str:\n    result, carry, i, j = \"\", 0, len(a) - 1, len(b) - 1\n    while i >= 0 or j >= 0 or carry:\n        if i >= 0:\n            carry += int(a[i])\n            i -= 1\n        if j >= 0:\n            carry += int(b[j])\n            j -= 1\n        result = str(carry % 2) + result\n        carry //= 2\n    return result", "java": "public String addBinary(String a, String b) {\n    StringBuilder result = new StringBuilder();\n    int i = a.length() - 1, j = b.length() - 1, carry = 0;\n    while (i >= 0 || j >= 0 || carry != 0) {\n        if (i >= 0) carry += a.charAt(i--) - '0';\n        if (j >= 0) carry += b.charAt(j--) - '0';\n        result.insert(0, carry % 2);\n        carry /= 2;\n    }\n    return result.toString();\n}", "cpp": "std::string addBinary(std::string a, std::string b) {\n    std::string result = \"\";\n    int i = a.size() - 1, j = b.size() - 1, carry = 0;\n    while (i >= 0 || j >= 0 || carry) {\n        if (i >= 0) carry += a[i--] - '0';\n        if (j >= 0) carry += b[j--] - '0';\n        result = char(carry % 2 + '0') + result;\n        carry /= 2;\n    }\n    return result;\n}", "javascript": "function addBinary(a, b) {\n    let result = \"\";\n    let i = a.length - 1, j = b.length - 1, carry = 0;\n    while (i >= 0 || j >= 0 || carry) {\n        if (i >= 0) carry += parseInt(a[i--], 10);\n        if (j >= 0) carry += parseInt(b[j--], 10);\n        result = (carry % 2) + result;\n        carry = Math.floor(carry / 2);\n    }\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/68", "prompt": "Given an array of strings `words` and a width `maxWidth`, format the text such that each line has exactly `maxWidth` characters and is fully (left and right) justified.\n\nYou should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces `' '` when necessary so that each line has exactly `maxWidth` characters.\n\nExtra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\n\nFor the last line of text, it should be left-justified, and no extra space is inserted between words.\n\n**Note:**\n\n*   A word is defined as a character sequence consisting of non-space characters only.\n*   Each word's length is guaranteed to be greater than `0` and not exceed `maxWidth`.\n*   The input array `words` contains at least one word.\n\n**Example 1:**\n\n**Input:** words = \\[ \"This \",  \"is \",  \"an \",  \"example \",  \"of \",  \"text \",  \"justification. \"\\], maxWidth = 16\n**Output:**\n\\[\n    \"This    is    an \",\n    \"example  of text \",\n    \"justification.   \"\n\\]\n\n**Example 2:**\n\n**Input:** words = \\[ \"What \", \"must \", \"be \", \"acknowledgment \", \"shall \", \"be \"\\], maxWidth = 16\n**Output:**\n\\[\n   \"What   must   be \",\n   \"acknowledgment   \",\n   \"shall be         \"\n\\]\n**Explanation:** Note that the last line is  \"shall be     \" instead of  \"shall     be \", because the last line must be left-justified instead of fully-justified.\nNote that the second line is also left-justified because it contains only one word.\n\n**Example 3:**\n\n**Input:** words = \\[ \"Science \", \"is \", \"what \", \"we \", \"understand \", \"well \", \"enough \", \"to \", \"explain \", \"to \", \"a \", \"computer. \", \"Art \", \"is \", \"everything \", \"else \", \"we \", \"do \"\\], maxWidth = 20\n**Output:**\n\\[\n   \"Science  is  what we \",\n   \"understand      well \",\n   \"enough to explain to \",\n   \"a  computer.  Art is \",\n   \"everything  else  we \",\n   \"do                   \"\n\\]\n\n**Constraints:**\n\n*   `1 <= words.length <= 300`\n*   `1 <= words[i].length <= 20`\n*   `words[i]` consists of only English letters and symbols.\n*   `1 <= maxWidth <= 100`\n*   `words[i].length <= maxWidth`", "entry_point": "text_justification", "canonical_solutions": {"python": "def fullJustify(words, maxWidth):\n    result = []\n    idx = 0\n    while idx < len(words):\n        total_chars = len(words[idx])\n        last = idx + 1\n        while last < len(words):\n            if total_chars + 1 + len(words[last]) > maxWidth:\n                break\n            total_chars += 1 + len(words[last])\n            last += 1\n        gaps = last - idx - 1\n        line = []\n        if last == len(words) or gaps == 0:\n            for i in range(idx, last):\n                line.append(words[i])\n                if i < last - 1:\n                    line.append(\" \")\n            while sum(len(w) for w in line) < maxWidth:\n                line.append(\" \")\n        else:\n            even_spaces = (maxWidth - total_chars) // gaps\n            extra_spaces = (maxWidth - total_chars) % gaps\n            for i in range(idx, last):\n                line.append(words[i])\n                if i < last - 1:\n                    line.append(\" \" * (even_spaces + (1 if i - idx < extra_spaces else 0)))\n        idx = last\n        result.append(\"\".join(line))\n    return result", "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> fullJustify(String[] words, int maxWidth) {\n    List<String> result = new ArrayList<>();\n    int idx = 0;\n    while (idx < words.length) {\n        int totalChars = words[idx].length();\n        int last = idx + 1;\n        while (last < words.length) {\n            if (totalChars + 1 + words[last].length() > maxWidth) break;\n            totalChars += 1 + words[last].length();\n            last++;\n        }\n        int gaps = last - idx - 1;\n        StringBuilder line = new StringBuilder();\n        if (last == words.length || gaps == 0) {\n            for (int i = idx; i < last; i++) {\n                line.append(words[i]);\n                if (i < last - 1) line.append(\" \");\n            }\n            while (line.length() < maxWidth) line.append(\" \");\n        } else {\n            int evenSpaces = (maxWidth - totalChars) / gaps;\n            int extraSpaces = (maxWidth - totalChars) % gaps;\n            for (int i = idx; i < last; i++) {\n                line.append(words[i]);\n                if (i < last - 1) {\n                    line.append(\" \".repeat(evenSpaces + (i - idx < extraSpaces ? 1 : 0)));\n                }\n            }\n        }\n        idx = last;\n        result.add(line.toString());\n    }\n    return result;\n}", "cpp": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> fullJustify(vector<string>& words, int maxWidth) {\n    vector<string> result;\n    int idx = 0;\n    while (idx < words.size()) {\n        int totalChars = words[idx].size();\n        int last = idx + 1;\n        while (last < words.size()) {\n            if (totalChars + 1 + words[last].length() > maxWidth) break;\n            totalChars += 1 + words[last].length();\n            last++;\n        }\n        int gaps = last - idx - 1;\n        stringstream line;\n        if (last == words.size() || gaps == 0) {\n            for (int i = idx; i < last; i++) {\n                line << words[i];\n                if (i < last - 1) line << \" \";\n            }\n            line << string(maxWidth - line.str().size(), ' ');\n        } else {\n            int evenSpaces = (maxWidth - totalChars) / gaps;\n            int extraSpaces = (maxWidth - totalChars) % gaps;\n            for (int i = idx; i < last; i++) {\n                line << words[i];\n                if (i < last - 1) {\n                    line << string(evenSpaces + (i - idx < extraSpaces ? 1 : 0), ' ');\n                }\n            }\n        }\n        idx = last;\n        result.push_back(line.str());\n    }\n    return result;\n}", "javascript": "function fullJustify(words, maxWidth) {\n    const result = [];\n    let idx = 0;\n    while (idx < words.length) {\n        let totalChars = words[idx].length;\n        let last = idx + 1;\n        while (last < words.length) {\n            if (totalChars + 1 + words[last].length > maxWidth) break;\n            totalChars += 1 + words[last].length;\n            last++;\n        }\n        const gaps = last - idx - 1;\n        let line = \"\";\n        if (last === words.length || gaps === 0) {\n            for (let i = idx; i < last; i++) {\n                line += words[i];\n                if (i < last - 1) line += \" \";\n            }\n            while (line.length < maxWidth) line += \" \";\n        } else {\n            const evenSpaces = Math.floor((maxWidth - totalChars) / gaps);\n            const extraSpaces = (maxWidth - totalChars) % gaps;\n            for (let i = idx; i < last; i++) {\n                line += words[i];\n                if (i < last - 1) {\n                    line += \" \".repeat(evenSpaces + (i - idx < extraSpaces ? 1 : 0));\n                }\n            }\n        }\n        idx = last;\n        result.push(line);\n    }\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/69", "prompt": "Given a non-negative integer `x`, return _the square root of_ `x` _rounded down to the nearest integer_. The returned integer should be **non-negative** as well.\n\nYou **must not use** any built-in exponent function or operator.\n\n*   For example, do not use `pow(x, 0.5)` in c++ or `x ** 0.5` in python.\n\n**Example 1:**\n\n**Input:** x = 4\n**Output:** 2\n**Explanation:** The square root of 4 is 2, so we return 2.\n\n**Example 2:**\n\n**Input:** x = 8\n**Output:** 2\n**Explanation:** The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned.\n\n**Constraints:**\n\n*   `0 <= x <= 231 - 1`", "entry_point": "sqrtx", "canonical_solutions": {"python": "def mySqrt(x):\n    if x == 0 or x == 1:\n        return x\n    start, end, ans = 1, x, 0\n    while start <= end:\n        mid = (start + end) // 2\n        if mid * mid == x:\n            return mid\n        if mid * mid < x:\n            start = mid + 1\n            ans = mid\n        else:\n            end = mid - 1\n    return ans", "java": "public int mySqrt(int x) {\n    if (x == 0 || x == 1) return x;\n    int start = 1, end = x, ans = 0;\n    while (start <= end) {\n        int mid = (start + end) / 2;\n        if (mid * mid == x) return mid;\n        if (mid <= x / mid) {\n            start = mid + 1;\n            ans = mid;\n        } else {\n            end = mid - 1;\n        }\n    }\n    return ans;\n}", "cpp": "int mySqrt(int x) {\n    if (x == 0 || x == 1) return x;\n    int start = 1, end = x, ans;\n    while (start <= end) {\n        int mid = (start + end) / 2;\n        if (mid * mid == x) return mid;\n        if (mid * mid < x) {\n            start = mid + 1;\n            ans = mid;\n        } else {\n            end = mid - 1;\n        }\n    }\n    return ans;\n}", "javascript": "function mySqrt(x) {\n    if (x === 0 || x === 1) return x;\n    let start = 1, end = x, ans;\n    while (start <= end) {\n        let mid = Math.floor((start + end) / 2);\n        if (mid * mid === x) return mid;\n        if (mid * mid < x) {\n            start = mid + 1;\n            ans = mid;\n        } else {\n            end = mid - 1;\n        }\n    }\n    return ans;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/70", "prompt": "You are climbing a staircase. It takes `n` steps to reach the top.\n\nEach time you can either climb `1` or `2` steps. In how many distinct ways can you climb to the top?\n\n**Example 1:**\n\n**Input:** n = 2\n**Output:** 2\n**Explanation:** There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps\n\n**Example 2:**\n\n**Input:** n = 3\n**Output:** 3\n**Explanation:** There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n\n**Constraints:**\n\n*   `1 <= n <= 45`", "entry_point": "climbing_stairs", "canonical_solutions": {"python": "def climbStairs(n):\n    if n <= 2:\n        return n\n    a, b = 1, 2\n    for _ in range(3, n+1):\n        a, b = b, a + b\n    return b", "java": "public int climbStairs(int n) {\n    if(n <= 2) return n;\n    int a = 1, b = 2, c;\n    for(int i = 3; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return c;\n}", "cpp": "int climbStairs(int n) {\n    if(n <= 2) return n;\n    int a = 1, b = 2, c;\n    for(int i = 3; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return c;\n}", "javascript": "function climbStairs(n) {\n    if(n <= 2) return n;\n    let a = 1, b = 2, c;\n    for(let i = 3; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return c;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/71", "prompt": "Given a string `path`, which is an **absolute path** (starting with a slash `'/'`) to a file or directory in a Unix-style file system, convert it to the simplified **canonical path**.\n\nIn a Unix-style file system, a period `'.'` refers to the current directory, a double period `'..'` refers to the directory up a level, and any multiple consecutive slashes (i.e. `'//'`) are treated as a single slash `'/'`. For this problem, any other format of periods such as `'...'` are treated as file/directory names.\n\nThe **canonical path** should have the following format:\n\n*   The path starts with a single slash `'/'`.\n*   Any two directories are separated by a single slash `'/'`.\n*   The path does not end with a trailing `'/'`.\n*   The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period `'.'` or double period `'..'`)\n\nReturn _the simplified **canonical path**_.\n\n**Example 1:**\n\n**Input:** path =  \"/home/ \"\n**Output:**  \"/home \"\n**Explanation:** Note that there is no trailing slash after the last directory name.\n\n**Example 2:**\n\n**Input:** path =  \"/../ \"\n**Output:**  \"/ \"\n**Explanation:** Going one level up from the root directory is a no-op, as the root level is the highest level you can go.\n\n**Example 3:**\n\n**Input:** path =  \"/home//foo/ \"\n**Output:**  \"/home/foo \"\n**Explanation:** In the canonical path, multiple consecutive slashes are replaced by a single one.\n\n**Constraints:**\n\n*   `1 <= path.length <= 3000`\n*   `path` consists of English letters, digits, period `'.'`, slash `'/'` or `'_'`.\n*   `path` is a valid absolute Unix path.", "entry_point": "simplify_path", "canonical_solutions": {"python": "def simplifyPath(path: str) -> str:\n    stack = []\n    parts = path.split(\"/\")\n\n    for part in parts:\n        if not part or part == \".\":\n            continue\n        if part == \"..\":\n            if stack:\n                stack.pop()\n        else:\n            stack.append(part)\n\n    return \"/\" + \"/\".join(stack)", "java": "import java.util.LinkedList;\n\npublic String simplifyPath(String path) {\n    String[] parts = path.split(\"/\");\n    LinkedList<String> stack = new LinkedList<>();\n\n    for (String part : parts) {\n        if (part.isEmpty() || part.equals(\".\")) continue;\n        if (part.equals(\"..\")) {\n            if (!stack.isEmpty()) stack.removeLast();\n        } else {\n            stack.addLast(part);\n        }\n    }\n\n    StringBuilder canonicalPath = new StringBuilder();\n    for (String piece : stack) {\n        canonicalPath.append('/').append(piece);\n    }\n    return stack.isEmpty() ? \"/\" : canonicalPath.toString();\n}", "cpp": "#include <string>\n#include <vector>\n#include <sstream>\n\nstd::string simplifyPath(std::string path) {\n    std::vector<std::string> stack;\n    std::istringstream ss{path};\n    std::string part;\n\n    while (std::getline(ss, part, '/')) {\n        if (part.empty() || part == \".\") continue;\n        if (part == \"..\") {\n            if (!stack.empty()) stack.pop_back();\n        } else {\n            stack.push_back(part);\n        }\n    }\n\n    std::string canonicalPath;\n    for (const auto &piece : stack) {\n        canonicalPath += '/' + piece;\n    }\n    return stack.empty() ? \"/\" : canonicalPath;\n}", "javascript": "function simplifyPath(path) {\n    let stack = [];\n    let parts = path.split(\"/\");\n\n    for (let part of parts) {\n        if (!part || part === \".\") continue;\n        if (part === \"..\") {\n            if (stack.length) stack.pop();\n        } else {\n            stack.push(part);\n        }\n    }\n\n    return \"/\" + stack.join(\"/\");\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/72", "prompt": "Given two strings `word1` and `word2`, return _the minimum number of operations required to convert `word1` to `word2`_.\n\nYou have the following three operations permitted on a word:\n\n*   Insert a character\n*   Delete a character\n*   Replace a character\n\n**Example 1:**\n\n**Input:** word1 =  \"horse \", word2 =  \"ros \"\n**Output:** 3\n**Explanation:** \nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')\n\n**Example 2:**\n\n**Input:** word1 =  \"intention \", word2 =  \"execution \"\n**Output:** 5\n**Explanation:** \nintention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')\n\n**Constraints:**\n\n*   `0 <= word1.length, word2.length <= 500`\n*   `word1` and `word2` consist of lowercase English letters.", "entry_point": "edit_distance", "canonical_solutions": {"python": "def minDistance(word1: str, word2: str) -> int:\n    m, n = len(word1), len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0:\n                dp[i][j] = j\n            elif j == 0:\n                dp[i][j] = i\n            elif word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n    \n    return dp[m][n]", "java": "public int minDistance(String word1, String word2) {\n    int m = word1.length();\n    int n = word2.length();\n    int[][] dp = new int[m + 1][n + 1];\n    \n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (i == 0) {\n                dp[i][j] = j;\n            } else if (j == 0) {\n                dp[i][j] = i;\n            } else if (word1.charAt(i - 1) == word2.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n    \n    return dp[m][n];\n}", "cpp": "int minDistance(string word1, string word2) {\n    int m = word1.size();\n    int n = word2.size();\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n    \n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (i == 0) {\n                dp[i][j] = j;\n            } else if (j == 0) {\n                dp[i][j] = i;\n            } else if (word1[i - 1] == word2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n    \n    return dp[m][n];\n}", "javascript": "function minDistance(word1, word2) {\n    const m = word1.length;\n    const n = word2.length;\n    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));\n    \n    for (let i = 0; i <= m; i++) {\n        for (let j = 0; j <= n; j++) {\n            if (i === 0) {\n                dp[i][j] = j;\n            } else if (j === 0) {\n                dp[i][j] = i;\n            } else if (word1[i - 1] === word2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n    \n    return dp[m][n];\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/73", "prompt": "Given an `m x n` integer matrix `matrix`, if an element is `0`, set its entire row and column to `0`'s.\n\nYou must do it [in place](https://en.wikipedia.org/wiki/In-place_algorithm).\n\n**Example 1:**\n\n**Input:** matrix = \\[\\[1,1,1\\],\\[1,0,1\\],\\[1,1,1\\]\\]\n**Output:** \\[\\[1,0,1\\],\\[0,0,0\\],\\[1,0,1\\]\\]\n\n**Example 2:**\n\n**Input:** matrix = \\[\\[0,1,2,0\\],\\[3,4,5,2\\],\\[1,3,1,5\\]\\]\n**Output:** \\[\\[0,0,0,0\\],\\[0,4,5,0\\],\\[0,3,1,0\\]\\]\n\n**Constraints:**\n\n*   `m == matrix.length`\n*   `n == matrix[0].length`\n*   `1 <= m, n <= 200`\n*   `-231 <= matrix[i][j] <= 231 - 1`\n\n**Follow up:**\n\n*   A straightforward solution using `O(mn)` space is probably a bad idea.\n*   A simple improvement uses `O(m + n)` space, but still not the best solution.\n*   Could you devise a constant space solution?", "entry_point": "set_matrix_zeroes", "canonical_solutions": {"python": "def setZeroes(matrix):\n    rows = len(matrix)\n    cols = len(matrix[0])\n    firstRow, firstCol = False, False\n\n    for i in range(rows):\n        for j in range(cols):\n            if matrix[i][j] == 0:\n                if i == 0: firstRow = True\n                if j == 0: firstCol = True\n                matrix[i][0] = 0\n                matrix[0][j] = 0\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            if matrix[i][0] == 0 or matrix[0][j] == 0:\n                matrix[i][j] = 0\n\n    if firstRow:\n        for j in range(cols):\n            matrix[0][j] = 0\n\n    if firstCol:\n        for i in range(rows):\n            matrix[i][0] = 0", "java": "public void setZeroes(int[][] matrix) {\n    int rows = matrix.length;\n    int cols = matrix[0].length;\n    boolean firstRow = false, firstCol = false;\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (matrix[i][j] == 0) {\n                if (i == 0) firstRow = true;\n                if (j == 0) firstCol = true;\n                matrix[i][0] = 0;\n                matrix[0][j] = 0;\n            }\n        }\n    }\n\n    for (int i = 1; i < rows; i++) {\n        for (int j = 1; j < cols; j++) {\n            if (matrix[i][0] == 0 || matrix[0][j] == 0)\n                matrix[i][j] = 0;\n        }\n    }\n\n    if (firstRow) {\n        for (int j = 0; j < cols; j++)\n            matrix[0][j] = 0;\n    }\n\n    if (firstCol) {\n        for (int i = 0; i < rows; i++)\n            matrix[i][0] = 0;\n    }\n}", "cpp": "void setZeroes(vector<vector<int>>& matrix) {\n    int rows = matrix.size();\n    int cols = matrix[0].size();\n    bool firstRow = false, firstCol = false;\n    \n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (matrix[i][j] == 0) {\n                if (i == 0) firstRow = true;\n                if (j == 0) firstCol = true;\n                matrix[i][0] = 0;\n                matrix[0][j] = 0;\n            }\n        }\n    }\n\n    for (int i = 1; i < rows; i++) {\n        for (int j = 1; j < cols; j++) {\n            if (matrix[i][0] == 0 || matrix[0][j] == 0)\n                matrix[i][j] = 0;\n        }\n    }\n\n    if (firstRow) {\n        for (int j = 0; j < cols; j++)\n            matrix[0][j] = 0;\n    }\n\n    if (firstCol) {\n        for (int i = 0; i < rows; i++)\n            matrix[i][0] = 0;\n    }\n}", "javascript": "function setZeroes(matrix) {\n    let rows = matrix.length;\n    let cols = matrix[0].length;\n    let firstRow = false;\n    let firstCol = false;\n \n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            if (matrix[i][j] === 0) {\n                if (i === 0) firstRow = true;\n                if (j === 0) firstCol = true;\n                matrix[i][0] = 0;\n                matrix[0][j] = 0;\n            }\n        }\n    }\n    \n    for (let i = 1; i < rows; i++) {\n        for (let j = 1; j < cols; j++) {\n            if (matrix[i][0] === 0 || matrix[0][j] === 0) {\n                matrix[i][j] = 0;\n            }\n        }\n    }\n    \n    if (firstRow) {\n        for (let j = 0; j < cols; j++) \n            matrix[0][j] = 0;\n    }\n    \n    if (firstCol) {\n        for (let i = 0; i < rows; i++)\n            matrix[i][0] = 0;\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/74", "prompt": "You are given an `m x n` integer matrix `matrix` with the following two properties:\n\n*   Each row is sorted in non-decreasing order.\n*   The first integer of each row is greater than the last integer of the previous row.\n\nGiven an integer `target`, return `true` _if_ `target` _is in_ `matrix` _or_ `false` _otherwise_.\n\nYou must write a solution in `O(log(m * n))` time complexity.\n\n**Example 1:**\n\n**Input:** matrix = \\[\\[1,3,5,7\\],\\[10,11,16,20\\],\\[23,30,34,60\\]\\], target = 3\n**Output:** true\n\n**Example 2:**\n\n**Input:** matrix = \\[\\[1,3,5,7\\],\\[10,11,16,20\\],\\[23,30,34,60\\]\\], target = 13\n**Output:** false\n\n**Constraints:**\n\n*   `m == matrix.length`\n*   `n == matrix[i].length`\n*   `1 <= m, n <= 100`\n*   `-104 <= matrix[i][j], target <= 104`", "entry_point": "search_a_2d_matrix", "canonical_solutions": {"python": "def searchMatrix(matrix, target):\n    m, n = len(matrix), len(matrix[0])\n    l, r = 0, m * n - 1\n\n    while l <= r:\n        mid = l + (r - l) // 2\n        mid_val = matrix[mid // n][mid % n]\n\n        if mid_val == target:\n            return True\n        elif mid_val < target:\n            l = mid + 1\n        else:\n            r = mid - 1\n\n    return False", "java": "public boolean searchMatrix(int[][] matrix, int target) {\n    int m = matrix.length;\n    int n = matrix[0].length;\n    int l = 0, r = m * n - 1;\n\n    while (l <= r) {\n        int mid = l + (r - l) / 2;\n        int midVal = matrix[mid / n][mid % n];\n\n        if (midVal == target) {\n            return true;\n        } else if (midVal < target) {\n            l = mid + 1;\n        } else {\n            r = mid - 1;\n        }\n    }\n\n    return false;\n}", "cpp": "bool searchMatrix(vector<vector<int>>& matrix, int target) {\n    int m = matrix.size();\n    int n = matrix[0].size();\n    int l = 0, r = m * n - 1;\n    \n    while (l <= r) {\n        int mid = l + (r - l) / 2;\n        int midVal = matrix[mid / n][mid % n];\n        \n        if (midVal == target) {\n            return true;\n        } else if (midVal < target) {\n            l = mid + 1;\n        } else {\n            r = mid - 1;\n        }\n    }\n    \n    return false;\n}", "javascript": "function searchMatrix(matrix, target) {\n    const m = matrix.length;\n    const n = matrix[0].length;\n    let l = 0, r = m * n - 1;\n\n    while (l <= r) {\n        const mid = l+ Math.floor((r - l) / 2);\n        const midVal = matrix[Math.floor(mid / n)][mid % n];\n\n        if (midVal === target) {\n            return true;\n        } else if (midVal < target) {\n            l = mid + 1;\n        } else {\n            r = mid - 1;\n        }\n    }\n\n    return false;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/75", "prompt": "Given an array `nums` with `n` objects colored red, white, or blue, sort them **[in-place](https://en.wikipedia.org/wiki/In-place_algorithm)** so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\n\nWe will use the integers `0`, `1`, and `2` to represent the color red, white, and blue, respectively.\n\nYou must solve this problem without using the library's sort function.\n\n**Example 1:**\n\n**Input:** nums = \\[2,0,2,1,1,0\\]\n**Output:** \\[0,0,1,1,2,2\\]\n\n**Example 2:**\n\n**Input:** nums = \\[2,0,1\\]\n**Output:** \\[0,1,2\\]\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 300`\n*   `nums[i]` is either `0`, `1`, or `2`.\n\n**Follow up:** Could you come up with a one-pass algorithm using only constant extra space?", "entry_point": "sort_colors", "canonical_solutions": {"python": "def sortColors(nums: List[int]) -> None:\n    red, white, blue = 0, 0, len(nums) - 1\n    while white <= blue:\n        if nums[white] == 0:\n            nums[red], nums[white] = nums[white], nums[red]\n            red += 1\n            white += 1\n        elif nums[white] == 1:\n            white += 1\n        else:\n            nums[white], nums[blue] = nums[blue], nums[white]\n            blue -= 1", "java": "public void sortColors(int[] nums) {\n    int red = 0, white = 0, blue = nums.length - 1;\n    while (white <= blue) {\n        if (nums[white] == 0) {\n            int temp = nums[red];\n            nums[red++] = nums[white];\n            nums[white++] = temp;\n        } else if (nums[white] == 1) {\n            white++;\n        } else {\n            int temp = nums[white];\n            nums[white] = nums[blue];\n            nums[blue--] = temp;\n        }\n    }\n}", "cpp": "void sortColors(vector<int>& nums) {\n    int red = 0, white = 0, blue = nums.size() - 1;\n    while (white <= blue) {\n        if (nums[white] == 0) {\n            swap(nums[red++], nums[white++]);\n        } else if (nums[white] == 1) {\n            white++;\n        } else {\n            swap(nums[white], nums[blue--]);\n        }\n    }\n}", "javascript": "function sortColors(nums) {\n    let red = 0, white = 0, blue = nums.length - 1;\n    while (white <= blue) {\n        if (nums[white] === 0) {\n            [nums[red], nums[white]] = [nums[white], nums[red]];\n            red++;\n            white++;\n        } else if (nums[white] === 1) {\n            white++;\n        } else {\n            [nums[white], nums[blue]] = [nums[blue], nums[white]];\n            blue--;\n        }\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/76", "prompt": "Given two strings `s` and `t` of lengths `m` and `n` respectively, return _the **minimum window**_ **_substring_** _of_ `s` _such that every character in_ `t` _(**including duplicates**) is included in the window_. If there is no such substring, return _the empty string_ `\" \"`.\n\nThe testcases will be generated such that the answer is **unique**.\n\n**Example 1:**\n\n**Input:** s =  \"ADOBECODEBANC \", t =  \"ABC \"\n**Output:**  \"BANC \"\n**Explanation:** The minimum window substring  \"BANC \" includes 'A', 'B', and 'C' from string t.\n\n**Example 2:**\n\n**Input:** s =  \"a \", t =  \"a \"\n**Output:**  \"a \"\n**Explanation:** The entire string s is the minimum window.\n\n**Example 3:**\n\n**Input:** s =  \"a \", t =  \"aa \"\n**Output:**  \" \"\n**Explanation:** Both 'a's from t must be included in the window.\nSince the largest window of s only has one 'a', return empty string.\n\n**Constraints:**\n\n*   `m == s.length`\n*   `n == t.length`\n*   `1 <= m, n <= 105`\n*   `s` and `t` consist of uppercase and lowercase English letters.\n\n**Follow up:** Could you find an algorithm that runs in `O(m + n)` time?", "entry_point": "minimum_window_substring", "canonical_solutions": {"python": "from collections import Counter\n\ndef min_window(s, t):\n    need = Counter(t)\n    window = {}\n    \n    left = 0\n    right = 0\n    valid = 0\n    start = 0\n    length = float('inf')\n\n    while right < len(s):\n        c = s[right]\n        right += 1\n        if c in need:\n            window[c] = window.get(c, 0) + 1\n            if window[c] <= need[c]:\n                valid += 1\n\n        while valid == len(t):\n            if right - left < length:\n                start = left\n                length = right - left\n\n            d = s[left]\n            left += 1\n            if d in need:\n                if window[d] <= need[d]:\n                    valid -= 1\n                window[d] -= 1\n\n    return \"\" if length == float('inf') else s[start : start + length]", "java": "import java.util.HashMap;\n\npublic String minWindow(String s, String t) {\n    HashMap<Character, Integer> need = new HashMap<>();\n    HashMap<Character, Integer> window = new HashMap<>();\n    for (char c : t.toCharArray()) need.put(c, need.getOrDefault(c, 0) + 1);\n    \n    int left = 0, right = 0;\n    int valid = 0;\n    int start = 0, length = Integer.MAX_VALUE;\n\n    while (right < s.length()) {\n        char c = s.charAt(right);\n        right++;\n        if (need.containsKey(c)) {\n            window.put(c, window.getOrDefault(c, 0) + 1);\n            if (window.get(c) <= need.get(c)) valid++;\n        }\n\n        while (valid == t.length()) {\n            if (right - left < length) {\n                start = left;\n                length = right - left;\n            }\n\n            char d = s.charAt(left);\n            left++;\n            if (need.containsKey(d)) {\n                if (window.get(d) <= need.get(d)) valid--;\n                window.put(d, window.get(d) - 1);\n            }\n        }\n    }\n    return length == Integer.MAX_VALUE ? \"\" : s.substring(start, start + length);\n}", "cpp": "#include <string>\n#include <unordered_map>\n\nstd::string min_window(std::string s, std::string t) {\n    std::unordered_map<char, int> need, window;\n    for (char c : t) need[c]++;\n    \n    int left = 0, right = 0;\n    int valid = 0;\n    int start = 0, length = INT_MAX;\n\n    while (right < s.length()) {\n        char c = s[right];\n        right++;\n        if (need.count(c)) {\n            window[c]++;\n            if (window[c] <= need[c]) valid++;\n        }\n\n        while (valid == t.length()) {\n            if (right - left < length) {\n                start = left;\n                length = right - left;\n            }\n\n            char d = s[left];\n            left++;\n            if (need.count(d)) {\n                if (window[d] <= need[d]) valid--;\n                window[d]--;\n            }\n        }\n    }\n    return length == INT_MAX ? \"\" : s.substr(start, length);\n}", "javascript": "function minWindow(s, t) {\n    const need = new Map();\n    const window = new Map();\n\n    for (const c of t) {\n        need.set(c, (need.get(c) || 0) + 1);\n    }\n    \n    let left = 0, right = 0;\n    let valid = 0;\n    let start = 0, length = Infinity;\n\n    while (right < s.length) {\n        const c = s[right];\n        right++;\n        if (need.has(c)) {\n            window.set(c, (window.get(c) || 0) + 1);\n            if (window.get(c) <= need.get(c)) valid++;\n        }\n\n        while (valid === t.length) {\n            if (right - left < length) {\n                start = left;\n                length = right - left;\n            }\n\n            const d = s[left];\n            left++;\n            if (need.has(d)) {\n                if (window.get(d) <= need.get(d)) valid--;\n                window.set(d, window.get(d) - 1);\n            }\n        }\n    }\n    return length === Infinity ? \"\" : s.substring(start, start + length);\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/77", "prompt": "Given two integers `n` and `k`, return _all possible combinations of_ `k` _numbers chosen from the range_ `[1, n]`.\n\nYou may return the answer in **any order**.\n\n**Example 1:**\n\n**Input:** n = 4, k = 2\n**Output:** \\[\\[1,2\\],\\[1,3\\],\\[1,4\\],\\[2,3\\],\\[2,4\\],\\[3,4\\]\\]\n**Explanation:** There are 4 choose 2 = 6 total combinations.\nNote that combinations are unordered, i.e., \\[1,2\\] and \\[2,1\\] are considered to be the same combination.\n\n**Example 2:**\n\n**Input:** n = 1, k = 1\n**Output:** \\[\\[1\\]\\]\n**Explanation:** There is 1 choose 1 = 1 total combination.\n\n**Constraints:**\n\n*   `1 <= n <= 20`\n*   `1 <= k <= n`", "entry_point": "combinations", "canonical_solutions": {"python": "from typing import List\n\ndef combine(n: int, k: int) -> List[List[int]]:\n    def backtrack(start, current_combination):\n        if len(current_combination) == k:\n            result.append(current_combination[:])\n\n        for i in range(start, n + 1):\n            current_combination.append(i)\n            backtrack(i + 1, current_combination)\n            current_combination.pop()\n\n    result = []\n    backtrack(1, [])\n    return result", "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> combine(int n, int k) {\n    List<List<Integer>> result = new ArrayList<>();\n    backtrack(n, k, 1, new ArrayList<>(), result);\n    return result;\n}\n\nprivate void backtrack(int n, int k, int start, List<Integer> current, List<List<Integer>> result) {\n    if (current.size() == k) {\n        result.add(new ArrayList<>(current));\n        return;\n    }\n\n    for (int i = start; i <= n; i++) {\n        current.add(i);\n        backtrack(n, k, i + 1, current, result);\n        current.remove(current.size() - 1);\n    }\n}", "cpp": "#include <vector>\n\nvoid backtrack(int n, int k, int start, std::vector<int>& current, std::vector<std::vector<int>>& result) {\n    if (current.size() == k) {\n        result.push_back(current);\n        return;\n    }\n\n    for (int i = start; i <= n; ++i) {\n        current.push_back(i);\n        backtrack(n, k, i + 1, current, result);\n        current.pop_back();\n    }\n}\n\nstd::vector<std::vector<int>> combine(int n, int k) {\n    std::vector<std::vector<int>> result;\n    std::vector<int> current;\n    backtrack(n, k, 1, current, result);\n    return result;\n}", "javascript": "function combine(n, k) {\n    const result = [];\n    backtrack(n, k, 1, [], result);\n    return result;\n}\n\nfunction backtrack(n, k, start, current, result) {\n    if (current.length === k) {\n        result.push([...current]);\n        return;\n    }\n\n    for (let i = start; i <= n; i++) {\n        current.push(i);\n        backtrack(n, k, i + 1, current, result);\n        current.pop();\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/78", "prompt": "Given an integer array `nums` of **unique** elements, return _all possible_ _subsets_ _(the power set)_.\n\nThe solution set **must not** contain duplicate subsets. Return the solution in **any order**.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3\\]\n**Output:** \\[\\[\\],\\[1\\],\\[2\\],\\[1,2\\],\\[3\\],\\[1,3\\],\\[2,3\\],\\[1,2,3\\]\\]\n\n**Example 2:**\n\n**Input:** nums = \\[0\\]\n**Output:** \\[\\[\\],\\[0\\]\\]\n\n**Constraints:**\n\n*   `1 <= nums.length <= 10`\n*   `-10 <= nums[i] <= 10`\n*   All the numbers of `nums` are **unique**.", "entry_point": "subsets", "canonical_solutions": {"python": "def subsets(nums):\n    n = len(nums)\n    num_subsets = 1 << n\n    result = []\n\n    for i in range(num_subsets):\n        subset = []\n        for j in range(n):\n            if i & (1 << j):\n                subset.append(nums[j])\n        result.append(subset)\n    return result", "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> subsets(int[] nums) {\n    List<List<Integer>> result = new ArrayList<>();\n    int n = nums.length;\n    int num_subsets = 1 << n;\n\n    for (int i = 0; i < num_subsets; ++i) {\n        List<Integer> subset = new ArrayList<>();\n        for (int j = 0; j < n; ++j) {\n            if ((i & (1 << j)) != 0) {\n                subset.add(nums[j]);\n            }\n        }\n        result.add(subset);\n    }\n    return result;\n}", "cpp": "#include <vector>\n\nstd::vector<std::vector<int>> subsets(std::vector<int>& nums) {\n    std::vector<std::vector<int>> result;\n    int n = nums.size();\n    int num_subsets = 1 << n;\n\n    for (int i = 0; i < num_subsets; ++i) {\n        std::vector<int> subset;\n        for (int j = 0; j < n; ++j) {\n            if (i & (1 << j)) {\n                subset.push_back(nums[j]);\n            }\n        }\n        result.push_back(subset);\n    }\n    return result;\n}", "javascript": "function subsets(nums) {\n    let result = [];\n    let n = nums.length;\n    let num_subsets = 1 << n;\n\n    for (let i = 0; i < num_subsets; ++i) {\n        let subset = [];\n        for (let j = 0; j < n; ++j) {\n            if (i & (1 << j)) {\n                subset.push(nums[j]);\n            }\n        }\n        result.push(subset);\n    }\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/79", "prompt": "Given an `m x n` grid of characters `board` and a string `word`, return `true` _if_ `word` _exists in the grid_.\n\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\n\n**Example 1:**\n\n**Input:** board = \\[\\[ \"A \", \"B \", \"C \", \"E \"\\],\\[ \"S \", \"F \", \"C \", \"S \"\\],\\[ \"A \", \"D \", \"E \", \"E \"\\]\\], word =  \"ABCCED \"\n**Output:** true\n\n**Example 2:**\n\n**Input:** board = \\[\\[ \"A \", \"B \", \"C \", \"E \"\\],\\[ \"S \", \"F \", \"C \", \"S \"\\],\\[ \"A \", \"D \", \"E \", \"E \"\\]\\], word =  \"SEE \"\n**Output:** true\n\n**Example 3:**\n\n**Input:** board = \\[\\[ \"A \", \"B \", \"C \", \"E \"\\],\\[ \"S \", \"F \", \"C \", \"S \"\\],\\[ \"A \", \"D \", \"E \", \"E \"\\]\\], word =  \"ABCB \"\n**Output:** false\n\n**Constraints:**\n\n*   `m == board.length`\n*   `n = board[i].length`\n*   `1 <= m, n <= 6`\n*   `1 <= word.length <= 15`\n*   `board` and `word` consists of only lowercase and uppercase English letters.\n\n**Follow up:** Could you use search pruning to make your solution faster with a larger `board`?", "entry_point": "word_search", "canonical_solutions": {"python": "def exist(board, word):\n    m, n = len(board), len(board[0])\n\n    def dfs(i, j, k):\n        if not 0 <= i < m or not 0 <= j < n or board[i][j] != word[k]:\n            return False\n        if k == len(word) - 1:\n            return True\n\n        tmp, board[i][j] = board[i][j], '/'\n        res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)\n        board[i][j] = tmp\n        return res\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, 0):\n                return True\n    return False", "java": "public boolean exist(char[][] board, String word) {\n    int m = board.length;\n    int n = board[0].length;\n\n    boolean[][] visited = new boolean[m][n];\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (dfs(board, i, j, 0, word, visited)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nprivate boolean dfs(char[][] board, int i, int j, int k, String word, boolean[][] visited) {\n    if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] != word.charAt(k) || visited[i][j]) {\n        return false;\n    }\n\n    if (k == word.length() - 1) {\n        return true;\n    }\n\n    visited[i][j] = true;\n    boolean result = dfs(board, i + 1, j, k + 1, word, visited)\n            || dfs(board, i - 1, j, k + 1, word, visited)\n            || dfs(board, i, j + 1, k + 1, word, visited)\n            || dfs(board, i, j - 1, k + 1, word, visited);\n    visited[i][j] = false;\n\n    return result;\n}", "cpp": "bool exist(vector<vector<char>>& board, string word) {\n    int m = board.size();\n    int n = board[0].size();\n    \n    function<bool(int, int, int)> dfs = [&](int i, int j, int k) {\n        if (i < 0 || i >= m || j < 0 || j >= n || board[i][j] != word[k])\n            return false;\n        if (k == word.length() - 1)\n            return true;\n        \n        char temp = board[i][j];\n        board[i][j] = '/';\n        bool res = dfs(i + 1, j, k + 1) || dfs(i - 1, j, k + 1) || dfs(i, j + 1, k + 1) || dfs(i, j - 1, k + 1);\n        board[i][j] = temp;\n        return res;\n    };\n    \n    for (int i = 0; i < m; i++)\n        for (int j = 0; j < n; j++)\n            if (dfs(i, j, 0))\n                return true;\n    return false;\n}", "javascript": "function exist(board, word) {\n    const m = board.length;\n    const n = board[0].length;\n\n    function dfs(i, j, k) {\n        if (i < 0 || i === m || j < 0 || j === n || board[i][j] !== word[k])\n            return false;\n        if (k === word.length - 1)\n            return true;\n        \n        const temp = board[i][j];\n        board[i][j] = '/';\n        const res = dfs(i + 1, j, k +1) || dfs(i - 1, j, k + 1) || dfs(i, j + 1, k + 1) || dfs(i, j - 1, k + 1);\n        board[i][j] = temp;\n        return res;\n    }\n\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (dfs(i, j, 0))\n                return true;\n        }\n    }\n    return false;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/80", "prompt": "Given an integer array `nums` sorted in **non-decreasing order**, remove some duplicates [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm) such that each unique element appears **at most twice**. The **relative order** of the elements should be kept the **same**.\n\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the **first part** of the array `nums`. More formally, if there are `k` elements after removing the duplicates, then the first `k` elements of `nums` should hold the final result. It does not matter what you leave beyond the first `k` elements.\n\nReturn `k` _after placing the final result in the first_ `k` _slots of_ `nums`.\n\nDo **not** allocate extra space for another array. You must do this by **modifying the input array [in-place](https://en.wikipedia.org/wiki/In-place_algorithm)** with O(1) extra memory.\n\n**Custom Judge:**\n\nThe judge will test your solution with the following code:\n\nint\\[\\] nums = \\[...\\]; // Input array\nint\\[\\] expectedNums = \\[...\\]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums\\[i\\] == expectedNums\\[i\\];\n}\n\nIf all assertions pass, then your solution will be **accepted**.\n\n**Example 1:**\n\n**Input:** nums = \\[1,1,1,2,2,3\\]\n**Output:** 5, nums = \\[1,1,2,2,3,\\_\\]\n**Explanation:** Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n**Example 2:**\n\n**Input:** nums = \\[0,0,1,1,1,1,2,3,3\\]\n**Output:** 7, nums = \\[0,0,1,1,2,3,3,\\_,\\_\\]\n**Explanation:** Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n**Constraints:**\n\n*   `1 <= nums.length <= 3 * 104`\n*   `-104 <= nums[i] <= 104`\n*   `nums` is sorted in **non-decreasing** order.", "entry_point": "remove_duplicates_from_sorted_array_ii", "canonical_solutions": {"python": "def remove_duplicates(nums):\n    i = 0\n    for num in nums:\n        if i < 2 or num > nums[i - 2]:\n            nums[i] = num\n            i += 1\n    return i", "java": "public int removeDuplicates(int[] nums) {\n    int i = 0;\n    for (int num : nums) {\n        if (i < 2 || num > nums[i - 2]) {\n            nums[i++] = num;\n        }\n    }\n    return i;\n}", "cpp": "int removeDuplicates(vector<int>& nums) {\n    int i = 0;\n    for (int num : nums) {\n        if (i < 2 || num > nums[i - 2]) {\n            nums[i++] = num;\n        }\n    }\n    return i;\n}", "javascript": "function removeDuplicates(nums) {\n    let i = 0;\n    for (let num of nums) {\n        if (i < 2 || num > nums[i - 2]) {\n            nums[i++] = num;\n        }\n    }\n    return i;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/81", "prompt": "There is an integer array `nums` sorted in non-decreasing order (not necessarily with **distinct** values).\n\nBefore being passed to your function, `nums` is **rotated** at an unknown pivot index `k` (`0 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (**0-indexed**). For example, `[0,1,2,4,4,4,5,6,6,7]` might be rotated at pivot index `5` and become `[4,5,6,6,7,0,1,2,4,4]`.\n\nGiven the array `nums` **after** the rotation and an integer `target`, return `true` _if_ `target` _is in_ `nums`_, or_ `false` _if it is not in_ `nums`_._\n\nYou must decrease the overall operation steps as much as possible.\n\n**Example 1:**\n\n**Input:** nums = \\[2,5,6,0,0,1,2\\], target = 0\n**Output:** true\n\n**Example 2:**\n\n**Input:** nums = \\[2,5,6,0,0,1,2\\], target = 3\n**Output:** false\n\n**Constraints:**\n\n*   `1 <= nums.length <= 5000`\n*   `-104 <= nums[i] <= 104`\n*   `nums` is guaranteed to be rotated at some pivot.\n*   `-104 <= target <= 104`\n\n**Follow up:** This problem is similar to Search in Rotated Sorted Array, but `nums` may contain **duplicates**. Would this affect the runtime complexity? How and why?", "entry_point": "search_in_rotated_sorted_array_ii", "canonical_solutions": {"python": "def search(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            return True\n\n        if nums[mid] == nums[left]:\n            left += 1\n        elif nums[mid] > nums[left]:\n            if nums[left] <= target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if nums[mid] < target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    return False", "java": "public boolean search(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) return true;\n\n        if (nums[mid] == nums[left]) {\n            left++;\n        } else if (nums[mid] > nums[left]) {\n            if (nums[left] <= target && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else {\n            if (nums[mid] < target && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    return false;\n}", "cpp": "bool search(vector<int>& nums, int target) {\n    int left = 0, right = nums.size() - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) return true;\n\n        if (nums[mid] == nums[left]) {\n            left++;\n        } else if (nums[mid] > nums[left]) {\n            if (nums[left] <= target && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else {\n            if (nums[mid] < target && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    return false;\n}", "javascript": "function search(nums, target) {\n    let left = 0, right = nums.length - 1;\n    while (left <= right) {\n        const mid = left + Math.floor((right - left) / 2);\n        if (nums[mid] === target) return true;\n\n        if (nums[mid] === nums[left]) {\n            left++;\n        } else if (nums[mid] > nums[left]) {\n            if (nums[left] <= target && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else {\n            if (nums[mid] < target && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    return false;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/82", "prompt": "Given the `head` of a sorted linked list, _delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list_. Return _the linked list **sorted** as well_.\n\n**Example 1:**\n\n**Input:** head = \\[1,2,3,3,4,4,5\\]\n**Output:** \\[1,2,5\\]\n\n**Example 2:**\n\n**Input:** head = \\[1,1,1,2,3\\]\n**Output:** \\[2,3\\]\n\n**Constraints:**\n\n*   The number of nodes in the list is in the range `[0, 300]`.\n*   `-100 <= Node.val <= 100`\n*   The list is guaranteed to be **sorted** in ascending order.", "entry_point": "remove_duplicates_from_sorted_list_ii", "canonical_solutions": {"python": "class ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\ndef deleteDuplicates(head):\n    dummy = ListNode(0)\n    dummy.next = head\n    prev, curr = dummy, head\n    while curr:\n        while curr.next and curr.val == curr.next.val:\n            curr = curr.next\n        if prev.next == curr:\n            prev = prev.next\n        else:\n            prev.next = curr.next\n        curr = curr.next\n    return dummy.next", "java": "class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) { val = x; }\n}\n\npublic ListNode deleteDuplicates(ListNode head) {\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    ListNode prev = dummy, curr = head;\n    while (curr != null) {\n        while (curr.next != null && curr.val == curr.next.val)\n            curr = curr.next;\n        if (prev.next == curr)\n            prev = prev.next;\n        else\n            prev.next = curr.next;\n        curr = curr.next;\n    }\n    return dummy.next;\n}", "cpp": "class ListNode {\npublic:\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(nullptr) {}\n};\n\nListNode* deleteDuplicates(ListNode* head) {\n    ListNode dummy(0);\n    dummy.next = head;\n    ListNode *prev = &dummy, *curr = head;\n    while (curr) {\n        while (curr->next && curr->val == curr->next->val)\n            curr = curr->next;\n        if (prev->next == curr)\n            prev = prev->next;\n        else\n            prev->next = curr->next;\n        curr = curr->next;\n    }\n    return dummy.next;\n}", "javascript": "class ListNode {\n    constructor(val=0, next=null) {\n        this.val = val;\n        this.next = next;\n    }\n}\n\nfunction deleteDuplicates(head) {\n    const dummy = new ListNode(0);\n    dummy.next = head;\n    let prev = dummy, curr = head;\n    while (curr) {\n        while (curr.next && curr.val === curr.next.val) {\n            curr = curr.next;\n        }\n        if (prev.next === curr) {\n            prev = prev.next;\n        } else {\n            prev.next = curr.next;\n        }\n        curr = curr.next;\n    }\n    return dummy.next;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/83", "prompt": "Given the `head` of a sorted linked list, _delete all duplicates such that each element appears only once_. Return _the linked list **sorted** as well_.\n\n**Example 1:**\n\n**Input:** head = \\[1,1,2\\]\n**Output:** \\[1,2\\]\n\n**Example 2:**\n\n**Input:** head = \\[1,1,2,3,3\\]\n**Output:** \\[1,2,3\\]\n\n**Constraints:**\n\n*   The number of nodes in the list is in the range `[0, 300]`.\n*   `-100 <= Node.val <= 100`\n*   The list is guaranteed to be **sorted** in ascending order.", "entry_point": "remove_duplicates_from_sorted_list", "canonical_solutions": {"python": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef delete_duplicates(head):\n    current = head\n    while current and current.next:\n        if current.next.val == current.val:\n            current.next = current.next.next\n        else:\n            current = current.next\n    return head", "java": "public class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) { val = x; }\n}\n\npublic ListNode deleteDuplicates(ListNode head) {\n    ListNode current = head;\n    while (current != null && current.next != null) {\n        if (current.next.val == current.val) {\n            current.next = current.next.next;\n        } else {\n            current = current.next;\n        }\n    }\n    return head;\n}", "cpp": "struct ListNode {\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(nullptr) {}\n};\n\nListNode* deleteDuplicates(ListNode* head) {\n    ListNode* current = head;\n    while (current && current->next) {\n        if (current->next->val == current->val) {\n            ListNode* temp = current->next;\n            current->next = temp->next;\n            delete temp;\n        } else {\n            current = current->next;\n        }\n    }\n    return head;\n}", "javascript": "class ListNode {\n    constructor(val, next = null) {\n        this.val = val;\n        this.next = next;\n    }\n}\n\nfunction deleteDuplicates(head) {\n    let current = head;\n    while (current && current.next) {\n        if (current.next.val === current.val) {\n            current.next = current.next.next;\n        } else {\n            current = current.next;\n        }\n    }\n    return head;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/84", "prompt": "Given an array of integers `heights` representing the histogram's bar height where the width of each bar is `1`, return _the area of the largest rectangle in the histogram_.\n\n**Example 1:**\n\n**Input:** heights = \\[2,1,5,6,2,3\\]\n**Output:** 10\n**Explanation:** The above is a histogram where width of each bar is 1.\nThe largest rectangle is shown in the red area, which has an area = 10 units.\n\n**Example 2:**\n\n**Input:** heights = \\[2,4\\]\n**Output:** 4\n\n**Constraints:**\n\n*   `1 <= heights.length <= 105`\n*   `0 <= heights[i] <= 104`", "entry_point": "largest_rectangle_in_histogram", "canonical_solutions": {"python": "def largestRectangleArea(heights):\n    stack = []\n    max_area = 0\n    for i, h in enumerate(heights + [0]):\n        while stack and heights[stack[-1]] > h:\n            height = heights[stack.pop()]\n            width = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, height * width)\n        stack.append(i)\n    return max_area", "java": "public int largestRectangleArea(int[] heights) {\n    Stack<Integer> stack = new Stack<>();\n    int max_area = 0;\n    for (int i = 0; i <= heights.length; i++) {\n        int height = (i == heights.length) ? 0 : heights[i];\n        while (!stack.isEmpty() && heights[stack.peek()] > height) {\n            int h = heights[stack.pop()];\n            int w = stack.isEmpty() ? i : i - stack.peek() - 1;\n            max_area = Math.max(max_area, h * w);\n        }\n        stack.push(i);\n    }\n    return max_area;\n}", "cpp": "int largestRectangleArea(vector<int>& heights) {\n    heights.push_back(0);\n    stack<int> s;\n    int max_area = 0;\n    for (int i = 0; i < heights.size(); i++) {\n        while (!s.empty() && heights[s.top()] > heights[i]) {\n            int height = heights[s.top()];\n            s.pop();\n            int width = s.empty() ? i : i - s.top() - 1;\n            max_area = max(max_area, height * width);\n        }\n        s.push(i);\n    }\n    return max_area;\n}", "javascript": "function largestRectangleArea(heights) {\n    let stack = [];\n    let max_area = 0;\n    heights.push(0);\n    for (let i = 0; i < heights.length; i++) {\n        while (stack.length > 0 && heights[stack[stack.length - 1]] > heights[i]) {\n            let height = heights[stack.pop()];\n            let width = stack.length === 0 ? i : i - stack[stack.length - 1] - 1;\n            max_area = Math.max(max_area, height * width);\n        }\n        stack.push(i);\n    }\n    return max_area;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/85", "prompt": "Given a `rows x cols` binary `matrix` filled with `0`'s and `1`'s, find the largest rectangle containing only `1`'s and return _its area_.\n\n**Example 1:**\n\n**Input:** matrix = \\[\\[ \"1 \", \"0 \", \"1 \", \"0 \", \"0 \"\\],\\[ \"1 \", \"0 \", \"1 \", \"1 \", \"1 \"\\],\\[ \"1 \", \"1 \", \"1 \", \"1 \", \"1 \"\\],\\[ \"1 \", \"0 \", \"0 \", \"1 \", \"0 \"\\]\\]\n**Output:** 6\n**Explanation:** The maximal rectangle is shown in the above picture.\n\n**Example 2:**\n\n**Input:** matrix = \\[\\[ \"0 \"\\]\\]\n**Output:** 0\n\n**Example 3:**\n\n**Input:** matrix = \\[\\[ \"1 \"\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `rows == matrix.length`\n*   `cols == matrix[i].length`\n*   `1 <= row, cols <= 200`\n*   `matrix[i][j]` is `'0'` or `'1'`.", "entry_point": "maximal_rectangle", "canonical_solutions": {"python": "def maximalRectangle(matrix):\n    if not matrix:\n        return 0\n\n    m = len(matrix)\n    n = len(matrix[0])\n    height = [0] * (n + 1)\n    max_area = 0\n\n    for i in range(m):\n        s = []\n        for j in range(n + 1):\n            if j < n:\n                height[j] = height[j] + 1 if matrix[i][j] == '1' else 0\n            while s and height[j] < height[s[-1]]:\n                h = height[s.pop()]\n                w = j if not s else j - s[-1] - 1\n                max_area = max(max_area, h * w)\n            s.append(j)\n\n    return max_area", "java": "import java.util.Stack;\n\npublic int maximalRectangle(char[][] matrix) {\n    if (matrix.length == 0) return 0;\n\n    int m = matrix.length;\n    int n = matrix[0].length;\n    int[] height = new int[n + 1];\n    int maxArea = 0;\n\n    for (int i = 0; i < m; ++i) {\n        Stack<Integer> s = new Stack<>();\n        for (int j = 0; j <= n; ++j) {\n            if (j < n) {\n                height[j] = matrix[i][j] == '1' ? height[j] + 1 : 0;\n            }\n            while (!s.empty() && height[j] < height[s.peek()]) {\n                int h = height[s.pop()];\n                int w = s.empty() ? j : j - s.peek() - 1;\n                maxArea = Math.max(maxArea, h * w);\n            }\n            s.push(j);\n        }\n    }\n\n    return maxArea;\n}", "cpp": "#include <vector>\n#include <stack>\nusing namespace std;\n\nint maximalRectangle(vector<vector<char>>& matrix) {\n    if (matrix.empty()) return 0;\n\n    int m = matrix.size();\n    int n = matrix[0].size();\n    vector<int> height(n + 1, 0);\n    int maxArea = 0;\n\n    for (int i = 0; i < m; ++i) {\n        stack<int> s;\n        for (int j = 0; j <= n; ++j) {\n            if (j < n) {\n                height[j] = matrix[i][j] == '1' ? height[j] + 1 : 0;\n            }\n            while (!s.empty() && height[j] < height[s.top()]) {\n                int h = height[s.top()];\n                s.pop();\n                int w = s.empty() ? j : j - s.top() - 1;\n                maxArea = max(maxArea, h * w);\n            }\n            s.push(j);\n        }\n    }\n\n    return maxArea;\n}", "javascript": "function maximalRectangle(matrix) {\n    if (!matrix.length) return 0;\n\n    let m = matrix.length;\n    let n = matrix[0].length;\n    let height = Array(n + 1).fill(0);\n    let maxArea = 0;\n\n    for (let i = 0; i < m; i++) {\n        let s = [];\n        for (let j = 0; j <= n; j++) {\n            if (j < n) {\n                height[j] = matrix[i][j] === '1' ? height[j] + 1 : 0;\n            }\n            while (s.length && height[j] < height[s[s.length - 1]]) {\n                let h = height[s.pop()];\n                let w = !s.length ? j : j - s[s.length - 1] - 1;\n                maxArea = Math.max(maxArea, h * w);\n            }\n            s.push(j);\n        }\n    }\n\n    return maxArea;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/86", "prompt": "Given the `head` of a linked list and a value `x`, partition it such that all nodes **less than** `x` come before nodes **greater than or equal** to `x`.\n\nYou should **preserve** the original relative order of the nodes in each of the two partitions.\n\n**Example 1:**\n\n**Input:** head = \\[1,4,3,2,5,2\\], x = 3\n**Output:** \\[1,2,2,4,3,5\\]\n\n**Example 2:**\n\n**Input:** head = \\[2,1\\], x = 2\n**Output:** \\[1,2\\]\n\n**Constraints:**\n\n*   The number of nodes in the list is in the range `[0, 200]`.\n*   `-100 <= Node.val <= 100`\n*   `-200 <= x <= 200`", "entry_point": "partition_list", "canonical_solutions": {"python": "class ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\ndef partition(head, x):\n    less_head = ListNode(0)\n    more_head = ListNode(0)\n    less_ptr, more_ptr = less_head, more_head\n    \n    while head:\n        if head.val < x:\n            less_ptr.next = head\n            less_ptr = head\n        else:\n            more_ptr.next = head\n            more_ptr = head\n        head = head.next\n    \n    less_ptr.next = more_head.next\n    more_ptr.next = None\n    \n    return less_head.next", "java": "public class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) {\n        val = x;\n        next = null;\n    }\n}\n\npublic ListNode partition(ListNode head, int x) {\n    ListNode less_head = new ListNode(0);\n    ListNode more_head = new ListNode(0);\n    ListNode less_ptr = less_head, more_ptr = more_head;\n    \n    while (head != null) {\n        if (head.val < x) {\n            less_ptr.next = head;\n            less_ptr = head;\n        } else {\n            more_ptr.next = head;\n            more_ptr = head;\n        }\n        head = head.next;\n    }\n    \n    less_ptr.next = more_head.next;\n    more_ptr.next = null;\n    \n    return less_head.next;\n}", "cpp": "class ListNode {\npublic:\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nListNode* partition(ListNode* head, int x) {\n    ListNode less_head(0), more_head(0);\n    ListNode *less_ptr = &less_head, *more_ptr = &more_head;\n    \n    while (head) {\n        if (head->val < x) {\n            less_ptr->next = head;\n            less_ptr = head;\n        } else {\n            more_ptr->next = head;\n            more_ptr = head;\n        }\n        head = head->next;\n    }\n    \n    less_ptr->next = more_head.next;\n    more_ptr->next = NULL;\n    \n    return less_head.next;\n}", "javascript": "class ListNode {\n    constructor(x) {\n        this.val = x;\n        this.next = null;\n    }\n}\n\nfunction partition(head, x) {\n    let less_head = new ListNode(0);\n    let more_head = new ListNode(0);\n    let less_ptr = less_head, more_ptr = more_head;\n    \n    while (head !== null) {\n        if (head.val < x) {\n            less_ptr.next = head;\n            less_ptr = head;\n        } else {\n            more_ptr.next = head;\n            more_ptr = head;\n        }\n        head = head.next;\n    }\n    \n    less_ptr.next = more_head.next;\n    more_ptr.next = null;\n    \n    return less_head.next;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/87", "prompt": "We can scramble a string s to get a string t using the following algorithm:\n\n1.  If the length of the string is 1, stop.\n2.  If the length of the string is > 1, do the following:\n    *   Split the string into two non-empty substrings at a random index, i.e., if the string is `s`, divide it to `x` and `y` where `s = x + y`.\n    *   **Randomly** decide to swap the two substrings or to keep them in the same order. i.e., after this step, `s` may become `s = x + y` or `s = y + x`.\n    *   Apply step 1 recursively on each of the two substrings `x` and `y`.\n\nGiven two strings `s1` and `s2` of **the same length**, return `true` if `s2` is a scrambled string of `s1`, otherwise, return `false`.\n\n**Example 1:**\n\n**Input:** s1 =  \"great \", s2 =  \"rgeat \"\n**Output:** true\n**Explanation:** One possible scenario applied on s1 is:\n \"great \" -->  \"gr/eat \" // divide at random index.\n \"gr/eat \" -->  \"gr/eat \" // random decision is not to swap the two substrings and keep them in order.\n \"gr/eat \" -->  \"g/r / e/at \" // apply the same algorithm recursively on both substrings. divide at random index each of them.\n \"g/r / e/at \" -->  \"r/g / e/at \" // random decision was to swap the first substring and to keep the second substring in the same order.\n \"r/g / e/at \" -->  \"r/g / e/ a/t \" // again apply the algorithm recursively, divide  \"at \" to  \"a/t \".\n \"r/g / e/ a/t \" -->  \"r/g / e/ a/t \" // random decision is to keep both substrings in the same order.\nThe algorithm stops now, and the result string is  \"rgeat \" which is s2.\nAs one possible scenario led s1 to be scrambled to s2, we return true.\n\n**Example 2:**\n\n**Input:** s1 =  \"abcde \", s2 =  \"caebd \"\n**Output:** false\n\n**Example 3:**\n\n**Input:** s1 =  \"a \", s2 =  \"a \"\n**Output:** true\n\n**Constraints:**\n\n*   `s1.length == s2.length`\n*   `1 <= s1.length <= 30`\n*   `s1` and `s2` consist of lowercase English letters.", "entry_point": "scramble_string", "canonical_solutions": {"python": "def isScramble(s1: str, s2: str) -> bool:\n    if s1 == s2:\n        return True\n    if len(s1) != len(s2) or sorted(s1) != sorted(s2):\n        return False\n\n    for i in range(1, len(s1)):\n        if (isScramble(s1[:i], s2[:i]) and isScramble(s1[i:], s2[i:])) or \\\n           (isScramble(s1[:i], s2[-i:]) and isScramble(s1[i:], s2[:-i])):\n            return True\n    return False", "java": "public boolean isScramble(String s1, String s2) {\n    if (s1.equals(s2)) return true;\n    if (sorted(s1).equals(sorted(s2)) == false) return false;\n\n    for (int i = 1; i < s1.length(); i++) {\n        if (isScramble(s1.substring(0, i), s2.substring(0, i)) && isScramble(s1.substring(i), s2.substring(i)))\n            return true;\n        if (isScramble(s1.substring(0, i), s2.substring(s2.length() - i)) && isScramble(s1.substring(i), s2.substring(0, s2.length() - i)))\n            return true;\n    }\n    return false;\n}\n\nprivate String sorted(String s) {\n    char[] chars = s.toCharArray();\n    Arrays.sort(chars);\n    return new String(chars);\n}", "cpp": "bool isScramble(string s1, string s2) {\n    if (s1 == s2) return true;\n    if (s1.size() != s2.size() || sort(s1.begin(), s1.end()) != sort(s2.begin(), s2.end())) return false;\n\n    for (int i = 1; i < s1.size(); i++) {\n        if (isScramble(s1.substr(0, i), s2.substr(0, i)) && isScramble(s1.substr(i), s2.substr(i)))\n            return true;\n        if (isScramble(s1.substr(0, i), s2.substr(s2.size() - i)) && isScramble(s1.substr(i), s2.substr(0, s2.size() - i)))\n            return true;\n    }\n    return false;\n}", "javascript": "function isScramble(s1, s2) {\n    if (s1 === s2) return true;\n    if (s1.length !== s2.length || sorted(s1) !== sorted(s2)) return false;\n\n    for (let i = 1; i < s1.length; i++) {\n        if ((isScramble(s1.slice(0, i), s2.slice(0, i)) && isScramble(s1.slice(i), s2.slice(i))) || \n            (isScramble(s1.slice(0, i), s2.slice(s2.length - i)) && isScramble(s1.slice(i), s2.slice(0, s2.length - i))))\n            return true;\n    }\n    return false;\n}\n\nfunction sorted(s) {\n    return s.split('').sort().join('');\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/88", "prompt": "You are given two integer arrays `nums1` and `nums2`, sorted in **non-decreasing order**, and two integers `m` and `n`, representing the number of elements in `nums1` and `nums2` respectively.\n\n**Merge** `nums1` and `nums2` into a single array sorted in **non-decreasing order**.\n\nThe final sorted array should not be returned by the function, but instead be _stored inside the array_ `nums1`. To accommodate this, `nums1` has a length of `m + n`, where the first `m` elements denote the elements that should be merged, and the last `n` elements are set to `0` and should be ignored. `nums2` has a length of `n`.\n\n**Example 1:**\n\n**Input:** nums1 = \\[1,2,3,0,0,0\\], m = 3, nums2 = \\[2,5,6\\], n = 3\n**Output:** \\[1,2,2,3,5,6\\]\n**Explanation:** The arrays we are merging are \\[1,2,3\\] and \\[2,5,6\\].\nThe result of the merge is \\[1,2,2,3,5,6\\] with the underlined elements coming from nums1.\n\n**Example 2:**\n\n**Input:** nums1 = \\[1\\], m = 1, nums2 = \\[\\], n = 0\n**Output:** \\[1\\]\n**Explanation:** The arrays we are merging are \\[1\\] and \\[\\].\nThe result of the merge is \\[1\\].\n\n**Example 3:**\n\n**Input:** nums1 = \\[0\\], m = 0, nums2 = \\[1\\], n = 1\n**Output:** \\[1\\]\n**Explanation:** The arrays we are merging are \\[\\] and \\[1\\].\nThe result of the merge is \\[1\\].\nNote that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.\n\n**Constraints:**\n\n*   `nums1.length == m + n`\n*   `nums2.length == n`\n*   `0 <= m, n <= 200`\n*   `1 <= m + n <= 200`\n*   `-109 <= nums1[i], nums2[j] <= 109`\n\n**Follow up:** Can you come up with an algorithm that runs in `O(m + n)` time?", "entry_point": "merge_sorted_array", "canonical_solutions": {"python": "def merge(nums1, m, nums2, n):\n    i, j, k = m - 1, n - 1, m + n - 1\n    while i >= 0 and j >= 0:\n        if nums1[i] > nums2[j]:\n            nums1[k] = nums1[i]\n            i -= 1\n        else:\n            nums1[k] = nums2[j]\n            j -= 1\n        k -= 1\n    while j >= 0:\n        nums1[k] = nums2[j]\n        k -= 1\n        j -= 1", "java": "public void merge(int[] nums1, int m, int[] nums2, int n) {\n    int i = m - 1, j = n - 1, k = m + n - 1;\n    while (i >= 0 && j >= 0) {\n        if (nums1[i] > nums2[j])\n            nums1[k--] = nums1[i--];\n        else\n            nums1[k--] = nums2[j--];\n    }\n    while (j >= 0) {\n        nums1[k--] = nums2[j--];\n    }\n}", "cpp": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n    int i = m - 1, j = n - 1, k = m + n - 1;\n    while (i >= 0 && j >= 0) {\n        if (nums1[i] > nums2[j])\n            nums1[k--] = nums1[i--];\n        else\n            nums1[k--] = nums2[j--];\n    }\n    while (j >= 0) {\n        nums1[k--] = nums2[j--];\n    }\n}", "javascript": "function merge(nums1, m, nums2, n) {\n    let i = m - 1, j = n - 1, k = m + n - 1;\n    while (i >= 0 && j >= 0) {\n        if (nums1[i] > nums2[j])\n            nums1[k--] = nums1[i--];\n        else\n            nums1[k--] = nums2[j--];\n    }\n    while (j >= 0) {\n        nums1[k--] = nums2[j--];\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/89", "prompt": "An **n-bit gray code sequence** is a sequence of `2n` integers where:\n\n*   Every integer is in the **inclusive** range `[0, 2n - 1]`,\n*   The first integer is `0`,\n*   An integer appears **no more than once** in the sequence,\n*   The binary representation of every pair of **adjacent** integers differs by **exactly one bit**, and\n*   The binary representation of the **first** and **last** integers differs by **exactly one bit**.\n\nGiven an integer `n`, return _any valid **n-bit gray code sequence**_.\n\n**Example 1:**\n\n**Input:** n = 2\n**Output:** \\[0,1,3,2\\]\n**Explanation:**\nThe binary representation of \\[0,1,3,2\\] is \\[00,01,11,10\\].\n- 00 and 01 differ by one bit\n- 01 and 11 differ by one bit\n- 11 and 10 differ by one bit\n- 10 and 00 differ by one bit\n\\[0,2,3,1\\] is also a valid gray code sequence, whose binary representation is \\[00,10,11,01\\].\n- 00 and 10 differ by one bit\n- 10 and 11 differ by one bit\n- 11 and 01 differ by one bit\n- 01 and 00 differ by one bit\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** \\[0,1\\]\n\n**Constraints:**\n\n*   `1 <= n <= 16`", "entry_point": "gray_code", "canonical_solutions": {"python": "def grayCode(n):\n    result = []\n    for i in range(1 << n):\n        result.append(i ^ (i >> 1))\n    return result", "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> grayCode(int n) {\n    List<Integer> result = new ArrayList<>();\n    for (int i = 0; i < (1 << n); i++) {\n        result.add(i ^ (i >> 1));\n    }\n    return result;\n}", "cpp": "#include <vector>\n\nstd::vector<int> grayCode(int n) {\n    std::vector<int> result;\n    for (int i = 0; i < (1 << n); i++) {\n        result.push_back(i ^ (i >> 1));\n    }\n    return result;\n}", "javascript": "function grayCode(n) {\n    const result = [];\n    for (let i = 0; i < (1 << n); i++) {\n        result.push(i ^ (i >> 1));\n    }\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/90", "prompt": "Given an integer array `nums` that may contain duplicates, return _all possible_ _subsets_ _(the power set)_.\n\nThe solution set **must not** contain duplicate subsets. Return the solution in **any order**.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,2\\]\n**Output:** \\[\\[\\],\\[1\\],\\[1,2\\],\\[1,2,2\\],\\[2\\],\\[2,2\\]\\]\n\n**Example 2:**\n\n**Input:** nums = \\[0\\]\n**Output:** \\[\\[\\],\\[0\\]\\]\n\n**Constraints:**\n\n*   `1 <= nums.length <= 10`\n*   `-10 <= nums[i] <= 10`", "entry_point": "subsets_ii", "canonical_solutions": {"python": "from itertools import combinations\n\ndef subsetsWithDup(nums):\n    result = set()\n    nums.sort()\n    for i in range(len(nums) + 1):\n        for combo in combinations(nums, i):\n            result.add(combo)\n    return list(result)", "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\n    Set<List<Integer>> result = new HashSet<>();\n    Arrays.sort(nums);\n    backtrack(nums, 0, new ArrayList<Integer>(), result);\n    return new ArrayList<>(result);\n}\n\nprivate void backtrack(int[] nums, int index, List<Integer> subset, Set<List<Integer>> result) {\n    result.add(new ArrayList<>(subset));\n    for (int i = index; i < nums.length; i++) {\n        subset.add(nums[i]);\n        backtrack(nums, i + 1, subset, result);\n        subset.remove(subset.size() - 1);\n    }\n}", "cpp": "#include <vector>\n#include <set>\nusing namespace std;\n\nvector<vector<int>> subsetsWithDup(vector<int>& nums) {\n    set<vector<int>> result;\n    vector<int> subset;\n    sort(nums.begin(), nums.end());\n    backtrack(nums, 0, subset, result);\n    return vector<vector<int>>(result.begin(), result.end());\n}\n\nvoid backtrack(vector<int>& nums, int index, vector<int>& subset, set<vector<int>>& result) {\n    result.insert(subset);\n    for (int i = index; i < nums.size(); i++) {\n        subset.push_back(nums[i]);\n        backtrack(nums, i + 1, subset, result);\n        subset.pop_back();\n    }\n}", "javascript": "function subsetsWithDup(nums) {\n  const result = new Set();\n  nums.sort((a, b) => a - b);\n  backtrack(nums, 0, [], result);\n  return Array.from(result).map(item => Array.from(item));\n}\n\nfunction backtrack(nums, index, subset, result) {\n  result.add(JSON.stringify(subset));\n  for (let i = index; i < nums.length; i++) {\n    subset.push(nums[i]);\n    backtrack(nums, i + 1, subset, result);\n    subset.pop();\n  }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/91", "prompt": "A message containing letters from `A-Z` can be **encoded** into numbers using the following mapping:\n\n'A' ->  \"1 \"\n'B' ->  \"2 \"\n...\n'Z' ->  \"26 \"\n\nTo **decode** an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, `\"11106 \"` can be mapped into:\n\n*   `\"AAJF \"` with the grouping `(1 1 10 6)`\n*   `\"KJF \"` with the grouping `(11 10 6)`\n\nNote that the grouping `(1 11 06)` is invalid because `\"06 \"` cannot be mapped into `'F'` since `\"6 \"` is different from `\"06 \"`.\n\nGiven a string `s` containing only digits, return _the **number** of ways to **decode** it_.\n\nThe test cases are generated so that the answer fits in a **32-bit** integer.\n\n**Example 1:**\n\n**Input:** s =  \"12 \"\n**Output:** 2\n**Explanation:**  \"12 \" could be decoded as  \"AB \" (1 2) or  \"L \" (12).\n\n**Example 2:**\n\n**Input:** s =  \"226 \"\n**Output:** 3\n**Explanation:**  \"226 \" could be decoded as  \"BZ \" (2 26),  \"VF \" (22 6), or  \"BBF \" (2 2 6).\n\n**Example 3:**\n\n**Input:** s =  \"06 \"\n**Output:** 0\n**Explanation:**  \"06 \" cannot be mapped to  \"F \" because of the leading zero ( \"6 \" is different from  \"06 \").\n\n**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `s` contains only digits and may contain leading zero(s).", "entry_point": "decode_ways", "canonical_solutions": {"python": "def numDecodings(s: str) -> int:\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1 if s[0] != '0' else 0\n\n    for i in range(2, n + 1):\n        one_digit = int(s[i - 1:i])\n        two_digits = int(s[i - 2:i])\n\n        if one_digit >= 1:\n            dp[i] += dp[i - 1]\n        if two_digits >= 10 and two_digits <= 26:\n            dp[i] += dp[i - 2]\n    return dp[n]", "java": "public int numDecodings(String s) {\n    int n = s.length();\n    int[] dp = new int[n + 1];\n    dp[0] = 1;\n    dp[1] = s.charAt(0) != '0' ? 1 : 0;\n\n    for (int i = 2; i <= n; i++) {\n        int oneDigit = Integer.parseInt(s.substring(i - 1, i));\n        int twoDigits = Integer.parseInt(s.substring(i - 2, i));\n\n        if (oneDigit >= 1)\n            dp[i] += dp[i - 1];\n        if (twoDigits >= 10 && twoDigits <= 26)\n            dp[i] += dp[i - 2];\n    }\n    return dp[n];\n}", "cpp": "#include <string>\n#include <vector>\n\nint numDecodings(std::string s) {\n    int n = s.size();\n    std::vector<int> dp(n + 1, 0);\n    dp[0] = 1;\n    dp[1] = s[0] != '0' ? 1 : 0;\n\n    for (int i = 2; i <= n; ++i) {\n        int oneDigit = stoi(s.substr(i - 1, 1));\n        int twoDigits = stoi(s.substr(i - 2, 2));\n\n        if (oneDigit >= 1)\n            dp[i] += dp[i - 1];\n        if (twoDigits >= 10 && twoDigits <= 26)\n            dp[i] += dp[i - 2];\n    }\n    return dp[n];\n}", "javascript": "var numDecodings = function(s) {\n    const n = s.length;\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    dp[1] = s[0] !== '0' ? 1 : 0;\n\n    for (let i = 2; i <= n; i++) {\n        const oneDigit = parseInt(s.slice(i - 1, i), 10);\n        const twoDigits = parseInt(s.slice(i - 2, i), 10);\n\n        if (oneDigit >= 1)\n            dp[i] += dp[i - 1];\n        if (twoDigits >= 10 && twoDigits <= 26)\n            dp[i] += dp[i - 2];\n    }\n    return dp[n];\n};"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/92", "prompt": "Given the `head` of a singly linked list and two integers `left` and `right` where `left <= right`, reverse the nodes of the list from position `left` to position `right`, and return _the reversed list_.\n\n**Example 1:**\n\n**Input:** head = \\[1,2,3,4,5\\], left = 2, right = 4\n**Output:** \\[1,4,3,2,5\\]\n\n**Example 2:**\n\n**Input:** head = \\[5\\], left = 1, right = 1\n**Output:** \\[5\\]\n\n**Constraints:**\n\n*   The number of nodes in the list is `n`.\n*   `1 <= n <= 500`\n*   `-500 <= Node.val <= 500`\n*   `1 <= left <= right <= n`\n\n**Follow up:** Could you do it in one pass?", "entry_point": "reverse_linked_list_ii", "canonical_solutions": {"python": "def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\n    if not head or left == right:\n        return head\n    dummy = ListNode(0)\n    dummy.next = head\n    pre = dummy\n    for _ in range(left - 1):\n        pre = pre.next\n    cur = pre.next\n    for _ in range(left, right):\n        t = cur.next\n        cur.next = t.next\n        t.next = pre.next\n        pre.next = t\n    return dummy.next", "java": "public ListNode reverseBetween(ListNode head, int left, int right) {\n    if (head == null || left == right) return head;\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    ListNode pre = dummy;\n    for (int i = 1; i < left; ++i) pre = pre.next;\n    ListNode cur = pre.next;\n    for (int i = left; i < right; ++i) {\n        ListNode t = cur.next;\n        cur.next = t.next;\n        t.next = pre.next;\n        pre.next = t;\n    }\n    return dummy.next;\n}", "cpp": "ListNode* reverseBetween(ListNode* head, int left, int right) {\n    if (!head || left == right) return head;\n    ListNode dummy(0);\n    dummy.next = head;\n    ListNode* pre = &dummy;\n    for (int i = 1; i < left; ++i) pre = pre->next;\n    ListNode* cur = pre->next;\n    for (int i = left; i < right; ++i) {\n        ListNode* t = cur->next;\n        cur->next = t->next;\n        t->next = pre->next;\n        pre->next = t;\n    }\n    return dummy.next;\n}", "javascript": "function reverseBetween(head, left, right) {\n    if (!head || left === right) return head;\n    const dummy = new ListNode(0);\n    dummy.next = head;\n    let pre = dummy;\n    for (let i = 1; i < left; ++i) pre = pre.next;\n    let cur = pre.next;\n    for (let i = left; i < right; ++i) {\n        const t = cur.next;\n        cur.next = t.next;\n        t.next = pre.next;\n        pre.next = t;\n    }\n    return dummy.next;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/93", "prompt": "A **valid IP address** consists of exactly four integers separated by single dots. Each integer is between `0` and `255` (**inclusive**) and cannot have leading zeros.\n\n*   For example, `\"0.1.2.201 \"` and `\"192.168.1.1 \"` are **valid** IP addresses, but `\"0.011.255.245 \"`, `\"192.168.1.312 \"` and `\"192.168@1.1 \"` are **invalid** IP addresses.\n\nGiven a string `s` containing only digits, return _all possible valid IP addresses that can be formed by inserting dots into_ `s`. You are **not** allowed to reorder or remove any digits in `s`. You may return the valid IP addresses in **any** order.\n\n**Example 1:**\n\n**Input:** s =  \"25525511135 \"\n**Output:** \\[ \"255.255.11.135 \", \"255.255.111.35 \"\\]\n\n**Example 2:**\n\n**Input:** s =  \"0000 \"\n**Output:** \\[ \"0.0.0.0 \"\\]\n\n**Example 3:**\n\n**Input:** s =  \"101023 \"\n**Output:** \\[ \"1.0.10.23 \", \"1.0.102.3 \", \"10.1.0.23 \", \"10.10.2.3 \", \"101.0.2.3 \"\\]\n\n**Constraints:**\n\n*   `1 <= s.length <= 20`\n*   `s` consists of digits only.", "entry_point": "restore_ip_addresses", "canonical_solutions": {"python": "def restore_ip_addresses(s):\n    def dfs(s, start, ip, result, part):\n        if part == 4 and start == len(s):\n            result.append(ip[:-1])\n            return\n        if part == 4 or start >= len(s):\n            return\n\n        num = 0\n        for i in range(start, len(s)):\n            num = num * 10 + int(s[i])\n            if num > 255:\n                break\n            dfs(s, i + 1, ip + s[i] + \".\", result, part + 1)\n            if num == 0:\n                break\n\n    result = []\n    dfs(s, 0, \"\", result, 0)\n    return result", "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> restoreIpAddresses(String s) {\n    List<String> result = new ArrayList<>();\n    dfs(s, 0, \"\", result, 0);\n    return result;\n}\n\nprivate void dfs(String s, int start, String ip, List<String> result, int part) {\n    if (part == 4 && start == s.length()) {\n        result.add(ip.substring(0, ip.length() - 1));\n        return;\n    }\n    if (part == 4 || start >= s.length()) return;\n\n    int num = 0;\n    for (int i = start; i < s.length(); i++) {\n        num = num * 10 + (s.charAt(i) - '0');\n        if (num > 255) break;\n        dfs(s, i + 1, ip + s.charAt(i) + \".\", result, part + 1);\n        if (num == 0) break;\n    }\n}", "cpp": "#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> restore_ip_address(string s) {\n    vector<string> result;\n    string ip;\n    dfs(result, s, ip, 0, 0);\n    return result;\n}\n\nvoid dfs(vector<string>& result, string s, string ip, int start, int part) {\n    if (part == 4 && start == s.size()) {\n        ip.pop_back();\n        result.push_back(ip);\n        return;\n    }\n    if (part == 4 || start == s.size()) return;\n\n    int num = 0;\n    for (int i = start; i < s.size(); i++) {\n        num = num * 10 + (s[i] - '0');\n        if (num > 255) break;\n        ip += s[i];\n        dfs(result, s, ip + '.', i + 1, part + 1);\n        if (num == 0) break;\n    }\n}", "javascript": "function restoreIpAddresses(s) {\n    const result = [];\n    dfs(s, 0, \"\", result, 0);\n    return result;\n}\n\nfunction dfs(s, start, ip, result, part) {\n    if (part === 4 && start === s.length) {\n        result.push(ip.slice(0, -1));\n        return;\n    }\n    if (part === 4 || start >= s.length) return;\n\n    let num = 0;\n    for (let i = start; i < s.length; i++) {\n        num = num * 10 + parseInt(s[i]);\n        if (num > 255) break;\n        dfs(s, i + 1, ip + s[i] + \".\", result, part + 1);\n        if (num === 0) break;\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/94", "prompt": "Given the `root` of a binary tree, return _the inorder traversal of its nodes' values_.\n\n**Example 1:**\n\n**Input:** root = \\[1,null,2,3\\]\n**Output:** \\[1,3,2\\]\n\n**Example 2:**\n\n**Input:** root = \\[\\]\n**Output:** \\[\\]\n\n**Example 3:**\n\n**Input:** root = \\[1\\]\n**Output:** \\[1\\]\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 100]`.\n*   `-100 <= Node.val <= 100`\n\n**Follow up:** Recursive solution is trivial, could you do it iteratively?", "entry_point": "binary_tree_inorder_traversal", "canonical_solutions": {"python": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef inorderTraversalHelper(root, result):\n    if not root:\n        return\n    inorderTraversalHelper(root.left, result)\n    result.append(root.val)\n    inorderTraversalHelper(root.right, result)\n\ndef inorderTraversal(root):\n    result = []\n    inorderTraversalHelper(root, result)\n    return result", "java": "import java.util.List;\nimport java.util.ArrayList;\n\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n}\n\npublic List<Integer> inorderTraversal(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    inorderTraversalHelper(root, result);\n    return result;\n}\n\nprivate void inorderTraversalHelper(TreeNode root, List<Integer> result) {\n    if (root == null) {\n        return;\n    }\n    inorderTraversalHelper(root.left, result);\n    result.add(root.val);\n    inorderTraversalHelper(root.right, result);\n}", "cpp": "#include<vector>\nusing namespace std;\n\nclass TreeNode {\npublic:\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n};\n\nvoid inorderTraversalHelper(TreeNode* root, vector<int>& result) {\n    if (!root) return;\n    inorderTraversalHelper(root->left, result);\n    result.push_back(root->val);\n    inorderTraversalHelper(root->right, result);\n}\n\nvector<int> inorderTraversal(TreeNode* root){\n    vector<int> result;\n    inorderTraversalHelper(root, result);\n    return result;\n}", "javascript": "class TreeNode {\n    constructor(val, left = null, right = null){\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction inorderTraversalHelper(root, result) {\n    if (!root) return;\n    inorderTraversalHelper(root.left, result);\n    result.push(root.val);\n    inorderTraversalHelper(root.right, result);\n}\n\nfunction inorderTraversal(root) {\n    let result = [];\n    inorderTraversalHelper(root, result);\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/95", "prompt": "Given an integer `n`, return _all the structurally unique **BST'**s (binary search trees), which has exactly_ `n` _nodes of unique values from_ `1` _to_ `n`. Return the answer in **any order**.\n\n**Example 1:**\n\n**Input:** n = 3\n**Output:** \\[\\[1,null,2,null,3\\],\\[1,null,3,2\\],\\[2,1,3\\],\\[3,1,null,null,2\\],\\[3,2,null,1\\]\\]\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** \\[\\[1\\]\\]\n\n**Constraints:**\n\n*   `1 <= n <= 8`", "entry_point": "unique_binary_search_trees_ii", "canonical_solutions": {"python": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef generate_trees(start, end):\n    trees = []\n    if start > end:\n        trees.append(None)\n        return trees\n\n    for i in range(start, end + 1):\n        left_subtrees = generate_trees(start, i - 1)\n        right_subtrees = generate_trees(i + 1, end)\n\n        for left in left_subtrees:\n            for right in right_subtrees:\n                new_node = TreeNode(i)\n                new_node.left = left\n                new_node.right = right\n                trees.append(new_node)\n\n    return trees\n\ndef generate_trees(n):\n    if n == 0:\n        return []\n    return generate_trees(1, n)", "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\nclass Solution {\n    public List<TreeNode> generateTrees(int start, int end) {\n        List<TreeNode> trees = new ArrayList<>();\n        if (start > end) {\n            trees.add(null);\n            return trees;\n        }\n\n        for (int i = start; i <= end; i++) {\n            List<TreeNode> leftSubtrees = generateTrees(start, i - 1);\n            List<TreeNode> rightSubtrees = generateTrees(i + 1, end);\n\n            for (TreeNode left : leftSubtrees) {\n                for (TreeNode right : rightSubtrees) {\n                    TreeNode newNode = new TreeNode(i);\n                    newNode.left = left;\n                    newNode.right = right;\n                    trees.add(newNode);\n                }\n            }\n        }\n\n        return trees;\n    }\n\n    public List<TreeNode> generateTrees(int n) {\n        if (n == 0) {\n            return new ArrayList<TreeNode>();\n        }\n        return generateTrees(1, n);\n    }\n}", "cpp": "#include <vector>\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nstd::vector<TreeNode*> generateTrees(int start, int end) {\n    std::vector<TreeNode*> trees;\n    if (start > end) {\n        trees.push_back(nullptr);\n        return trees;\n    }\n\n    for (int i = start; i <= end; i++) {\n        std::vector<TreeNode*> leftSubtrees = generateTrees(start, i - 1);\n        std::vector<TreeNode*> rightSubtrees = generateTrees(i + 1, end);\n\n        for (TreeNode* left : leftSubtrees) {\n            for (TreeNode* right : rightSubtrees) {\n                TreeNode* newNode = new TreeNode(i);\n                newNode->left = left;\n                newNode->right = right;\n                trees.push_back(newNode);\n            }\n        }\n    }\n\n    return trees;\n}\n\nstd::vector<TreeNode*> generateTrees(int n) {\n    if (n == 0) {\n        return std::vector<TreeNode*>();\n    }\n    return generateTrees(1, n);\n}", "javascript": "class TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction generateTrees(start, end) {\n    const trees = [];\n    if (start > end) {\n        trees.push(null);\n        return trees;\n    }\n\n    for (let i = start; i <= end; i++) {\n        const leftSubtrees = generateTrees(start, i - 1);\n        const rightSubtrees = generateTrees(i + 1, end);\n\n        for (const left of leftSubtrees) {\n            for (const right of rightSubtrees) {\n                const newNode = new TreeNode(i);\n                newNode.left = left;\n                newNode.right = right;\n                trees.push(newNode);\n            }\n        }\n    }\n\n    return trees;\n}\n\nfunction generateTrees(n) {\n    if (n === 0) {\n        return [];\n    }\n    return generateTrees(1, n);\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/96", "prompt": "Given an integer `n`, return _the number of structurally unique **BST'**s (binary search trees) which has exactly_ `n` _nodes of unique values from_ `1` _to_ `n`.\n\n**Example 1:**\n\n**Input:** n = 3\n**Output:** 5\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= n <= 19`", "entry_point": "unique_binary_search_trees", "canonical_solutions": {"python": "def numTrees(n):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i - j - 1]\n    return dp[n]", "java": "public int numTrees(int n) {\n    int[] dp = new int[n + 1];\n    dp[0] = 1;\n    dp[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        for (int j = 0; j < i; j++) {\n            dp[i] += dp[j] * dp[i - j - 1];\n        }\n    }\n    return dp[n];\n}", "cpp": "int numTrees(int n) {\n    vector<int> dp(n + 1, 0);\n    dp[0] = dp[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        for (int j = 0; j < i; j++) {\n            dp[i] += dp[j] * dp[i - j - 1];\n        }\n    }\n    return dp[n];\n}", "javascript": "function numTrees(n) {\n    let dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    dp[1] = 1;\n    for (let i = 2; i <= n; i++) {\n        for (let j = 0; j < i; j++) {\n            dp[i] += dp[j] * dp[i - j - 1];\n        }\n    }\n    return dp[n];\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/97", "prompt": "Given strings `s1`, `s2`, and `s3`, find whether `s3` is formed by an **interleaving** of `s1` and `s2`.\n\nAn **interleaving** of two strings `s` and `t` is a configuration where `s` and `t` are divided into `n` and `m` substrings respectively, such that:\n\n*   `s = s1 + s2 + ... + sn`\n*   `t = t1 + t2 + ... + tm`\n*   `|n - m| <= 1`\n*   The **interleaving** is `s1 + t1 + s2 + t2 + s3 + t3 + ...` or `t1 + s1 + t2 + s2 + t3 + s3 + ...`\n\n**Note:** `a + b` is the concatenation of strings `a` and `b`.\n\n**Example 1:**\n\n**Input:** s1 =  \"aabcc \", s2 =  \"dbbca \", s3 =  \"aadbbcbcac \"\n**Output:** true\n**Explanation:** One way to obtain s3 is:\nSplit s1 into s1 =  \"aa \" +  \"bc \" +  \"c \", and s2 into s2 =  \"dbbc \" +  \"a \".\nInterleaving the two splits, we get  \"aa \" +  \"dbbc \" +  \"bc \" +  \"a \" +  \"c \" =  \"aadbbcbcac \".\nSince s3 can be obtained by interleaving s1 and s2, we return true.\n\n**Example 2:**\n\n**Input:** s1 =  \"aabcc \", s2 =  \"dbbca \", s3 =  \"aadbbbaccc \"\n**Output:** false\n**Explanation:** Notice how it is impossible to interleave s2 with any other string to obtain s3.\n\n**Example 3:**\n\n**Input:** s1 =  \" \", s2 =  \" \", s3 =  \" \"\n**Output:** true\n\n**Constraints:**\n\n*   `0 <= s1.length, s2.length <= 100`\n*   `0 <= s3.length <= 200`\n*   `s1`, `s2`, and `s3` consist of lowercase English letters.\n\n**Follow up:** Could you solve it using only `O(s2.length)` additional memory space?", "entry_point": "interleaving_string", "canonical_solutions": {"python": "def isInterleave(s1, s2, s3):\n    m, n = len(s1), len(s2)\n    if m + n != len(s3):\n        return False\n\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n    for i in range(1, m + 1):\n        dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n    for j in range(1, n + 1):\n        dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or \\\n                       (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n\n    return dp[m][n]", "java": "public boolean isInterleave(String s1, String s2, String s3) {\n    int m = s1.length(), n = s2.length();\n    if (m + n != s3.length()) return false;\n\n    boolean[][] dp = new boolean[m + 1][n + 1];\n    dp[0][0] = true;\n    for (int i = 1; i <= m; i++)\n        dp[i][0] = dp[i - 1][0] && s1.charAt(i - 1) == s3.charAt(i - 1);\n    for (int j = 1; j <= n; j++)\n        dp[0][j] = dp[0][j - 1] && s2.charAt(j - 1) == s3.charAt(j - 1);\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            dp[i][j] = (dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) ||\n                       (dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));\n        }\n    }\n\n    return dp[m][n];\n}", "cpp": "bool isInterleave(string s1, string s2, string s3) {\n    int m = s1.length(), n = s2.length();\n    if (m + n != s3.length()) return false;\n\n    vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));\n    dp[0][0] = true;\n    for (int i = 1; i <= m; i++)\n        dp[i][0] = dp[i - 1][0] && s1[i - 1] == s3[i - 1];\n    for (int j = 1; j <= n; j++)\n        dp[0][j] = dp[0][j - 1] && s2[j - 1] == s3[j - 1];\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            dp[i][j] = (dp[i - 1][j] && s1[i - 1] == s3[i + j - 1]) ||\n                       (dp[i][j - 1] && s2[j - 1] == s3[i + j - 1]);\n        }\n    }\n\n    return dp[m][n];\n}", "javascript": "function isInterleave(s1, s2, s3) {\n    let m = s1.length, n = s2.length;\n    if (m + n !== s3.length) return false;\n\n    let dp = new Array(m + 1).fill(null).map(() => new Array(n + 1).fill(false));\n    dp[0][0] = true;\n    for (let i = 1; i <= m; i++)\n        dp[i][0] = dp[i - 1][0] && s1[i - 1] === s3[i - 1];\n    for (let j = 1; j <= n; j++)\n        dp[0][j] = dp[0][j - 1] && s2[j - 1] === s3[j - 1];\n\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            dp[i][j] = (dp[i - 1][j] && s1[i - 1] === s3[i + j - 1]) ||\n                       (dp[i][j - 1] && s2[j - 1] === s3[i + j - 1]);\n        }\n    }\n\n    return dp[m][n];\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/98", "prompt": "Given the `root` of a binary tree, _determine if it is a valid binary search tree (BST)_.\n\nA **valid BST** is defined as follows:\n\n*   The left subtree of a node contains only nodes with keys **less than** the node's key.\n*   The right subtree of a node contains only nodes with keys **greater than** the node's key.\n*   Both the left and right subtrees must also be binary search trees.\n\n**Example 1:**\n\n**Input:** root = \\[2,1,3\\]\n**Output:** true\n\n**Example 2:**\n\n**Input:** root = \\[5,1,4,null,null,3,6\\]\n**Output:** false\n**Explanation:** The root node's value is 5 but its right child's value is 4.\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-231 <= Node.val <= 231 - 1`", "entry_point": "validate_binary_search_tree", "canonical_solutions": {"python": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef isValidBSTHelper(node, min_val, max_val):\n    if node is None:\n        return True\n    if not min_val < node.val < max_val:\n        return False\n    return (isValidBSTHelper(node.left, min_val, node.val) and\n            isValidBSTHelper(node.right, node.val, max_val))\n\ndef isValidBST(root):\n    return isValidBSTHelper(root, float('-inf'), float('inf'))", "java": "public class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n}\n\npublic boolean isValidBST(TreeNode root) {\n    return isValidBSTHelper(root, Long.MIN_VALUE, Long.MAX_VALUE);\n}\n\nprivate boolean isValidBSTHelper(TreeNode node, long min, long max) {\n    if (node == null) return true;\n    if (node.val <= min || node.val >= max) return false;\n    return isValidBSTHelper(node.left, min, node.val) && isValidBSTHelper(node.right, node.val, max);\n}", "cpp": "struct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n};\n\nbool isValidBSTHelper(TreeNode* root, long min, long max) {\n    if (root == nullptr) return true;\n    if (root->val <= min || root->val >= max) return false;\n    return isValidBSTHelper(root->left, min, root->val) && isValidBSTHelper(root->right, root->val, max);\n}\n\nbool isValidBST(TreeNode* root) {\n    return isValidBSTHelper(root, LONG_MIN, LONG_MAX);\n}", "javascript": "class TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction isValidBST(root) {\n    return isValidBSTHelper(root, -Infinity, Infinity);\n}\n\nfunction isValidBSTHelper(node, minVal, maxVal) {\n    if (node === null) return true;\n    if (node.val <= minVal || node.val >= maxVal) return false;\n    return isValidBSTHelper(node.left, minVal, node.val) && isValidBSTHelper(node.right, node.val, maxVal);\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/99", "prompt": "You are given the `root` of a binary search tree (BST), where the values of **exactly** two nodes of the tree were swapped by mistake. _Recover the tree without changing its structure_.\n\n**Example 1:**\n\n**Input:** root = \\[1,3,null,null,2\\]\n**Output:** \\[3,1,null,null,2\\]\n**Explanation:** 3 cannot be a left child of 1 because 3 > 1. Swapping 1 and 3 makes the BST valid.\n\n**Example 2:**\n\n**Input:** root = \\[3,1,4,null,null,2\\]\n**Output:** \\[2,1,4,null,null,3\\]\n**Explanation:** 2 cannot be in the right subtree of 3 because 2 < 3. Swapping 2 and 3 makes the BST valid.\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[2, 1000]`.\n*   `-231 <= Node.val <= 231 - 1`\n\n**Follow up:** A solution using `O(n)` space is pretty straight-forward. Could you devise a constant `O(1)` space solution?", "entry_point": "recover_binary_search_tree", "canonical_solutions": {"python": "def inorder(node, nodes):\n    if not node: return\n    inorder(node.left, nodes)\n    if nodes[1] and nodes[1].val > node.val:\n        if not nodes[0]: nodes[0] = nodes[1]\n        nodes[2] = node\n    nodes[1] = node\n    inorder(node.right, nodes)\n\ndef recoverTree(root):\n    nodes = [None, None, None]\n    inorder(root, nodes)\n    nodes[0].val, nodes[2].val = nodes[2].val, nodes[0].val", "java": "void inorder(TreeNode node, TreeNode[] nodes) {\n    if (node == null) return;\n    inorder(node.left, nodes);\n    if (nodes[1] != null && nodes[1].val > node.val) {\n        if (nodes[0] == null) nodes[0] = nodes[1];\n        nodes[2] = node;\n    }\n    nodes[1] = node;\n    inorder(node.right, nodes);\n}\n\npublic void recoverTree(TreeNode root) {\n    TreeNode[] nodes = new TreeNode[3];\n    inorder(root, nodes);\n    int temp = nodes[0].val;\n    nodes[0].val = nodes[2].val;\n    nodes[2].val = temp;\n}", "cpp": "void inorder(TreeNode* node, TreeNode*& first, TreeNode*& second, TreeNode*& prev) {\n    if (!node) return;\n    inorder(node->left, first, second, prev);\n    if (prev && prev->val > node->val) {\n        if (!first) first = prev;\n        second = node;\n    }\n    prev = node;\n    inorder(node->right, first, second, prev);\n}\n\nvoid recoverTree(TreeNode* root) {\n    TreeNode *first = nullptr, *second = nullptr, *prev = nullptr;\n    inorder(root, first, second, prev);\n    std::swap(first->val, second->val);\n}", "javascript": "function inorder(node, nodes) {\n    if (!node) return;\n    inorder(node.left, nodes);\n    if (nodes[1] && nodes[1].val > node.val) {\n        if (!nodes[0]) nodes[0] = nodes[1];\n        nodes[2] = node;\n    }\n    nodes[1] = node;\n    inorder(node.right, nodes);\n}\n\nfunction recoverTree(root) {\n    const nodes = [null, null, null];\n    inorder(root, nodes);\n    const temp = nodes[0].val;\n    nodes[0].val = nodes[2].val;\n    nodes[2].val = temp;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/100", "prompt": "Given the roots of two binary trees `p` and `q`, write a function to check if they are the same or not.\n\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\n\n**Example 1:**\n\n**Input:** p = \\[1,2,3\\], q = \\[1,2,3\\]\n**Output:** true\n\n**Example 2:**\n\n**Input:** p = \\[1,2\\], q = \\[1,null,2\\]\n**Output:** false\n\n**Example 3:**\n\n**Input:** p = \\[1,2,1\\], q = \\[1,1,2\\]\n**Output:** false\n\n**Constraints:**\n\n*   The number of nodes in both trees is in the range `[0, 100]`.\n*   `-104 <= Node.val <= 104`", "entry_point": "same_tree", "canonical_solutions": {"python": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef is_same_tree(p, q):\n    if p is None and q is None:\n        return True\n    if p is None or q is None:\n        return False\n    if p.val != q.val:\n        return False\n    return is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)", "java": "public class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n}\n\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) {\n        return true;\n    }\n    if (p == null || q == null) {\n        return false;\n    }\n    if (p.val != q.val) {\n        return false;\n    }\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n}", "cpp": "struct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n};\n\nbool isSameTree(TreeNode* p, TreeNode* q) {\n    if (p == nullptr && q == nullptr) {\n        return true;\n    }\n    if (p == nullptr || q == nullptr) {\n        return false;\n    }\n    if (p->val != q->val) {\n        return false;\n    }\n    return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n}", "javascript": "class TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction isSameTree(p, q) {\n    if (p === null && q === null) {\n        return true;\n    }\n    if (p === null || q === null) {\n        return false;\n    }\n    if (p.val !== q.val) {\n        return false;\n    }\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/101", "prompt": "Given the `root` of a binary tree, _check whether it is a mirror of itself_ (i.e., symmetric around its center).\n\n**Example 1:**\n\n**Input:** root = \\[1,2,2,3,4,4,3\\]\n**Output:** true\n\n**Example 2:**\n\n**Input:** root = \\[1,2,2,null,3,null,3\\]\n**Output:** false\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 1000]`.\n*   `-100 <= Node.val <= 100`\n\n**Follow up:** Could you solve it both recursively and iteratively?", "entry_point": "symmetric_tree", "canonical_solutions": {"python": "def isSymmetric(root):\n    return checkSymmetry(root, root)\n\ndef checkSymmetry(node1, node2):\n    if not node1 and not node2:\n        return True\n    if not node1 or not node2:\n        return False\n    return (node1.val == node2.val) and checkSymmetry(node1.right, node2.left) and checkSymmetry(node1.left, node2.right)", "java": "public boolean isSymmetric(TreeNode root) {\n    return checkSymmetry(root, root);\n}\n\npublic boolean checkSymmetry(TreeNode node1, TreeNode node2) {\n    if (node1 == null && node2 == null) return true;\n    if (node1 == null || node2 == null) return false;\n    return (node1.val == node2.val) && checkSymmetry(node1.right, node2.left) && checkSymmetry(node1.left, node2.right);\n}", "cpp": "bool isSymmetric(TreeNode* root) {\n    return checkSymmetry(root, root);\n}\n\nbool checkSymmetry(TreeNode* node1, TreeNode* node2) {\n    if (!node1 && !node2) return true;\n    if (!node1 || !node2) return false;\n    return (node1->val == node2->val) && checkSymmetry(node1->right, node2->left) && checkSymmetry(node1->left, node2->right);\n}", "javascript": "function isSymmetric(root) {\n    return checkSymmetry(root, root);\n}\n\nfunction checkSymmetry(node1, node2) {\n    if (!node1 && !node2) return true;\n    if (!node1 || !node2) return false;\n    return (node1.val === node2.val) && checkSymmetry(node1.right, node2.left) && checkSymmetry(node1.left, node2.right);\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/102", "prompt": "Given the `root` of a binary tree, return _the level order traversal of its nodes' values_. (i.e., from left to right, level by level).\n\n**Example 1:**\n\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** \\[\\[3\\],\\[9,20\\],\\[15,7\\]\\]\n\n**Example 2:**\n\n**Input:** root = \\[1\\]\n**Output:** \\[\\[1\\]\\]\n\n**Example 3:**\n\n**Input:** root = \\[\\]\n**Output:** \\[\\]\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 2000]`.\n*   `-1000 <= Node.val <= 1000`", "entry_point": "binary_tree_level_order_traversal", "canonical_solutions": {"python": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef levelOrder(root):\n    if not root:\n        return []\n\n    result = []\n    queue = [root]\n\n    while queue:\n        level = []\n        for i in range(len(queue)):\n            node = queue.pop(0)\n\n            if node.left:\n                queue.append(node.left)\n\n            if node.right:\n                queue.append(node.right)\n\n            level.append(node.val)\n\n        result.append(level)\n\n    return result", "java": "import java.util.List;\nimport java.util.ArrayList;\nimport java.util.Queue;\nimport java.util.LinkedList;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic List<List<Integer>> levelOrder(TreeNode root) {\n    List<List<Integer>> result = new ArrayList<>();\n    if(root == null) return result;\n    \n    Queue<TreeNode> q = new LinkedList<>();\n    q.offer(root);\n    \n    while(!q.isEmpty()) {\n        int size = q.size();\n        List<Integer> level = new ArrayList<>();\n        \n        for(int i=0; i<size; i++) {\n            TreeNode currNode = q.poll();\n            level.add(currNode.val);\n            \n            if(currNode.left != null) q.offer(currNode.left);\n            if(currNode.right != null) q.offer(currNode.right);\n        }\n        \n        result.add(level);\n    }\n    \n    return result;\n}", "cpp": "#include <vector>\n#include <queue>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nstd::vector<std::vector<int>> levelOrder(TreeNode* root) {\n    std::vector<std::vector<int>> result;\n    if(root == nullptr) return result;\n    \n    std::queue<TreeNode*> q;\n    q.push(root);\n    \n    while(!q.empty()) {\n        int size = q.size();\n        std::vector<int> level;\n        \n        for(int i=0; i<size; i++) {\n            TreeNode* currNode = q.front();\n            level.push_back(currNode->val);\n            \n            if(currNode->left) q.push(currNode->left);\n            if(currNode->right) q.push(currNode->right);\n            \n            q.pop();\n        }\n        \n        result.push_back(level);\n    }\n    \n    return result;\n}", "javascript": "class TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction levelOrder(root) {\n    if (!root) return [];\n\n    const result = [];\n    const queue = [root];\n\n    while (queue.length) {\n        const level = [];\n        for (let i = 0, len = queue.length; i < len; i++) {\n            const currentNode = queue.shift();\n            level.push(currentNode.val);\n\n            currentNode.left && queue.push(currentNode.left);\n            currentNode.right && queue.push(currentNode.right);\n        }\n\n        result.push(level);\n    }\n\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/103", "prompt": "Given the `root` of a binary tree, return _the zigzag level order traversal of its nodes' values_. (i.e., from left to right, then right to left for the next level and alternate between).\n\n**Example 1:**\n\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** \\[\\[3\\],\\[20,9\\],\\[15,7\\]\\]\n\n**Example 2:**\n\n**Input:** root = \\[1\\]\n**Output:** \\[\\[1\\]\\]\n\n**Example 3:**\n\n**Input:** root = \\[\\]\n**Output:** \\[\\]\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 2000]`.\n*   `-100 <= Node.val <= 100`", "entry_point": "binary_tree_zigzag_level_order_traversal", "canonical_solutions": {"python": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef zigzagLevelOrder(root):\n    if not root:\n        return []\n\n    result = []\n    queue = [root]\n    zigzag = False\n\n    while queue:\n        level = []\n        for i in range(len(queue)):\n            node = queue.pop(0)\n\n            if zigzag:\n                level.insert(0, node.val)\n            else:\n                level.append(node.val)\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n        result.append(level)\n        zigzag = not zigzag\n\n    return result", "java": "import java.util.*;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n}\n\npublic List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n    if (root == null) return new ArrayList<>();\n\n    List<List<Integer>> result = new ArrayList<>();\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.offer(root);\n    boolean zigzag = false;\n\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n        List<Integer> level = new ArrayList<>(size);\n\n        for (int i = 0; i < size; i++) {\n            TreeNode node = queue.poll();\n            if (zigzag) level.add(0, node.val);\n            else level.add(node.val);\n\n            if (node.left != null) queue.offer(node.left);\n            if (node.right != null) queue.offer(node.right);\n        }\n\n        zigzag = !zigzag;\n        result.add(level);\n    }\n\n    return result;\n}", "cpp": "#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n};\n\nvector<vector<int>> zigzagLevelOrder(TreeNode* root) {\n    if (!root) return {};\n\n    vector<vector<int>> result;\n    queue<TreeNode*> q;\n    q.push(root);\n    bool zigzag = false;\n\n    while (!q.empty()) {\n        int size = q.size();\n        vector<int> level(size);\n\n        for (int i = 0; i < size; i++) {\n            TreeNode* node = q.front();\n            q.pop();\n\n            int index = (zigzag) ? (size - 1 - i) : i;\n            level[index] = node->val;\n\n            if (node->left) q.push(node->left);\n            if (node->right) q.push(node->right);\n        }\n        \n        zigzag = !zigzag;\n        result.push_back(move(level));\n    }\n\n    return result;\n}", "javascript": "class TreeNode {\n    constructor(val, left, right) {\n        this.val = (val === undefined ? 0 : val);\n        this.left = (left === undefined ? null : left);\n        this.right = (right === undefined ? null : right);\n    }\n}\n\nfunction zigzagLevelOrder(root) {\n    if (!root) return [];\n\n    const result = [];\n    let queue = [root];\n    let zigzag = false;\n\n    while (queue.length) {\n        const level = [];\n        const queueLen = queue.length;\n        const tempQueue = [];\n\n        for (let i = 0; i < queueLen; i++) {\n            const node = queue[i];\n\n            if (zigzag) level.unshift(node.val);\n            else level.push(node.val);\n\n            if (node.left) tempQueue.push(node.left);\n            if (node.right) tempQueue.push(node.right);\n        }\n\n        zigzag = !zigzag;\n        queue = tempQueue;\n        result.push(level);\n    }\n    \n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/104", "prompt": "Given the `root` of a binary tree, return _its maximum depth_.\n\nA binary tree's **maximum depth** is the number of nodes along the longest path from the root node down to the farthest leaf node.\n\n**Example 1:**\n\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** 3\n\n**Example 2:**\n\n**Input:** root = \\[1,null,2\\]\n**Output:** 2\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 104]`.\n*   `-100 <= Node.val <= 100`", "entry_point": "maximum_depth_of_binary_tree", "canonical_solutions": {"python": "def maxDepth(root):\n    if root is None:\n        return 0\n    return 1 + max(maxDepth(root.left), maxDepth(root.right))", "java": "public int maxDepth(TreeNode root) {\n    if (root == null) {\n        return 0;\n    }\n    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n}", "cpp": "int maxDepth(TreeNode* root) {\n    if (root == nullptr) {\n        return 0;\n    }\n    return 1 + max(maxDepth(root->left), maxDepth(root->right));\n}", "javascript": "function maxDepth(root) {\n    if (root === null) {\n        return 0;\n    }\n    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/105", "prompt": "Given two integer arrays `preorder` and `inorder` where `preorder` is the preorder traversal of a binary tree and `inorder` is the inorder traversal of the same tree, construct and return _the binary tree_.\n\n**Example 1:**\n\n**Input:** preorder = \\[3,9,20,15,7\\], inorder = \\[9,3,15,20,7\\]\n**Output:** \\[3,9,20,null,null,15,7\\]\n\n**Example 2:**\n\n**Input:** preorder = \\[-1\\], inorder = \\[-1\\]\n**Output:** \\[-1\\]\n\n**Constraints:**\n\n*   `1 <= preorder.length <= 3000`\n*   `inorder.length == preorder.length`\n*   `-3000 <= preorder[i], inorder[i] <= 3000`\n*   `preorder` and `inorder` consist of **unique** values.\n*   Each value of `inorder` also appears in `preorder`.\n*   `preorder` is **guaranteed** to be the preorder traversal of the tree.\n*   `inorder` is **guaranteed** to be the inorder traversal of the tree.", "entry_point": "construct_binary_tree_from_preorder_and_inorder_traversal", "canonical_solutions": {"python": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef build_tree(preorder, inorder):\n    def construct_tree(in_left, in_right):\n        nonlocal pre_idx\n        if in_left > in_right:\n            return None\n\n        root_val = preorder[pre_idx]\n        root = TreeNode(root_val)\n        idx = in_map[root_val]\n\n        pre_idx += 1\n        root.left = construct_tree(in_left, idx - 1)\n        root.right = construct_tree(idx + 1, in_right)\n\n        return root\n\n    in_map = {val: idx for idx, val in enumerate(inorder)}\n    pre_idx = 0\n    return construct_tree(0, len(inorder) - 1)", "java": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nclass Solution {\n    private int pre_idx = 0;\n    private int[] preorder;\n    private int[] inorder;\n    private Map<Integer, Integer> in_map = new HashMap<>();\n\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        this.preorder = preorder;\n        this.inorder = inorder;\n        for (int i = 0; i < inorder.length; i++) {\n            in_map.put(inorder[i], i);\n        }\n        return constructTree(0, inorder.length - 1);\n    }\n\n    private TreeNode constructTree(int in_left, int in_right) {\n        if (in_left > in_right) return null;\n        \n        int root_val = preorder[pre_idx];\n        TreeNode root = new TreeNode(root_val);\n        int idx = in_map.get(root_val);\n\n        pre_idx++;\n        root.left = constructTree(in_left, idx - 1);\n        root.right = constructTree(idx + 1, in_right);\n\n        return root;\n    }\n}", "cpp": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nTreeNode* buildTree(vector<int>& preorder, vector<int>& inorder, unordered_map<int, int>& in_map, int& pre_idx, int in_left, int in_right) {\n    if (in_left > in_right) return nullptr;\n\n    int root_val = preorder[pre_idx];\n    TreeNode* root = new TreeNode(root_val);\n    int idx = in_map[root_val];\n\n    pre_idx++;\n    root->left = buildTree(preorder, inorder, in_map, pre_idx, in_left, idx - 1);\n    root->right = buildTree(preorder, inorder, in_map, pre_idx, idx + 1, in_right);\n\n    return root;\n}\n\nTreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n    unordered_map<int, int> in_map;\n    int pre_idx = 0;\n    for (int i =  0; i < inorder.size(); i++) {\n        in_map[inorder[i]] = i;\n    }\n    return buildTree(preorder, inorder, in_map, pre_idx, 0, inorder.size() - 1);\n}", "javascript": "class TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction buildTree(preorder, inorder) {\n    const in_map = new Map();\n    for (let i = 0; i < inorder.length; i++) {\n        in_map.set(inorder[i], i);\n    }\n\n    let pre_idx = 0;\n    function constructTree(in_left, in_right) {\n        if (in_left > in_right) return null;\n\n        const root_val = preorder[pre_idx];\n        const root = new TreeNode(root_val);\n        const idx = in_map.get(root_val);\n\n        pre_idx++;\n        root.left = constructTree(in_left, idx - 1);\n        root.right = constructTree(idx + 1, in_right);\n\n        return root;\n    }\n\n    return constructTree(0, inorder.length - 1);\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/106", "prompt": "Given two integer arrays `inorder` and `postorder` where `inorder` is the inorder traversal of a binary tree and `postorder` is the postorder traversal of the same tree, construct and return _the binary tree_.\n\n**Example 1:**\n\n**Input:** inorder = \\[9,3,15,20,7\\], postorder = \\[9,15,7,20,3\\]\n**Output:** \\[3,9,20,null,null,15,7\\]\n\n**Example 2:**\n\n**Input:** inorder = \\[-1\\], postorder = \\[-1\\]\n**Output:** \\[-1\\]\n\n**Constraints:**\n\n*   `1 <= inorder.length <= 3000`\n*   `postorder.length == inorder.length`\n*   `-3000 <= inorder[i], postorder[i] <= 3000`\n*   `inorder` and `postorder` consist of **unique** values.\n*   Each value of `postorder` also appears in `inorder`.\n*   `inorder` is **guaranteed** to be the inorder traversal of the tree.\n*   `postorder` is **guaranteed** to be the postorder traversal of the tree.", "entry_point": "construct_binary_tree_from_inorder_and_postorder_traversal", "canonical_solutions": {"python": "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def buildTree(self, inorder, postorder):\n        def _build(in_left, in_right, post_root):\n            if in_left > in_right:\n                return None\n            \n            root = TreeNode(postorder[post_root])\n\n            inorder_root_index = index_map[root.val]\n            left_tree_size = inorder_root_index - in_left\n\n            root.left = _build(in_left, inorder_root_index - 1, post_root - 1 - in_right + inorder_root_index)\n            root.right = _build(inorder_root_index + 1, in_right, post_root - 1)\n\n            return root\n\n        index_map = {val: i for i, val in enumerate(inorder)}\n        return _build(0, len(inorder) - 1, len(postorder) - 1)", "java": "import java.util.HashMap;\n\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\nclass Solution {\n    private HashMap<Integer, Integer> indexMap;\n\n    private TreeNode buildTree(int[] inorder, int[] postorder, int in_left, int in_right, int post_root) {\n        if (in_left > in_right)\n            return null;\n        \n        TreeNode root = new TreeNode(postorder[post_root]);\n\n        int inorder_root_index = indexMap.get(root.val);\n        int left_tree_size = inorder_root_index - in_left;\n\n        root.left = buildTree(inorder, postorder, in_left, inorder_root_index - 1, post_root - 1 - in_right + inorder_root_index);\n        root.right = buildTree(inorder, postorder, inorder_root_index + 1, in_right, post_root - 1);\n\n        return root;\n    }\n\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        int n = inorder.length;\n        indexMap = new HashMap<>();\n        for (int i = 0; i < n; ++i) {\n            indexMap.put(inorder[i], i);\n        }\n        return buildTree(inorder, postorder, 0, n - 1, n - 1);\n    }\n}", "cpp": "#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\n    unordered_map<int, int> index_map;\n\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder, int in_left, int in_right, int post_root) {\n        if (in_left > in_right)\n            return nullptr;\n        \n        TreeNode* root = new TreeNode(postorder[post_root]);\n\n        int inorder_root_index = index_map[root->val];\n        int left_tree_size = inorder_root_index - in_left;\n\n        root->left = buildTree(inorder, postorder, in_left, inorder_root_index - 1, post_root - 1 - in_right + inorder_root_index);\n        root->right = buildTree(inorder, postorder, inorder_root_index + 1, in_right, post_root - 1);\n\n        return root;\n    }\n\npublic:\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        int n = inorder.size();\n        for (int i = 0; i < n; ++i) {\n            index_map[inorder[i]] = i;\n        }\n        return buildTree(inorder, postorder, 0, n - 1, n - 1);\n    }\n};", "javascript": "class TreeNode {\n    constructor(val) {\n        this.val = val;\n        this.left = null;\n        this.right = null;\n    }\n}\n\nfunction buildTree(inorder, postorder) {\n    const indexMap = new Map();\n    inorder.forEach((val, index) => {\n        indexMap.set(val, index);\n    });\n\n    function _build(in_left, in_right, post_root) {\n        if (in_left > in_right) {\n            return null;\n        }\n\n        const root = new TreeNode(postorder[post_root]);\n        const inorder_root_index = indexMap.get(root.val);\n        const left_tree_size = inorder_root_index - in_left;\n\n        root.left = _build(in_left, inorder_root_index - 1, post_root - 1 - in_right + inorder_root_index);\n        root.right = _build(inorder_root_index + 1, in_right, post_root - 1);\n\n        return root;\n    }\n\n    return _build(0, inorder.length - 1, postorder.length - 1)\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/107", "prompt": "Given the `root` of a binary tree, return _the bottom-up level order traversal of its nodes' values_. (i.e., from left to right, level by level from leaf to root).\n\n**Example 1:**\n\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** \\[\\[15,7\\],\\[9,20\\],\\[3\\]\\]\n\n**Example 2:**\n\n**Input:** root = \\[1\\]\n**Output:** \\[\\[1\\]\\]\n\n**Example 3:**\n\n**Input:** root = \\[\\]\n**Output:** \\[\\]\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 2000]`.\n*   `-1000 <= Node.val <= 1000`", "entry_point": "binary_tree_level_order_traversal_ii", "canonical_solutions": {"python": "from collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef levelOrderBottom(root):\n    result = []\n    if not root:\n        return result\n\n    queue = deque([root])\n\n    while queue:\n        level = []\n        size = len(queue)\n\n        for i in range(size):\n            current = queue.popleft()\n            level.append(current.val)\n\n            if current.left:\n                queue.append(current.left)\n            if current.right:\n                queue.append(current.right)\n\n        result.insert(0, level)\n\n    return result", "java": "import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic List<List<Integer>> levelOrderBottom(TreeNode root) {\n    List<List<Integer>> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.add(root);\n\n    while (!queue.isEmpty()) {\n        List<Integer> level = new ArrayList<>();\n        int size = queue.size();\n\n        for (int i = 0; i < size; i++) {\n            TreeNode current = queue.poll();\n            level.add(current.val);\n\n            if (current.left != null) queue.add(current.left);\n            if (current.right != null) queue.add(current.right);\n        }\n        result.add(0, level);\n    }\n\n    return result;\n}", "cpp": "#include <vector>\n#include <queue>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nstd::vector<std::vector<int>> levelOrderBottom(TreeNode* root) {\n    std::vector<std::vector<int>> result;\n    if (root == nullptr) return result;\n\n    std::queue<TreeNode*> q;\n    q.push(root);\n\n    while (!q.empty()) {\n        std::vector<int> level;\n        int size = q.size();\n\n        for (int i = 0; i < size; i++) {\n            TreeNode* current = q.front();\n            q.pop();\n            level.push_back(current->val);\n\n            if (current->left) q.push(current->left);\n            if (current->right) q.push(current->right);\n        }\n        result.insert(result.begin(), level);\n    }\n\n    return result;\n}", "javascript": "class TreeNode {\n    constructor(val = 0, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction levelOrderBottom(root) {\n    const result = [];\n    if (!root) return result;\n\n    const queue = [root];\n\n    while (queue.length > 0) {\n        const level = [];\n        const size = queue.length;\n\n        for (let i = 0; i < size; i++) {\n            const current = queue.shift();\n            level.push(current.val);\n\n            if (current.left) queue.push(current.left);\n            if (current.right) queue.push(current.right);\n        }\n        result.unshift(level);\n    }\n\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/108", "prompt": "Given an integer array `nums` where the elements are sorted in **ascending order**, convert _it to a_ **_height-balanced_** _binary search tree_.\n\n**Example 1:**\n\n**Input:** nums = \\[-10,-3,0,5,9\\]\n**Output:** \\[0,-3,9,-10,null,5\\]\n**Explanation:** \\[0,-10,5,null,-3,null,9\\] is also accepted:\n \n\n**Example 2:**\n\n**Input:** nums = \\[1,3\\]\n**Output:** \\[3,1\\]\n**Explanation:** \\[1,null,3\\] and \\[3,1\\] are both height-balanced BSTs.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-104 <= nums[i] <= 104`\n*   `nums` is sorted in a **strictly increasing** order.", "entry_point": "convert_sorted_array_to_binary_search_tree", "canonical_solutions": {"python": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef sorted_array_to_bst(nums):\n    def helper(start, end):\n        if start > end:\n            return None\n\n        mid = start + (end - start) // 2\n        node = TreeNode(nums[mid])\n        node.left = helper(start, mid - 1)\n        node.right = helper(mid + 1, end)\n\n        return node\n\n    return helper(0, len(nums) - 1)", "java": "public class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic TreeNode sortedArrayToBST(int[] nums) {\n    return sortedArrayToBST(nums, 0, nums.length - 1);\n}\n\nprivate TreeNode sortedArrayToBST(int[] nums, int start, int end) {\n    if (start > end) return null;\n\n    int mid = start + (end - start) / 2;\n    TreeNode node = new TreeNode(nums[mid]);\n    node.left = sortedArrayToBST(nums, start, mid - 1);\n    node.right = sortedArrayToBST(nums, mid + 1, end);\n\n    return node;\n}", "cpp": "#include <vector>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nTreeNode* sortedArrayToBST(std::vector<int>& nums, int start, int end) {\n    if (start > end) return nullptr;\n\n    int mid = start + (end - start) / 2;\n    TreeNode* node = new TreeNode(nums[mid]);\n    node->left = sortedArrayToBST(nums, start, mid - 1);\n    node->right = sortedArrayToBST(nums, mid + 1, end);\n\n    return node;\n}\n\nTreeNode* sortedArrayToBST(std::vector<int>& nums) {\n    return sortedArrayToBST(nums, 0, nums.size() - 1);\n}", "javascript": "class TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction sortedArrayToBST(nums, start = 0, end = nums.length - 1) {\n    if (start > end) return null;\n\n    let mid = start + Math.floor((end - start) / 2);\n    let node = new TreeNode(nums[mid]);\n    node.left = sortedArrayToBST(nums, start, mid - 1);\n    node.right = sortedArrayToBST(nums, mid + 1, end);\n\n    return node;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/109", "prompt": "Given the `head` of a singly linked list where elements are sorted in **ascending order**, convert _it to a_ **_height-balanced_** _binary search tree_.\n\n**Example 1:**\n\n**Input:** head = \\[-10,-3,0,5,9\\]\n**Output:** \\[0,-3,9,-10,null,5\\]\n**Explanation:** One possible answer is \\[0,-3,9,-10,null,5\\], which represents the shown height balanced BST.\n\n**Example 2:**\n\n**Input:** head = \\[\\]\n**Output:** \\[\\]\n\n**Constraints:**\n\n*   The number of nodes in `head` is in the range `[0, 2 * 104]`.\n*   `-105 <= Node.val <= 105`", "entry_point": "convert_sorted_list_to_binary_search_tree", "canonical_solutions": {"python": "class ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef sortedListToBST(head):\n    if not head:\n        return None\n    if not head.next:\n        return TreeNode(head.val)\n    slow = head\n    fast = head\n    prev = None\n\n    while fast and fast.next:\n        prev = slow\n        slow = slow.next\n        fast = fast.next.next\n\n    prev.next = None\n\n    root = TreeNode(slow.val)\n    root.left = sortedListToBST(head)\n    root.right = sortedListToBST(slow.next)\n    return root", "java": "public class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) { val = x; }\n}\n\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic TreeNode sortedListToBST(ListNode head) {\n    if (head == null) return null;\n    if (head.next == null) return new TreeNode(head.val);\n    ListNode slow = head;\n    ListNode fast = head;\n    ListNode prev = null;\n\n    while (fast != null && fast.next != null) {\n        prev = slow;\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n\n    prev.next = null;\n\n    TreeNode root = new TreeNode(slow.val);\n    root.left = sortedListToBST(head);\n    root.right = sortedListToBST(slow.next);\n    return root;\n}", "cpp": "class TreeNode {\npublic:\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass ListNode {\npublic:\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nTreeNode* sortedListToBST(ListNode* head) {\n    if (!head) return NULL;\n    if (!head->next) return new TreeNode(head->val);\n    ListNode* slow = head;\n    ListNode* fast = head;\n    ListNode* prev = NULL;\n\n    while (fast && fast->next) {\n        prev = slow;\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n\n    prev->next = NULL;\n\n    TreeNode* root = new TreeNode(slow->val);\n    root->left = sortedListToBST(head);\n    root->right = sortedListToBST(slow->next);\n    return root;\n}", "javascript": "class ListNode {\n    constructor(val, next = null) {\n        this.val = val;\n        this.next = next;\n    }\n}\n\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction sortedListToBST(head) {\n    if (!head) return null;\n    if (!head.next) return new TreeNode(head.val);\n\n    let slow = head;\n    let fast = head;\n    let prev = null;\n\n    while (fast && fast.next) {\n        prev = slow;\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n\n    prev.next = null;\n\n    const root = new TreeNode(slow.val);\n    root.left = sortedListToBST(head);\n    root.right = sortedListToBST(slow.next);\n    return root;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/110", "prompt": "Given a binary tree, determine if it is **height-balanced**.\n\n**Example 1:**\n\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** true\n\n**Example 2:**\n\n**Input:** root = \\[1,2,2,3,3,null,null,4,4\\]\n**Output:** false\n\n**Example 3:**\n\n**Input:** root = \\[\\]\n**Output:** true\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 5000]`.\n*   `-104 <= Node.val <= 104`", "entry_point": "balanced_binary_tree", "canonical_solutions": {"python": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef getHeight(node):\n    if not node:\n        return 0\n    left_height = getHeight(node.left)\n    right_height = getHeight(node.right)\n    if left_height == -1 or right_height == -1 or abs(left_height - right_height) > 1:\n        return -1\n    return 1 + max(left_height, right_height)\n\ndef isBalanced(root):\n    return getHeight(root) != -1", "java": "class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n}\n\npublic int getHeight(TreeNode node) {\n    if (node == null) return 0;\n    int leftHeight = getHeight(node.left);\n    int rightHeight = getHeight(node.right);\n    if (leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight - rightHeight) > 1)\n        return -1;\n    return 1 + Math.max(leftHeight, rightHeight);\n}\n\npublic boolean isBalanced(TreeNode root) {\n    return getHeight(root) != -1;\n}", "cpp": "struct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n};\n\nint getHeight(TreeNode* node) {\n    if (!node) return 0;\n    int leftHeight = getHeight(node->left);\n    int rightHeight = getHeight(node->right);\n    if (leftHeight == -1 || rightHeight == -1 || abs(leftHeight - rightHeight) > 1)\n        return -1;\n    return 1 + max(leftHeight, rightHeight);\n}\n\nbool isBalanced(TreeNode* root) {\n    return getHeight(root) != -1;\n}", "javascript": "class TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction getHeight(node) {\n    if (!node) return 0;\n    let leftHeight = getHeight(node.left);\n    let rightHeight = getHeight(node.right);\n    if (leftHeight === -1 || rightHeight === -1 || Math.abs(leftHeight - rightHeight) > 1)\n        return -1;\n    return 1 + Math.max(leftHeight, rightHeight);\n}\n\nfunction isBalanced(root) {\n    return getHeight(root) !== -1;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/111", "prompt": "Given a binary tree, find its minimum depth.\n\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\n\n**Note:** A leaf is a node with no children.\n\n**Example 1:**\n\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** 2\n\n**Example 2:**\n\n**Input:** root = \\[2,null,3,null,4,null,5,null,6\\]\n**Output:** 5\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 105]`.\n*   `-1000 <= Node.val <= 1000`", "entry_point": "minimum_depth_of_binary_tree", "canonical_solutions": {"python": "def minDepth(root):\n    if not root:\n        return 0\n    left = minDepth(root.left)\n    right = minDepth(root.right)\n    return (left == 0 or right == 0) and left + right + 1 or min(left, right) + 1", "java": "public int minDepth(TreeNode root) {\n    if (root == null) return 0;\n    int left = minDepth(root.left);\n    int right = minDepth(root.right);\n    return (left == 0 || right == 0) ? left + right + 1 : Math.min(left, right) + 1;\n}", "cpp": "int minDepth(TreeNode* root) {\n    if (!root) return 0;\n    int left = minDepth(root->left);\n    int right = minDepth(root->right);\n    return (left == 0 || right == 0) ? left + right + 1 : min(left, right) + 1;\n}", "javascript": "function minDepth(root) {\n    if (!root) return 0;\n    let left = minDepth(root.left);\n    let right = minDepth(root.right);\n    return (left === 0 || right === 0) ? left + right + 1 : Math.min(left, right) + 1;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/112", "prompt": "Given the `root` of a binary tree and an integer `targetSum`, return `true` if the tree has a **root-to-leaf** path such that adding up all the values along the path equals `targetSum`.\n\nA **leaf** is a node with no children.\n\n**Example 1:**\n\n**Input:** root = \\[5,4,8,11,null,13,4,7,2,null,null,null,1\\], targetSum = 22\n**Output:** true\n**Explanation:** The root-to-leaf path with the target sum is shown.\n\n**Example 2:**\n\n**Input:** root = \\[1,2,3\\], targetSum = 5\n**Output:** false\n**Explanation:** There two root-to-leaf paths in the tree:\n(1 --> 2): The sum is 3.\n(1 --> 3): The sum is 4.\nThere is no root-to-leaf path with sum = 5.\n\n**Example 3:**\n\n**Input:** root = \\[\\], targetSum = 0\n**Output:** false\n**Explanation:** Since the tree is empty, there are no root-to-leaf paths.\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 5000]`.\n*   `-1000 <= Node.val <= 1000`\n*   `-1000 <= targetSum <= 1000`", "entry_point": "path_sum", "canonical_solutions": {"python": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef hasPathSum(root, targetSum):\n    if root is None:\n        return False\n    if root.left is None and root.right is None:\n        return targetSum - root.val == 0\n    return hasPathSum(root.left, targetSum - root.val) or hasPathSum(root.right, targetSum - root.val)", "java": "public class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n}\n\npublic boolean hasPathSum(TreeNode root, int targetSum) {\n    if (root == null) return false;\n    if (root.left == null && root.right == null) return targetSum - root.val == 0;\n    return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\n}", "cpp": "struct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n};\n\nbool hasPathSum(TreeNode* root, int targetSum) {\n    if (!root) return false;\n    if (!root->left && !root->right) return targetSum - root->val == 0;\n    return hasPathSum(root->left, targetSum - root->val) || hasPathSum(root->right, targetSum - root->val);\n}", "javascript": "class TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction hasPathSum(root, targetSum) {\n    if (!root) return false;\n    if (!root.left && !root.right) return targetSum - root.val === 0;\n    return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/113", "prompt": "Given the `root` of a binary tree and an integer `targetSum`, return _all **root-to-leaf** paths where the sum of the node values in the path equals_ `targetSum`_. Each path should be returned as a list of the node **values**, not node references_.\n\nA **root-to-leaf** path is a path starting from the root and ending at any leaf node. A **leaf** is a node with no children.\n\n**Example 1:**\n\n**Input:** root = \\[5,4,8,11,null,13,4,7,2,null,null,5,1\\], targetSum = 22\n**Output:** \\[\\[5,4,11,2\\],\\[5,8,4,5\\]\\]\n**Explanation:** There are two paths whose sum equals targetSum:\n5 + 4 + 11 + 2 = 22\n5 + 8 + 4 + 5 = 22\n\n**Example 2:**\n\n**Input:** root = \\[1,2,3\\], targetSum = 5\n**Output:** \\[\\]\n\n**Example 3:**\n\n**Input:** root = \\[1,2\\], targetSum = 0\n**Output:** \\[\\]\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 5000]`.\n*   `-1000 <= Node.val <= 1000`\n*   `-1000 <= targetSum <= 1000`", "entry_point": "path_sum_ii", "canonical_solutions": {"python": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef pathSum(root, targetSum):\n    def helper(root, targetSum, current, ans):\n        if not root:\n            return\n        current.append(root.val)\n        if not root.left and not root.right and targetSum == root.val:\n            ans.append(current[:])\n        helper(root.left, targetSum - root.val, current, ans)\n        helper(root.right, targetSum - root.val, current, ans)\n        current.pop()\n\n    ans = []\n    helper(root, targetSum, [], ans)\n    return ans", "java": "import java.util.List;\nimport java.util.ArrayList;\n\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic List<List<Integer>> pathSum(TreeNode root, int targetSum) {\n    List<List<Integer>> ans = new ArrayList<>();\n    List<Integer> current = new ArrayList<>();\n    helper(root, targetSum, current, ans);\n    return ans;\n}\n\nprivate void helper(TreeNode root, int targetSum, List<Integer> current, List<List<Integer>> ans) {\n    if (root == null) return;\n    current.add(root.val);\n    if (root.left == null && root.right == null && targetSum == root.val) {\n        ans.add(new ArrayList<>(current));\n    }\n    helper(root.left, targetSum - root.val, current, ans);\n    helper(root.right, targetSum - root.val, current, ans);\n    current.remove(current.size() - 1);\n}", "cpp": "struct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nvoid helper(TreeNode* root, int targetSum, vector<int>& current, vector<vector<int>>& ans) {\n    if (!root) return;\n    current.push_back(root->val);\n    if (!root->left && !root->right && targetSum == root->val) {\n        ans.push_back(current);\n    }\n    helper(root->left, targetSum - root->val, current, ans);\n    helper(root->right, targetSum - root->val, current, ans);\n    current.pop_back();\n}\n\nvector<vector<int>> pathSum(TreeNode* root, int targetSum) {\n    vector<vector<int>> ans;\n    vector<int> current;\n    helper(root, targetSum, current, ans);\n    return ans;\n}", "javascript": "class TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction pathSum(root, targetSum) {\n    const ans = [];\n    const helper = (root, targetSum, current) => {\n        if (!root) return;\n        current.push(root.val);\n        if (!root.left && !root.right && targetSum === root.val) {\n            ans.push([...current]);\n        }\n        helper(root.left, targetSum - root.val, current);\n        helper(root.right, targetSum - root.val, current);\n        current.pop();\n    };\n\n    helper(root, targetSum, []);\n    return ans;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/114", "prompt": "Given the `root` of a binary tree, flatten the tree into a \"linked list \":\n\n*   The \"linked list \" should use the same `TreeNode` class where the `right` child pointer points to the next node in the list and the `left` child pointer is always `null`.\n*   The \"linked list \" should be in the same order as a [**pre-order** **traversal**](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR) of the binary tree.\n\n**Example 1:**\n\n**Input:** root = \\[1,2,5,3,4,null,6\\]\n**Output:** \\[1,null,2,null,3,null,4,null,5,null,6\\]\n\n**Example 2:**\n\n**Input:** root = \\[\\]\n**Output:** \\[\\]\n\n**Example 3:**\n\n**Input:** root = \\[0\\]\n**Output:** \\[0\\]\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 2000]`.\n*   `-100 <= Node.val <= 100`\n\n**Follow up:** Can you flatten the tree in-place (with `O(1)` extra space)?", "entry_point": "flatten_binary_tree_to_linked_list", "canonical_solutions": {"python": "def flatten(root):\n    if not root:\n        return\n    flatten(root.left)\n    flatten(root.right)\n    if root.left:\n        temp = root.right\n        root.right = root.left\n        root.left = None\n        while root.right:\n            root = root.right\n        root.right = temp", "java": "public void flatten(TreeNode root) {\n    if (root == null) return;\n    flatten(root.left);\n    flatten(root.right);\n    if (root.left != null) {\n        TreeNode temp = root.right;\n        root.right = root.left;\n        root.left = null;\n        while (root.right != null) root = root.right;\n        root.right = temp;\n    }\n}", "cpp": "void flatten(TreeNode* root) {\n    if (!root) return;\n    flatten(root->left);\n    flatten(root->right);\n    if (root->left) {\n        TreeNode* temp = root->right;\n        root->right = root->left;\n        root->left = nullptr;\n        while (root->right) root = root->right;\n        root->right = temp;\n    }\n}", "javascript": "function flatten(root) {\n    if (!root) return;\n    flatten(root.left);\n    flatten(root.right);\n    if (root.left) {\n        let temp = root.right;\n        root.right = root.left;\n        root.left = null;\n        while (root.right) root = root.right;\n        root.right = temp;\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/115", "prompt": "Given two strings `s` and `t`, return _the number of distinct_ **_subsequences_** _of_ `s` _which equals_ `t`.\n\nThe test cases are generated so that the answer fits on a 32-bit signed integer.\n\n**Example 1:**\n\n**Input:** s =  \"rabbbit \", t =  \"rabbit \"\n**Output:** 3\n**Explanation:**\nAs shown below, there are 3 ways you can generate  \"rabbit \" from s.\n`**rabb**b**it**`\n`**ra**b**bbit**`\n`**rab**b**bit**`\n\n**Example 2:**\n\n**Input:** s =  \"babgbag \", t =  \"bag \"\n**Output:** 5\n**Explanation:**\nAs shown below, there are 5 ways you can generate  \"bag \" from s.\n`**ba**b**g**bag`\n`**ba**bgba**g**`\n`**b**abgb**ag**`\n`ba**b**gb**ag**`\n`babg**bag**`\n\n**Constraints:**\n\n*   `1 <= s.length, t.length <= 1000`\n*   `s` and `t` consist of English letters.", "entry_point": "distinct_subsequences", "canonical_solutions": {"python": "def numDistinct(s: str, t: str) -> int:\n    m, n = len(s), len(t)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        dp[i][0] = 1\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[m][n]", "java": "public int numDistinct(String s, String t) {\n    int m = s.length(), n = t.length();\n    int[][] dp = new int[m + 1][n + 1];\n\n    for (int i = 0; i <= m; i++) {\n        dp[i][0] = 1;\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (s.charAt(i - 1) == t.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            } else {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n\n    return dp[m][n];\n}", "cpp": "int numDistinct(string s, string t) {\n    int m = s.size(), n = t.size();\n    vector<vector<unsigned int>> dp(m + 1, vector<unsigned int>(n + 1, 0));\n\n    for (int i = 0; i <= m; i++) {\n        dp[i][0] = 1;\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (s[i - 1] == t[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            } else {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n\n    return dp[m][n];\n}", "javascript": "function numDistinct(s, t) {\n    const m = s.length, n = t.length;\n    const dp = Array.from({length: m + 1}, () => Array(n + 1).fill(0));\n\n    for (let i = 0; i <= m; i++) {\n        dp[i][0] = 1;\n    }\n\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (s[i - 1] === t[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            } else {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n\n    return dp[m][n];\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/116", "prompt": "You are given a **perfect binary tree** where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:\n\nstruct Node {\n  int val;\n  Node \\*left;\n  Node \\*right;\n  Node \\*next;\n}\n\nPopulate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to `NULL`.\n\nInitially, all next pointers are set to `NULL`.\n\n**Example 1:**\n\n**Input:** root = \\[1,2,3,4,5,6,7\\]\n**Output:** \\[1,#,2,3,#,4,5,6,7,#\\]\n**Explanation:** Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level.\n\n**Example 2:**\n\n**Input:** root = \\[\\]\n**Output:** \\[\\]\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 212 - 1]`.\n*   `-1000 <= Node.val <= 1000`\n\n**Follow-up:**\n\n*   You may only use constant extra space.\n*   The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.", "entry_point": "populating_next_right_pointers_in_each_node", "canonical_solutions": {"python": "def connect(self, root: 'Node') -> 'Node':\n    if not root or not root.left:\n        return root\n    root.left.next = root.right\n    if root.next:\n        root.right.next = root.next.left\n    self.connect(root.left)\n    self.connect(root.right)\n    return root", "java": "public void connect(TreeLinkNode root) {\n    if (root == null || root.left == null) return;\n    root.left.next = root.right;\n    if (root.next != null) {\n        root.right.next = root.next.left;\n    }\n    connect(root.left);\n    connect(root.right);\n}", "cpp": "void connect(Node* root) {\n    if (!root) return;\n    if (root->left) {\n        root->left->next = root->right;\n        if (root->next) {\n            root->right->next = root->next->left;\n        }\n    }\n    connect(root->left);\n    connect(root->right);\n}", "javascript": "function connect(root) {\n    if (root === null || root.left === null) return root;\n    root.left.next = root.right;\n    if (root.next !== null) {\n        root.right.next = root.next.left;\n    }\n    connect(root.left);\n    connect(root.right);\n    return root;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/117", "prompt": "Given a binary tree\n\nstruct Node {\n  int val;\n  Node \\*left;\n  Node \\*right;\n  Node \\*next;\n}\n\nPopulate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to `NULL`.\n\nInitially, all next pointers are set to `NULL`.\n\n**Example 1:**\n\n**Input:** root = \\[1,2,3,4,5,null,7\\]\n**Output:** \\[1,#,2,3,#,4,5,7,#\\]\n**Explanation:** Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level.\n\n**Example 2:**\n\n**Input:** root = \\[\\]\n**Output:** \\[\\]\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 6000]`.\n*   `-100 <= Node.val <= 100`\n\n**Follow-up:**\n\n*   You may only use constant extra space.\n*   The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.", "entry_point": "populating_next_right_pointers_in_each_node_ii", "canonical_solutions": {"python": "class Node:\n    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\ndef connect(root: 'Node') -> 'Node':\n    if not root:\n        return None\n\n    q = [root]\n\n    while q:\n        level_size = len(q)\n        prev = None\n\n        for i in range(level_size):\n            current_node = q.pop(0)\n\n            if prev:\n                prev.next = current_node\n            prev = current_node\n\n            if current_node.left:\n                q.append(current_node.left)\n            if current_node.right:\n                q.append(current_node.right)\n\n    return root", "java": "import java.util.Queue;\nimport java.util.LinkedList;\n\nclass Node {\n    public int val;\n    public Node left;\n    public Node right;\n    public Node next;\n\n    public Node(int _val) {\n        val = _val;\n        left = null;\n        right = null;\n        next = null;\n    }\n}\n\npublic Node connect(Node root) {\n    if (root == null) return null;\n\n    Queue<Node> queue = new LinkedList<>();\n    queue.offer(root);\n\n    while(!queue.isEmpty()) {\n        int levelSize = queue.size();\n        Node prev = null;\n\n        for (int i = 0; i < levelSize; i++) {\n            Node currentNode = queue.poll();\n\n            if (prev != null) prev.next = currentNode;\n            prev = currentNode;\n\n            if(currentNode.left != null) queue.offer(currentNode.left);\n            if(currentNode.right != null) queue.offer(currentNode.right);\n        }\n    }\n\n    return root;\n}", "cpp": "#include <queue>\n\nclass Node {\npublic:\n    int val;\n    Node* left;\n    Node* right;\n    Node* next;\n\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\n};\n\nNode* connect(Node* root) {\n    if (!root) return NULL;\n\n    std::queue<Node*> q;\n    q.push(root);\n\n    while (!q.empty()) {\n        int levelSize = q.size();\n        Node* prev = NULL;\n\n        for (int i = 0; i < levelSize; ++i) {\n            Node* currentNode = q.front();\n            q.pop();\n\n            if (prev) prev->next = currentNode;\n            prev = currentNode;\n\n            if (currentNode->left) q.push(currentNode->left);\n            if (currentNode->right) q.push(currentNode->right);\n        }\n    }\n\n    return root;\n}", "javascript": "class Node {\n    constructor(val, left, right, next) {\n        this.val = val === undefined ? 0 : val;\n        this.left = left === undefined ? null : left;\n        this.right = right === undefined ? null : right;\n        this.next = next === undefined ? null : next;\n    }\n}\n\nfunction connect(root) {\n    if(!root) {\n        return null;\n    }\n\n    const queue = [root];\n\n    while(queue.length) {\n        let levelSize = queue.length;\n        let prev = null;\n\n        for(let i = 0; i < levelSize; i++) {\n            let currentNode = queue.shift();\n\n            if(prev) {\n                prev.next = currentNode;\n            }\n            prev = currentNode;\n\n            if(currentNode.left) queue.push(currentNode.left);\n            if(currentNode.right) queue.push(currentNode.right);\n        }\n    }\n\n    return root;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/118", "prompt": "Given an integer `numRows`, return the first numRows of **Pascal's triangle**.\n\nIn **Pascal's triangle**, each number is the sum of the two numbers directly above it as shown:\n\n**Example 1:**\n\n**Input:** numRows = 5\n**Output:** \\[\\[1\\],\\[1,1\\],\\[1,2,1\\],\\[1,3,3,1\\],\\[1,4,6,4,1\\]\\]\n\n**Example 2:**\n\n**Input:** numRows = 1\n**Output:** \\[\\[1\\]\\]\n\n**Constraints:**\n\n*   `1 <= numRows <= 30`", "entry_point": "pascals_triangle", "canonical_solutions": {"python": "def generate(numRows):\n    pascalsTriangle = []\n    for i in range(numRows):\n        row = [1]\n        if i > 0:\n            for j in range(1, i):\n                row.append(pascalsTriangle[i-1][j-1] + pascalsTriangle[i-1][j])\n            row.append(1)\n        pascalsTriangle.append(row)\n    return pascalsTriangle", "java": "public List<List<Integer>> generate(int numRows) {\n    List<List<Integer>> pascalsTriangle = new ArrayList<>();\n    for (int i = 0; i < numRows; i++) {\n        List<Integer> row = new ArrayList<>();\n        row.add(1);\n        for (int j = 1; j < i; j++) {\n            row.add(pascalsTriangle.get(i - 1).get(j - 1) + pascalsTriangle.get(i - 1).get(j));\n        }\n        if (i > 0) row.add(1);\n        pascalsTriangle.add(row);\n    }\n    return pascalsTriangle;\n}", "cpp": "vector<vector<int>> generate(int numRows) {\n    vector<vector<int>> pascalsTriangle(numRows);\n    for (int i = 0; i < numRows; i++) {\n        pascalsTriangle[i].resize(i + 1);\n        pascalsTriangle[i][0] = pascalsTriangle[i][i] = 1;\n        for (int j = 1; j < i; j++) {\n            pascalsTriangle[i][j] = pascalsTriangle[i - 1][j - 1] + pascalsTriangle[i - 1][j];\n        }\n    }\n    return pascalsTriangle;\n}", "javascript": "function generate(numRows) {\n    const pascalsTriangle = [];\n    for (let i = 0; i < numRows; i++) {\n        const row = [1];\n        for (let j = 1; j < i; j++) {\n            row.push(pascalsTriangle[i - 1][j - 1] + pascalsTriangle[i - 1][j]);\n        }\n        if (i > 0) row.push(1);\n        pascalsTriangle.push(row);\n    }\n    return pascalsTriangle;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/119", "prompt": "Given an integer `rowIndex`, return the `rowIndexth` (**0-indexed**) row of the **Pascal's triangle**.\n\nIn **Pascal's triangle**, each number is the sum of the two numbers directly above it as shown:\n\n**Example 1:**\n\n**Input:** rowIndex = 3\n**Output:** \\[1,3,3,1\\]\n\n**Example 2:**\n\n**Input:** rowIndex = 0\n**Output:** \\[1\\]\n\n**Example 3:**\n\n**Input:** rowIndex = 1\n**Output:** \\[1,1\\]\n\n**Constraints:**\n\n*   `0 <= rowIndex <= 33`\n\n**Follow up:** Could you optimize your algorithm to use only `O(rowIndex)` extra space?", "entry_point": "pascals_triangle_ii", "canonical_solutions": {"python": "def get_row(rowIndex):\n    row = [1] * (rowIndex + 1)\n    for i in range(1, rowIndex + 1):\n        for j in range(i - 1, 0, -1):\n            row[j] += row[j - 1]\n    return row", "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> getRow(int rowIndex) {\n    List<Integer> row = new ArrayList<>();\n    for (int i = 0; i <= rowIndex; i++) {\n        row.add(1);\n        for (int j = i - 1; j > 0; j--) {\n            row.set(j, row.get(j) + row.get(j - 1));\n        }\n    }\n    return row;\n}", "cpp": "#include <vector>\nusing namespace std;\n\nvector<int> getRow(int rowIndex) {\n    vector<int> row(rowIndex + 1, 1);\n    for (int i = 1; i <= rowIndex; i++) {\n        for (int j = i - 1; j > 0; j--) {\n            row[j] += row[j - 1];\n        }\n    }\n    return row;\n}", "javascript": "function getRow(rowIndex) {\n    const row = new Array(rowIndex + 1).fill(1);\n    for (let i = 1; i <= rowIndex; i++) {\n        for (let j = i - 1; j > 0; j--) {\n            row[j] += row[j - 1];\n        }\n    }\n    return row;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/120", "prompt": "Given a `triangle` array, return _the minimum path sum from top to bottom_.\n\nFor each step, you may move to an adjacent number of the row below. More formally, if you are on index `i` on the current row, you may move to either index `i` or index `i + 1` on the next row.\n\n**Example 1:**\n\n**Input:** triangle = \\[\\[2\\],\\[3,4\\],\\[6,5,7\\],\\[4,1,8,3\\]\\]\n**Output:** 11\n**Explanation:** The triangle looks like:\n   2\n  3 4\n 6 5 7\n4 1 8 3\nThe minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).\n\n**Example 2:**\n\n**Input:** triangle = \\[\\[-10\\]\\]\n**Output:** -10\n\n**Constraints:**\n\n*   `1 <= triangle.length <= 200`\n*   `triangle[0].length == 1`\n*   `triangle[i].length == triangle[i - 1].length + 1`\n*   `-104 <= triangle[i][j] <= 104`\n\n**Follow up:** Could you do this using only `O(n)` extra space, where `n` is the total number of rows in the triangle?", "entry_point": "triangle", "canonical_solutions": {"python": "def minimumTotal(triangle):\n    for row in range(len(triangle) - 2, -1, -1):\n        for col in range(len(triangle[row])):\n            triangle[row][col] += min(triangle[row + 1][col], triangle[row + 1][col + 1])\n    return triangle[0][0]", "java": "public int minimumTotal(List<List<Integer>> triangle) {\n    for (int row = triangle.size() - 2; row >= 0; row--) {\n        for (int col = 0; col < triangle.get(row).size(); col++) {\n            int minSum = Math.min(triangle.get(row + 1).get(col), triangle.get(row + 1).get(col + 1));\n            triangle.get(row).set(col, triangle.get(row).get(col) + minSum);\n        }\n    }\n    return triangle.get(0).get(0);\n}", "cpp": "int minimumTotal(vector<vector<int>>& triangle) {\n    for (int row = triangle.size() - 2; row >= 0; row--) {\n        for (int col = 0; col < triangle[row].size(); col++) {\n            triangle[row][col] += min(triangle[row + 1][col], triangle[row + 1][col + 1]);\n        }\n    }\n    return triangle[0][0];\n}", "javascript": "function minimumTotal(triangle) {\n    for (let row = triangle.length - 2; row >= 0; row--) {\n        for (let col = 0; col < triangle[row].length; col++) {\n            triangle[row][col] += Math.min(triangle[row + 1][col], triangle[row + 1][col + 1]);\n        }\n    }\n    return triangle[0][0];\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/121", "prompt": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\n\nYou want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock.\n\nReturn _the maximum profit you can achieve from this transaction_. If you cannot achieve any profit, return `0`.\n\n**Example 1:**\n\n**Input:** prices = \\[7,1,5,3,6,4\\]\n**Output:** 5\n**Explanation:** Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n\n**Example 2:**\n\n**Input:** prices = \\[7,6,4,3,1\\]\n**Output:** 0\n**Explanation:** In this case, no transactions are done and the max profit = 0.\n\n**Constraints:**\n\n*   `1 <= prices.length <= 105`\n*   `0 <= prices[i] <= 104`", "entry_point": "best_time_to_buy_and_sell_stock", "canonical_solutions": {"python": "def maxProfit(prices):\n    minPrice = float('inf')\n    maxProfit = 0\n    for price in prices:\n        minPrice = min(minPrice, price)\n        maxProfit = max(maxProfit, price - minPrice)\n    return maxProfit", "java": "public int maxProfit(int[] prices) {\n    int minPrice = Integer.MAX_VALUE;\n    int maxProfit = 0;\n    for (int price : prices) {\n        minPrice = Math.min(minPrice, price);\n        maxProfit = Math.max(maxProfit, price - minPrice);\n    }\n    return maxProfit;\n}", "cpp": "int maxProfit(vector<int>& prices) {\n    int minPrice = INT_MAX;\n    int maxProfit = 0;\n    for (int price : prices) {\n        minPrice = min(minPrice, price);\n        maxProfit = max(maxProfit, price - minPrice);\n    }\n    return maxProfit;\n}", "javascript": "function maxProfit(prices) {\n    let minPrice = Number.MAX_VALUE;\n    let maxProfit = 0;\n    for (const price of prices) {\n        minPrice = Math.min(minPrice, price);\n        maxProfit = Math.max(maxProfit, price - minPrice);\n    }\n    return maxProfit;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/122", "prompt": "You are given an integer array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold **at most one** share of the stock at any time. However, you can buy it then immediately sell it on the **same day**.\n\nFind and return _the **maximum** profit you can achieve_.\n\n**Example 1:**\n\n**Input:** prices = \\[7,1,5,3,6,4\\]\n**Output:** 7\n**Explanation:** Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\n\n**Example 2:**\n\n**Input:** prices = \\[1,2,3,4,5\\]\n**Output:** 4\n**Explanation:** Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.\n\n**Example 3:**\n\n**Input:** prices = \\[7,6,4,3,1\\]\n**Output:** 0\n**Explanation:** There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.\n\n**Constraints:**\n\n*   `1 <= prices.length <= 3 * 104`\n*   `0 <= prices[i] <= 104`", "entry_point": "best_time_to_buy_and_sell_stock_ii", "canonical_solutions": {"python": "def max_profit(prices):\n    max_profit = 0\n    for i in range(1, len(prices)):\n        if prices[i] > prices[i - 1]:\n            max_profit += prices[i] - prices[i - 1]\n    return max_profit", "java": "public int maxProfit(int[] prices) {\n    int max_profit = 0;\n    for (int i = 1; i < prices.length; i++) {\n        if (prices[i] > prices[i - 1]) {\n            max_profit += prices[i] - prices[i - 1];\n        }\n    }\n    return max_profit;\n}", "cpp": "int maxProfit(vector<int>& prices) {\n    int max_profit = 0;\n    for (int i = 1; i < prices.size(); i++) {\n        if (prices[i] > prices[i - 1]) {\n            max_profit += prices[i] - prices[i - 1];\n        }\n    }\n    return max_profit;\n}", "javascript": "function maxProfit(prices) {\n    let max_profit = 0;\n    for (let i = 1; i < prices.length; i++) {\n        if (prices[i] > prices[i - 1]) {\n            max_profit += prices[i] - prices[i - 1];\n        }\n    }\n    return max_profit;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/123", "prompt": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\n\nFind the maximum profit you can achieve. You may complete **at most two transactions**.\n\n**Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\n**Example 1:**\n\n**Input:** prices = \\[3,3,5,0,0,3,1,4\\]\n**Output:** 6\n**Explanation:** Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\nThen buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.\n\n**Example 2:**\n\n**Input:** prices = \\[1,2,3,4,5\\]\n**Output:** 4\n**Explanation:** Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nNote that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.\n\n**Example 3:**\n\n**Input:** prices = \\[7,6,4,3,1\\]\n**Output:** 0\n**Explanation:** In this case, no transaction is done, i.e. max profit = 0.\n\n**Constraints:**\n\n*   `1 <= prices.length <= 105`\n*   `0 <= prices[i] <= 105`", "entry_point": "best_time_to_buy_and_sell_stock_iii", "canonical_solutions": {"python": "def maxProfit(prices):\n    buy1, buy2 = float(\"inf\"), float(\"inf\")\n    profit1, profit2 = 0, 0\n\n    for price in prices:\n        buy1 = min(buy1, price)\n        profit1 = max(profit1, price - buy1)\n        buy2 = min(buy2, price - profit1)\n        profit2 = max(profit2, price - buy2)\n\n    return profit2", "java": "public int maxProfit(int[] prices) {\n    int buy1 = Integer.MAX_VALUE, buy2 = Integer.MAX_VALUE;\n    int profit1 = 0, profit2 = 0;\n    \n    for (int price : prices) {\n        buy1 = Math.min(buy1, price);\n        profit1 = Math.max(profit1, price - buy1);\n        buy2 = Math.min(buy2, price - profit1);\n        profit2 = Math.max(profit2, price - buy2);\n    }\n    \n    return profit2;\n}", "cpp": "int maxProfit(vector<int>& prices) {\n    int buy1 = INT_MAX, buy2 = INT_MAX;\n    int profit1 = 0, profit2 = 0;\n    \n    for (int price : prices) {\n        buy1 = min(buy1, price);\n        profit1 = max(profit1, price - buy1);\n        buy2 = min(buy2, price - profit1);\n        profit2 = max(profit2, price - buy2);\n    }\n    \n    return profit2;\n}", "javascript": "function maxProfit(prices) {\n    let buy1 = Infinity, buy2 = Infinity;\n    let profit1 = 0, profit2 = 0;\n\n    for (let price of prices) {\n        buy1 = Math.min(buy1, price);\n        profit1 = Math.max(profit1, price - buy1);\n        buy2 = Math.min(buy2, price - profit1);\n        profit2 = Math.max(profit2, price - buy2);\n    }\n\n    return profit2;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/124", "prompt": "A **path** in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence **at most once**. Note that the path does not need to pass through the root.\n\nThe **path sum** of a path is the sum of the node's values in the path.\n\nGiven the `root` of a binary tree, return _the maximum **path sum** of any **non-empty** path_.\n\n**Example 1:**\n\n**Input:** root = \\[1,2,3\\]\n**Output:** 6\n**Explanation:** The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\n\n**Example 2:**\n\n**Input:** root = \\[-10,9,20,null,null,15,7\\]\n**Output:** 42\n**Explanation:** The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 3 * 104]`.\n*   `-1000 <= Node.val <= 1000`", "entry_point": "binary_tree_maximum_path_sum", "canonical_solutions": {"python": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef maxPathSum(root: TreeNode) -> int:\n    def helper(root):\n        nonlocal maxSum\n        if not root:\n            return 0\n\n        left = max(0, helper(root.left))\n        right = max(0, helper(root.right))\n\n        maxSum = max(maxSum, left + right + root.val)\n\n        return max(left, right) + root.val\n\n    maxSum = float('-inf')\n    helper(root)\n    return maxSum", "java": "public class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n}\n\npublic int maxPathSum(TreeNode root) {\n    int[] maxSum = new int[]{Integer.MIN_VALUE};\n    helper(root, maxSum);\n    return maxSum[0];\n}\n\nprivate int helper(TreeNode root, int[] maxSum) {\n    if (root == null) return 0;\n\n    int left = Math.max(0, helper(root.left, maxSum));\n    int right = Math.max(0, helper(root.right, maxSum));\n\n    maxSum[0] = Math.max(maxSum[0], left + right + root.val);\n\n    return Math.max(left, right) + root.val;\n}", "cpp": "struct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n};\n\nint helper(TreeNode* root, int& maxSum) {\n    if(!root) return 0;\n\n    int left = max(0, helper(root->left, maxSum));\n    int right = max(0, helper(root->right, maxSum));\n\n    maxSum = max(maxSum, left + right + root->val);\n\n    return max(left, right) + root->val;\n}\n\nint maxPathSum(TreeNode* root) {\n    int maxSum = INT_MIN;\n    helper(root, maxSum);\n    return maxSum;\n}", "javascript": "class TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction maxPathSum(root) {\n    let maxSum = Number.MIN_SAFE_INTEGER;\n    \n    function helper(node) {\n        if (node === null) return 0;\n        \n        const left = Math.max(0, helper(node.left));\n        const right = Math.max(0, helper(node.right));\n        \n        maxSum = Math.max(maxSum, left + right + node.val);\n        \n        return Math.max(left, right) + node.val;\n    }\n    \n    helper(root);\n    return maxSum;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/125", "prompt": "A phrase is a **palindrome** if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\n\nGiven a string `s`, return `true` _if it is a **palindrome**, or_ `false` _otherwise_.\n\n**Example 1:**\n\n**Input:** s =  \"A man, a plan, a canal: Panama \"\n**Output:** true\n**Explanation:**  \"amanaplanacanalpanama \" is a palindrome.\n\n**Example 2:**\n\n**Input:** s =  \"race a car \"\n**Output:** false\n**Explanation:**  \"raceacar \" is not a palindrome.\n\n**Example 3:**\n\n**Input:** s =  \"  \"\n**Output:** true\n**Explanation:** s is an empty string  \" \" after removing non-alphanumeric characters.\nSince an empty string reads the same forward and backward, it is a palindrome.\n\n**Constraints:**\n\n*   `1 <= s.length <= 2 * 105`\n*   `s` consists only of printable ASCII characters.", "entry_point": "valid_palindrome", "canonical_solutions": {"python": "def isPalindrome(s: str) -> bool:\n    cleaned = \"\".join(c.lower() for c in s if c.isalnum())\n    left, right = 0, len(cleaned) - 1\n    while left < right:\n        if cleaned[left] != cleaned[right]:\n            return False\n        left += 1\n        right -= 1\n    return True", "java": "public boolean isPalindrome(String s) {\n    StringBuilder cleaned = new StringBuilder();\n    for (char c : s.toCharArray()) {\n        if (Character.isLetterOrDigit(c)) {\n            cleaned.append(Character.toLowerCase(c));\n        }\n    }\n    int left = 0, right = cleaned.length() - 1;\n    while (left < right) {\n        if (cleaned.charAt(left++) != cleaned.charAt(right--)) return false;\n    }\n    return true;\n}", "cpp": "#include <cctype>\n#include <algorithm>\n\nbool isPalindrome(std::string s) {\n    s.erase(std::remove_if(s.begin(), s.end(), [](char c) { return !std::isalnum(c); }), s.end());\n    std::transform(s.begin(), s.end(), s.begin(), ::tolower);\n    int left = 0, right = s.size() - 1;\n    while (left < right) {\n        if (s[left++] != s[right--]) return false;\n    }\n    return true;\n}", "javascript": "function isPalindrome(s) {\n    const cleaned = s.toLowerCase().replace(/[^a-z0-9]/g, '');\n    let left = 0, right = cleaned.length - 1;\n    while (left < right) {\n        if (cleaned[left++] !== cleaned[right--]) return false;\n    }\n    return true;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/126", "prompt": "A **transformation sequence** from word `beginWord` to word `endWord` using a dictionary `wordList` is a sequence of words `beginWord -> s1 -> s2 -> ... -> sk` such that:\n\n*   Every adjacent pair of words differs by a single letter.\n*   Every `si` for `1 <= i <= k` is in `wordList`. Note that `beginWord` does not need to be in `wordList`.\n*   `sk == endWord`\n\nGiven two words, `beginWord` and `endWord`, and a dictionary `wordList`, return _all the **shortest transformation sequences** from_ `beginWord` _to_ `endWord`_, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words_ `[beginWord, s1, s2, ..., sk]`.\n\n**Example 1:**\n\n**Input:** beginWord =  \"hit \", endWord =  \"cog \", wordList = \\[ \"hot \", \"dot \", \"dog \", \"lot \", \"log \", \"cog \"\\]\n**Output:** \\[\\[ \"hit \", \"hot \", \"dot \", \"dog \", \"cog \"\\],\\[ \"hit \", \"hot \", \"lot \", \"log \", \"cog \"\\]\\]\n**Explanation:** There are 2 shortest transformation sequences:\n \"hit \" ->  \"hot \" ->  \"dot \" ->  \"dog \" ->  \"cog \"\n \"hit \" ->  \"hot \" ->  \"lot \" ->  \"log \" ->  \"cog \"\n\n**Example 2:**\n\n**Input:** beginWord =  \"hit \", endWord =  \"cog \", wordList = \\[ \"hot \", \"dot \", \"dog \", \"lot \", \"log \"\\]\n**Output:** \\[\\]\n**Explanation:** The endWord  \"cog \" is not in wordList, therefore there is no valid transformation sequence.\n\n**Constraints:**\n\n*   `1 <= beginWord.length <= 5`\n*   `endWord.length == beginWord.length`\n*   `1 <= wordList.length <= 500`\n*   `wordList[i].length == beginWord.length`\n*   `beginWord`, `endWord`, and `wordList[i]` consist of lowercase English letters.\n*   `beginWord != endWord`\n*   All the words in `wordList` are **unique**.\n*   The **sum** of all shortest transformation sequences does not exceed `105`.", "entry_point": "word_ladder_ii", "canonical_solutions": {"python": "from collections import defaultdict, deque\n\ndef findLadders(beginWord, endWord, wordList):\n    wordList = set(wordList)\n    if endWord not in wordList:\n        return []\n\n    adjacent = defaultdict(list)\n    distance = defaultdict(int)\n    queue = deque([beginWord])\n    distance[beginWord] = 0\n    \n    def neighbors(word):\n        for i in range(len(word)):\n            for j in range(ord('a'), ord('z') + 1):\n                yield word[:i] + chr(j) + word[i + 1:]\n                \n    while queue:\n        current = queue.popleft()\n        if current == endWord:\n            break\n        for neighbor in neighbors(current):\n            if neighbor not in wordList:\n                continue\n            if neighbor not in distance:\n                distance[neighbor] = distance[current] + 1\n                queue.append(neighbor)\n            if distance[neighbor] == distance[current] + 1:\n                adjacent[current].append(neighbor)\n\n    result = []\n    path = [beginWord]\n\n    def backtrack(word):\n        if word == endWord:\n            result.append(path[:])\n        else:\n            for next_word in adjacent[word]:\n                path.append(next_word)\n                backtrack(next_word)\n                path.pop()\n                \n    backtrack(beginWord)\n    return result", "java": "import java.util.*;\n\npublic List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n    Set<String> dict = new HashSet<>(wordList);\n    if (!dict.contains(endWord)) {\n        return Collections.emptyList();\n    }\n\n    Map<String, List<String>> adjacent = new HashMap<>();\n    Map<String, Integer> distance = new HashMap<>();\n    Queue<String> queue = new LinkedList<>();\n    queue.offer(beginWord);\n    distance.put(beginWord, 0);\n\n    while (!queue.isEmpty()) {\n        String current = queue.poll();\n        if (current.equals(endWord)) {\n            break;\n        }\n        for (String neighbor : neighbors(current)) {\n            if (!dict.contains(neighbor)) {\n                continue;\n            }\n            if (!distance.containsKey(neighbor)) {\n                distance.put(neighbor, distance.get(current) + 1);\n                queue.offer(neighbor);\n            }\n            if (distance.get(neighbor).equals(distance.get(current) + 1)) {\n                adjacent.computeIfAbsent(current, k -> new ArrayList<>()).add(neighbor);\n            }\n        }\n    }\n\n    List<List<String>> result = new ArrayList<>();\n    List<String> path = new ArrayList<>();\n    path.add(beginWord);\n    backtrack(beginWord, endWord, path, adjacent, result);\n    return result;\n}\n\nprivate void backtrack(String current, String endWord, List<String> path, Map<String, List<String>> adjacent, List<List<String>> result) {\n    if (current.equals(endWord)) {\n        result.add(new ArrayList<>(path));\n        return;\n    }\n    for (String next : adjacent.getOrDefault(current, Collections.emptyList())) {\n        path.add(next);\n        backtrack(next, endWord, path, adjacent, result);\n        path.remove(path.size() - 1);\n    }\n}\n\nprivate List<String> neighbors(String word) {\n    List<String> result = new ArrayList<>();\n    char[] chars = word.toCharArray();\n    for (int i = 0; i < chars.length; i++) {\n        char original = chars[i];\n        for (char j = 'a'; j <= 'z'; j++) {\n            if (j == original) {\n                continue;\n            }\n            chars[i] = j;\n            result.add(new String(chars));\n        }\n        chars[i] = original;\n    }\n    return result;\n}", "cpp": "#include <vector>\n#include <string>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n\nstd::vector<std::vector<std::string>> findLadders(std::string beginWord, std::string endWord, std::vector<std::string>& wordList) {\n    std::unordered_set<std::string> dict(wordList.begin(), wordList.end());\n    if (dict.find(endWord) == dict.end()) {\n        return {};\n    }\n    std::unordered_map<std::string, std::vector<std::string>> adjacent;\n    std::unordered_map<std::string, int> distance;\n    \n    auto neighbors = [&](const std::string& word) {\n        std::vector<std::string> result;\n        std::string temp = word;\n        for (char& ch : temp) {\n            char original = ch;\n            for (int i = 'a'; i <= 'z'; ++i) {\n                ch = i;\n                if (dict.count(temp) && temp != word) {\n                    result.push_back(temp);\n                }\n            }\n            ch = original;\n        }\n        return result;\n    };\n    \n    std::queue<std::string> q;\n    q.push(beginWord);\n    distance[beginWord] = 0;\n    \n    while (!q.empty()) {\n        std::string current = q.front();\n        q.pop();\n        if (current == endWord) {\n            break;\n        }\n        for (const std::string& neighbor : neighbors(current)) {\n            if (!distance.count(neighbor)) {\n                distance[neighbor] = distance[current] + 1;\n                q.push(neighbor);\n            }\n            if (distance[neighbor] == distance[current] + 1) {\n                adjacent[current].push_back(neighbor);\n            }\n        }\n    }\n    \n    std::vector<std::vector<std::string>> result;\n    std::vector<std::string> path = {beginWord};\n    std::function<void(const std::string&)> backtrack = [&](const std::string& word) {\n        if (word == endWord) {\n            result.push_back(path);\n            return;\n        }\n        for (const std::string& next : adjacent[word]) {\n            path.push_back(next);\n            backtrack(next);\n            path.pop_back();\n        }\n    };\n    \n    backtrack(beginWord);\n    return result;\n}", "javascript": "function findLadders(beginWord, endWord, wordList) {\n    const dict = new Set(wordList);\n    if (!dict.has(endWord)) {\n        return [];\n    }\n\n    const adjacent = new Map();\n    const distance = new Map();\n    const queue = [beginWord];\n    distance.set(beginWord, 0);\n    \n    function neighbors(word) {\n        const result = [];\n        for (let i = 0; i < word.length; i++) {\n            for (let j = 'a'.charCodeAt(0); j <= 'z'.charCodeAt(0); j++) {\n                const next = word.slice(0, i) + String.fromCharCode(j) + word.slice(i + 1);\n                if (next !== word) {\n                    result.push(next);\n                }\n            }\n        }\n        return result;\n    }\n    \n    while (queue.length > 0) {\n        const current = queue.shift();\n        if (current === endWord) {\n            break;\n        }\n        for (const neighbor of neighbors(current)) {\n            if (!dict.has(neighbor)) {\n                continue;\n            }\n            if (!distance.has(neighbor)) {\n                distance.set(neighbor, distance.get(current) + 1);\n                queue.push(neighbor);\n            }\n            if (distance.get(neighbor) === distance.get(current) + 1) {\n                if (!adjacent.has(current)) {\n                    adjacent.set(current, []);\n                }\n                adjacent.get(current).push(neighbor);\n            }\n        }\n    }\n\n    const result = [];\n    const path = [beginWord];\n\n    function backtrack(word) {\n        if (word === endWord) {\n            result.push([...path]);\n            return;\n        }\n        for (const next of (adjacent.get(word) || [])) {\n            path.push(next);\n            backtrack(next);\n            path.pop();\n        }\n    }\n    \n    backtrack(beginWord);\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/127", "prompt": "A **transformation sequence** from word `beginWord` to word `endWord` using a dictionary `wordList` is a sequence of words `beginWord -> s1 -> s2 -> ... -> sk` such that:\n\n*   Every adjacent pair of words differs by a single letter.\n*   Every `si` for `1 <= i <= k` is in `wordList`. Note that `beginWord` does not need to be in `wordList`.\n*   `sk == endWord`\n\nGiven two words, `beginWord` and `endWord`, and a dictionary `wordList`, return _the **number of words** in the **shortest transformation sequence** from_ `beginWord` _to_ `endWord`_, or_ `0` _if no such sequence exists._\n\n**Example 1:**\n\n**Input:** beginWord =  \"hit \", endWord =  \"cog \", wordList = \\[ \"hot \", \"dot \", \"dog \", \"lot \", \"log \", \"cog \"\\]\n**Output:** 5\n**Explanation:** One shortest transformation sequence is  \"hit \" ->  \"hot \" ->  \"dot \" ->  \"dog \" -> cog \", which is 5 words long.\n\n**Example 2:**\n\n**Input:** beginWord =  \"hit \", endWord =  \"cog \", wordList = \\[ \"hot \", \"dot \", \"dog \", \"lot \", \"log \"\\]\n**Output:** 0\n**Explanation:** The endWord  \"cog \" is not in wordList, therefore there is no valid transformation sequence.\n\n**Constraints:**\n\n*   `1 <= beginWord.length <= 10`\n*   `endWord.length == beginWord.length`\n*   `1 <= wordList.length <= 5000`\n*   `wordList[i].length == beginWord.length`\n*   `beginWord`, `endWord`, and `wordList[i]` consist of lowercase English letters.\n*   `beginWord != endWord`\n*   All the words in `wordList` are **unique**.", "entry_point": "word_ladder", "canonical_solutions": {"python": "from collections import deque\n\ndef ladderLength(beginWord, endWord, wordList):\n    word_set = set(wordList)\n    if endWord not in word_set:\n        return 0\n\n    q = deque([beginWord])\n    steps = 1\n\n    while q:\n        size = len(q)\n        current_level = set()\n        \n        for _ in range(size):\n            current_word = q.popleft()\n            if current_word == endWord:\n                return steps\n\n            word_chars = list(current_word)\n            for i in range(len(word_chars)):\n                original_char = word_chars[i]\n                for j in range(26):\n                    word_chars[i] = chr(ord('a') + j)\n                    new_word = ''.join(word_chars)\n                    if new_word in word_set:\n                        q.append(new_word)\n                        current_level.add(new_word)\n                        \n                word_chars[i] = original_char\n        \n        word_set -= current_level\n        steps += 1\n        \n    return 0", "java": "import java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Set;\n\npublic int ladderLength(String beginWord, String endWord, List<String> wordList) {\n    Set<String> dict = new HashSet<>(wordList);\n    if (!dict.contains(endWord)) return 0;\n\n    Queue<String> q = new LinkedList<>();\n    q.offer(beginWord);\n    int steps = 1;\n\n    while (!q.isEmpty()) {\n        int size = q.size();\n        for (int i = 0; i < size; ++i) {\n            String currentWord = q.poll();\n            if (currentWord.equals(endWord)) return steps;\n\n            char[] charArray = currentWord.toCharArray();\n            for (int j = 0; j < charArray.length; ++j) {\n                char originalChar = charArray[j];\n                for (int k = 0; k < 26; ++k) {\n                    charArray[j] = (char) ('a' + k);\n                    String newWord = new String(charArray);\n                    if (dict.remove(newWord)) {\n                        q.offer(newWord);\n                    }\n                }\n                charArray[j] = originalChar;\n            }\n        }\n        ++steps;\n    }\n    return 0;\n}", "cpp": "#include <string>\n#include <vector>\n#include <queue>\n#include <unordered_set>\n\nint ladderLength(std::string beginWord, std::string endWord, std::vector<std::string>& wordList) {\n    std::unordered_set<std::string> dict(wordList.begin(), wordList.end());\n    if (!dict.count(endWord)) return 0;\n\n    std::queue<std::string> q;\n    q.push(beginWord);\n    int steps = 1;\n\n    while (!q.empty()) {\n        int size = q.size();\n        for (int i = 0; i < size; ++i) {\n            std::string currentWord = q.front();\n            q.pop();\n            if (currentWord == endWord) return steps;\n\n            for (char& c : currentWord) {\n                char originalChar = c;\n                for (int j = 0; j < 26; ++j) {\n                    c = 'a' + j;\n                    if (dict.count(currentWord)) {\n                        q.push(currentWord);\n                        dict.erase(currentWord);\n                    }\n                }\n                c = originalChar;\n            }\n        }\n        ++steps;\n    }\n    return 0;\n}", "javascript": "function ladderLength(beginWord, endWord, wordList) {\n    const wordSet = new Set(wordList);\n    if (!wordSet.has(endWord)) return 0;\n\n    const q = [beginWord];\n    let steps = 1;\n\n    while (q.length > 0) {\n        const size = q.length;\n        const currentLevel = new Set();\n\n        for (let i = 0; i < size; ++i) {\n            const currentWord = q.shift();\n            if (currentWord === endWord) return steps;\n\n            const wordChars = currentWord.split('');\n            for (let j = 0; j < wordChars.length; ++j) {\n                const originalChar = wordChars[j];\n                for (let k = 0; k < 26; ++k) {\n                    wordChars[j] = String.fromCharCode('a'.charCodeAt(0) + k);\n                    const newWord = wordChars.join('');\n                    if (wordSet.has(newWord)) {\n                        q.push(newWord);\n                        currentLevel.add(newWord);\n                    }\n                }\n                wordChars[j] = originalChar;\n            }\n        }\n        steps++;\n        for (const word of currentLevel) {\n            wordSet.delete(word);\n        }\n    }\n    return 0;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/128", "prompt": "Given an unsorted array of integers `nums`, return _the length of the longest consecutive elements sequence._\n\nYou must write an algorithm that runs in `O(n)` time.\n\n**Example 1:**\n\n**Input:** nums = \\[100,4,200,1,3,2\\]\n**Output:** 4\n**Explanation:** The longest consecutive elements sequence is `[1, 2, 3, 4]`. Therefore its length is 4.\n\n**Example 2:**\n\n**Input:** nums = \\[0,3,7,2,5,8,4,6,0,1\\]\n**Output:** 9\n\n**Constraints:**\n\n*   `0 <= nums.length <= 105`\n*   `-109 <= nums[i] <= 109`", "entry_point": "longest_consecutive_sequence", "canonical_solutions": {"python": "def longest_consecutive(nums):\n    elements = set(nums)\n    longest_seq = 0\n\n    for num in nums:\n        if num - 1 not in elements:\n            current_num = num\n            current_seq = 1\n            \n            while current_num + 1 in elements:\n                current_num += 1\n                current_seq += 1\n\n            longest_seq = max(longest_seq, current_seq)\n    \n    return longest_seq", "java": "public int longestConsecutive(int[] nums) {\n    Set<Integer> elements = new HashSet<>();\n    for (int num : nums) {\n        elements.add(num);\n    }\n    \n    int longestSeq = 0;\n    \n    for (int num : nums) {\n        if (!elements.contains(num - 1)) {\n            int currentNum = num;\n            int currentSeq = 1;\n            \n            while (elements.contains(currentNum + 1)) {\n                currentNum++;\n                currentSeq++;\n            }\n            \n            longestSeq = Math.max(longestSeq, currentSeq);\n        }\n    }\n    return longestSeq;\n}", "cpp": "int longestConsecutive(vector<int>& nums) {\n    unordered_set<int> elements(nums.begin(), nums.end());\n    int longestSeq = 0;\n    \n    for (int num : nums) {\n        if (elements.find(num - 1) == elements.end()) {\n            int currentNum = num;\n            int currentSeq = 1;\n            \n            while (elements.find(currentNum + 1) != elements.end()) {\n                currentNum += 1;\n                currentSeq += 1;\n            }\n            \n            longestSeq = max(longestSeq, currentSeq);\n        }\n    }\n    return longestSeq;\n}", "javascript": "function longestConsecutive(nums) {\n    const elements = new Set(nums);\n    let longestSeq = 0;\n\n    for (const num of nums) {\n        if (!elements.has(num - 1)) {\n            let currentNum = num;\n            let currentSeq = 1;\n\n            while (elements.has(currentNum + 1)) {\n                currentNum++;\n                currentSeq++;\n            }\n\n            longestSeq = Math.max(longestSeq, currentSeq);\n        }\n    }\n\n    return longestSeq;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/129", "prompt": "You are given the `root` of a binary tree containing digits from `0` to `9` only.\n\nEach root-to-leaf path in the tree represents a number.\n\n*   For example, the root-to-leaf path `1 -> 2 -> 3` represents the number `123`.\n\nReturn _the total sum of all root-to-leaf numbers_. Test cases are generated so that the answer will fit in a **32-bit** integer.\n\nA **leaf** node is a node with no children.\n\n**Example 1:**\n\n**Input:** root = \\[1,2,3\\]\n**Output:** 25\n**Explanation:**\nThe root-to-leaf path `1->2` represents the number `12`.\nThe root-to-leaf path `1->3` represents the number `13`.\nTherefore, sum = 12 + 13 = `25`.\n\n**Example 2:**\n\n**Input:** root = \\[4,9,0,5,1\\]\n**Output:** 1026\n**Explanation:**\nThe root-to-leaf path `4->9->5` represents the number 495.\nThe root-to-leaf path `4->9->1` represents the number 491.\nThe root-to-leaf path `4->0` represents the number 40.\nTherefore, sum = 495 + 491 + 40 = `1026`.\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 1000]`.\n*   `0 <= Node.val <= 9`\n*   The depth of the tree will not exceed `10`.", "entry_point": "sum_root_to_leaf_numbers", "canonical_solutions": {"python": "def sumNumbers(root, cur=0):\n    if root is None: return 0\n    cur = cur * 10 + root.val\n    if root.left is None and root.right is None: return cur\n    return sumNumbers(root.left, cur) + sumNumbers(root.right, cur)", "java": "public int sumNumbers(TreeNode root) {\n    return sumNumbersHelper(root, 0);\n}\n\nprivate int sumNumbersHelper(TreeNode root, int cur) {\n    if (root == null) return 0;\n    cur = cur * 10 + root.val;\n    if (root.left == null && root.right == null) return cur;\n    return sumNumbersHelper(root.left, cur) + sumNumbersHelper(root.right, cur);\n}", "cpp": "int sumNumbers(TreeNode* root, int cur = 0) {\n    if (!root) return 0;\n    cur = cur * 10 + root->val;\n    if (!root->left && !root->right) return cur;\n    return sumNumbers(root->left, cur) + sumNumbers(root->right, cur);\n}", "javascript": "function sumNumbers(root, cur = 0) {\n    if (!root) return 0;\n    cur = cur * 10 + root.val;\n    if (!root.left && !root.right) return cur;\n    return sumNumbers(root.left, cur) + sumNumbers(root.right, cur);\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/130", "prompt": "Given an `m x n` matrix `board` containing `'X'` and `'O'`, _capture all regions that are 4-directionally surrounded by_ `'X'`.\n\nA region is **captured** by flipping all `'O'`s into `'X'`s in that surrounded region.\n\n**Example 1:**\n\n**Input:** board = \\[\\[ \"X \", \"X \", \"X \", \"X \"\\],\\[ \"X \", \"O \", \"O \", \"X \"\\],\\[ \"X \", \"X \", \"O \", \"X \"\\],\\[ \"X \", \"O \", \"X \", \"X \"\\]\\]\n**Output:** \\[\\[ \"X \", \"X \", \"X \", \"X \"\\],\\[ \"X \", \"X \", \"X \", \"X \"\\],\\[ \"X \", \"X \", \"X \", \"X \"\\],\\[ \"X \", \"O \", \"X \", \"X \"\\]\\]\n**Explanation:** Notice that an 'O' should not be flipped if:\n- It is on the border, or\n- It is adjacent to an 'O' that should not be flipped.\nThe bottom 'O' is on the border, so it is not flipped.\nThe other three 'O' form a surrounded region, so they are flipped.\n\n**Example 2:**\n\n**Input:** board = \\[\\[ \"X \"\\]\\]\n**Output:** \\[\\[ \"X \"\\]\\]\n\n**Constraints:**\n\n*   `m == board.length`\n*   `n == board[i].length`\n*   `1 <= m, n <= 200`\n*   `board[i][j]` is `'X'` or `'O'`.", "entry_point": "surrounded_regions", "canonical_solutions": {"python": "class Solution:\n    def solve(self, board: List[List[str]]) -> None:\n        if not board:\n            return\n        m, n = len(board), len(board[0])\n\n        def dfs(x, y):\n            if x < 0 or x >= m or y < 0 or y >= n or board[x][y] != 'O':\n                return\n            board[x][y] = '#'\n            dfs(x - 1, y)\n            dfs(x + 1, y)\n            dfs(x, y - 1)\n            dfs(x, y + 1)\n\n        for i in range(m):\n            dfs(i, 0)\n            dfs(i, n - 1)\n        for i in range(n):\n            dfs(0, i)\n            dfs(m - 1, i)\n\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == '#':\n                    board[i][j] = 'O'\n                elif board[i][j] == 'O':\n                    board[i][j] = 'X'", "java": "class Solution {\n    public void solve(char[][] board) {\n        if (board.length == 0) return;\n        int m = board.length, n = board[0].length;\n\n        for (int i = 0; i < m; ++i) {\n            dfs(board, i, 0);\n            dfs(board, i, n - 1);\n        }\n        for (int i = 0; i < n; ++i) {\n            dfs(board, 0, i);\n            dfs(board, m - 1, i);\n        }\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (board[i][j] == '#') board[i][j] = 'O';\n                else if (board[i][j] == 'O') board[i][j] = 'X';\n            }\n        }\n    }\n\n    private void dfs(char[][] board, int x, int y) {\n        if (x < 0 || x >= board.length || y < 0 || y >= board[0].length || board[x][y] != 'O') {\n            return;\n        }\n        board[x][y] = '#';\n        dfs(board, x - 1, y);\n        dfs(board, x + 1, y);\n        dfs(board, x, y - 1);\n        dfs(board, x, y + 1);\n    }\n}", "cpp": "#include <vector>\n\nvoid dfs(std::vector<std::vector<char>> &board, int x, int y) {\n    if (x < 0 || x >= board.size() || y < 0 || y >= board[0].size() || board[x][y] != 'O') {\n        return;\n    }\n    board[x][y] = '#';\n    dfs(board, x - 1, y);\n    dfs(board, x + 1, y);\n    dfs(board, x, y - 1);\n    dfs(board, x, y + 1);\n}\n\nvoid solve(std::vector<std::vector<char>>& board) {\n    if (board.empty()) return;\n    int m = board.size(), n = board[0].size();\n    \n    for (int i = 0; i < m; ++i) {\n        dfs(board, i, 0);\n        dfs(board, i, n - 1);\n    }\n    for (int i = 0; i < n; ++i) {\n        dfs(board, 0, i);\n        dfs(board, m - 1, i);\n    }\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (board[i][j] == '#') board[i][j] = 'O';\n            else if (board[i][j] == 'O') board[i][j] = 'X';\n        }\n    }\n}", "javascript": "class Solution {\n    solve(board) {\n        if (board.length == 0) return;\n        const m = board.length, n = board[0].length;\n\n        const dfs = (x, y) => {\n            if (x < 0 || x >= m || y < 0 || y >= n || board[x][y] !== 'O') {\n                return;\n            }\n            board[x][y] = '#';\n            dfs(x - 1, y);\n            dfs(x + 1, y);\n            dfs(x, y - 1);\n            dfs(x, y + 1);\n        }\n\n        for (let i = 0; i < m; ++i) {\n            dfs(i, 0);\n            dfs(i, n - 1);\n        }\n        for (let i = 0; i < n; ++i) {\n            dfs(0, i);\n            dfs(m - 1, i);\n        }\n        for (let i = 0; i < m; ++i) {\n            for (let j = 0; j < n; ++j) {\n                if (board[i][j] == '#') board[i][j] = 'O';\n                else if (board[i][j] == 'O') board[i][j] = 'X';\n            }\n        }\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/131", "prompt": "Given a string `s`, partition `s` such that every substring of the partition is a **palindrome**. Return _all possible palindrome partitioning of_ `s`.\n\n**Example 1:**\n\n**Input:** s = \"aab\"\n**Output:** \\[\\[\"a\",\"a\",\"b\"\\],\\[\"aa\",\"b\"\\]\\]\n\n**Example 2:**\n\n**Input:** s = \"a\"\n**Output:** \\[\\[\"a\"\\]\\]\n\n**Constraints:**\n\n*   `1 <= s.length <= 16`\n*   `s` contains only lowercase English letters.", "entry_point": "palindrome_partitioning", "canonical_solutions": {"python": "def isPalindrome(s, start, end):\n    while start < end:\n        if s[start] != s[end]:\n            return False\n        start += 1\n        end -= 1\n    return True\n\ndef dfs(s, start, results, current):\n    if start == len(s):\n        results.append(current[:])\n        return\n    \n    for end in range(start, len(s)):\n        if isPalindrome(s, start, end):\n            current.append(s[start:end+1])\n            dfs(s, end + 1, results, current)\n            current.pop()\n\ndef partition(s):\n    results = []\n    dfs(s, 0, results, [])\n    return results", "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n    private boolean isPalindrome(String s, int start, int end) {\n        while (start < end) {\n            if (s.charAt(start++) != s.charAt(end--)) return false;\n        }\n        return true;\n    }\n\n    private void dfs(String s, int start, List<List<String>> results, List<String> current) {\n        if (start == s.length()) {\n            results.add(new ArrayList<>(current));\n            return;\n        }\n        \n        for (int end = start; end < s.length(); end++) {\n            if (isPalindrome(s, start, end)) {\n                current.add(s.substring(start, end + 1));\n                dfs(s, end + 1, results, current);\n                current.remove(current.size() - 1);\n            }\n        }\n    }\n\n    public List<List<String>> partition(String s) {\n        List<List<String>> results = new ArrayList<>();\n        List<String> current = new ArrayList<>();\n        dfs(s, 0, results, current);\n        return results;\n    }\n}", "cpp": "#include <vector>\n#include <string>\n\nbool isPalindrome(const std::string& s, int start, int end) {\n    while (start < end) {\n        if (s[start++] != s[end--]) return false;\n    }\n    return true;\n}\n\nvoid dfs(const std::string& s, int start, std::vector<std::vector<std::string>>& results, std::vector<std::string> current) {\n    if (start == s.length()) {\n        results.push_back(current);\n        return;\n    }\n    \n    for (int end = start; end < s.length(); ++end) {\n        if (isPalindrome(s, start, end)) {\n            current.push_back(s.substr(start, end - start + 1));\n            dfs(s, end + 1, results, current);\n            current.pop_back();\n        }\n    }\n}\n\nstd::vector<std::vector<std::string>> partition(std::string s) {\n    std::vector<std::vector<std::string>> results;\n    std::vector<std::string> current;\n    dfs(s, 0, results, current);\n    return results;\n}", "javascript": "function isPalindrome(s, start, end) {\n    while (start < end) {\n        if (s[start++] !== s[end--]) return false;\n    }\n    return true;\n}\n\nfunction dfs(s, start, results, current) {\n    if (start === s.length) {\n        results.push([...current]);\n        return;\n    }\n    \n    for (let end = start; end < s.length; end++) {\n        if (isPalindrome(s, start, end)) {\n            current.push(s.slice(start, end + 1));\n            dfs(s, end + 1, results, current);\n            current.pop();\n        }\n    }\n}\n\nfunction partition(s) {\n    let results = [];\n    dfs(s, 0, results, []);\n    return results;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/132", "prompt": "Given a string `s`, partition `s` such that every substring of the partition is a palindrome.\n\nReturn _the **minimum** cuts needed for a palindrome partitioning of_ `s`.\n\n**Example 1:**\n\n**Input:** s =  \"aab \"\n**Output:** 1\n**Explanation:** The palindrome partitioning \\[ \"aa \", \"b \"\\] could be produced using 1 cut.\n\n**Example 2:**\n\n**Input:** s =  \"a \"\n**Output:** 0\n\n**Example 3:**\n\n**Input:** s =  \"ab \"\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= s.length <= 2000`\n*   `s` consists of lowercase English letters only.", "entry_point": "palindrome_partitioning_ii", "canonical_solutions": {"python": "def minCut(s):\n    n = len(s)\n    dp = [i - 1 for i in range(n + 1)]\n    is_palindrome = [[False] * n for _ in range(n)]\n    \n    for j in range(1, n):\n        for i in range(j, -1, -1):\n            if s[i] == s[j] and (j - i < 2 or is_palindrome[i + 1][j - 1]):\n                is_palindrome[i][j] = True\n                dp[j + 1] = min(dp[j + 1], dp[i] + 1)\n                \n    return dp[n]", "java": "public int minCut(String s) {\n    int n = s.length();\n    int[] dp = new int[n + 1];\n    boolean[][] isPalindrome = new boolean[n][n];\n    \n    for (int i=0; i <= n; i++) {\n        dp[i] = i - 1;\n    }\n    \n    for (int j=1; j < n; j++) {\n        for (int i=j; i >= 0; i--) {\n            if (s.charAt(i) == s.charAt(j) && (j - i < 2 || isPalindrome[i + 1][j - 1])) {\n                isPalindrome[i][j] = true;\n                dp[j + 1] = Math.min(dp[j + 1], dp[i] + 1);\n            }\n        }\n    }\n    \n    return dp[n];\n}", "cpp": "#include <vector>\n#include <string>\n\nint minCut(std::string s) {\n    int n = s.size();\n    std::vector<int> dp(n + 1, 0);\n    std::vector<std::vector<bool>> isPalindrome(n, std::vector<bool>(n, false));\n    \n    for (int i = 0; i <= n; i++) {\n        dp[i] = i - 1;\n    }\n    \n    for (int j = 1; j < n; j++) {\n        for (int i = j; i >= 0; i--) {\n            if (s[i] == s[j] && (j - i < 2 || isPalindrome[i + 1][j - 1])) {\n                isPalindrome[i][j] = true;\n                dp[j + 1] = std::min(dp[j + 1], dp[i] + 1);\n            }\n        }\n    }\n    \n    return dp[n];\n}", "javascript": "function minCut(s) {\n    const n = s.length;\n    const dp = Array.from({ length: n + 1 }, (_, i) => i - 1);\n    const isPalindrome = Array.from({ length: n }, () => Array(n).fill(false));\n    \n    for (let j = 1; j < n; j++) {\n        for (let i = j; i >= 0; i--) {\n            if (s[i] === s[j] && (j - i < 2 || isPalindrome[i + 1][j - 1])) {\n                isPalindrome[i][j] = true;\n                dp[j + 1] = Math.min(dp[j + 1], dp[i] + 1);\n            }\n        }\n    }\n    \n    return dp[n];\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/133", "prompt": "Given a reference of a node in a **[connected](https://en.wikipedia.org/wiki/Connectivity_(graph_theory)#Connected_graph)** undirected graph.\n\nReturn a [**deep copy**](https://en.wikipedia.org/wiki/Object_copying#Deep_copy) (clone) of the graph.\n\nEach node in the graph contains a value (`int`) and a list (`List[Node]`) of its neighbors.\n\nclass Node {\n    public int val;\n    public List neighbors;\n}\n\n**Test case format:**\n\nFor simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with `val == 1`, the second node with `val == 2`, and so on. The graph is represented in the test case using an adjacency list.\n\n**An adjacency list** is a collection of unordered **lists** used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.\n\nThe given node will always be the first node with `val = 1`. You must return the **copy of the given node** as a reference to the cloned graph.\n\n**Example 1:**\n\n**Input:** adjList = \\[\\[2,4\\],\\[1,3\\],\\[2,4\\],\\[1,3\\]\\]\n**Output:** \\[\\[2,4\\],\\[1,3\\],\\[2,4\\],\\[1,3\\]\\]\n**Explanation:** There are 4 nodes in the graph.\n1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n\n**Example 2:**\n\n**Input:** adjList = \\[\\[\\]\\]\n**Output:** \\[\\[\\]\\]\n**Explanation:** Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.\n\n**Example 3:**\n\n**Input:** adjList = \\[\\]\n**Output:** \\[\\]\n**Explanation:** This an empty graph, it does not have any nodes.\n\n**Constraints:**\n\n*   The number of nodes in the graph is in the range `[0, 100]`.\n*   `1 <= Node.val <= 100`\n*   `Node.val` is unique for each node.\n*   There are no repeated edges and no self-loops in the graph.\n*   The Graph is connected and all nodes can be visited starting from the given node.", "entry_point": "clone_graph", "canonical_solutions": {"python": "class Node:\n    def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\ndef cloneGraph(node, visited=None):\n    if node is None:\n        return None\n\n    if visited is None:\n        visited = {}\n\n    if node in visited:\n        return visited[node]\n\n    cloneNode = Node(node.val)\n    visited[node] = cloneNode\n\n    for neighbor in node.neighbors:\n        cloneNode.neighbors.append(cloneGraph(neighbor, visited))\n\n    return cloneNode", "java": "import java.util.*;\n\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n\n    public Node(int val) {\n        this.val = val;\n        this.neighbors = new ArrayList<>();\n    }\n}\n\npublic Node cloneGraph(Node node, Map<Node, Node> visited) {\n    if (node == null) {\n        return null;\n    }\n\n    if (visited.containsKey(node)) {\n        return visited.get(node);\n    }\n\n    Node cloneNode = new Node(node.val);\n    visited.put(node, cloneNode);\n\n    for (Node neighbor : node.neighbors) {\n        cloneNode.neighbors.add(cloneGraph(neighbor, visited));\n    }\n\n    return cloneNode;\n}\n\npublic Node cloneGraph(Node node) {\n    Map<Node, Node> visited = new HashMap<>();\n    return cloneGraph(node, visited);\n}", "cpp": "#include <unordered_map>\nusing namespace std;\n\nclass Node {\npublic:\n    int val;\n    vector<Node*> neighbors;\n\n    Node(int _val) {\n        val = _val;\n        neighbors = vector<Node*>();\n    }\n};\n\nNode* cloneGraph(Node* node, unordered_map<Node*, Node*>& visited) {\n    if (node == nullptr) {\n        return nullptr;\n    }\n\n    if (visited.find(node) != visited.end()) {\n        return visited[node];\n    }\n\n    Node* cloneNode = new Node(node->val);\n    visited[node] = cloneNode;\n\n    for (Node* neighbor : node->neighbors) {\n        cloneNode->neighbors.push_back(cloneGraph(neighbor, visited));\n    }\n\n    return cloneNode;\n}\n\nNode* cloneGraph(Node* node) {\n    unordered_map<Node*, Node*> visited;\n    return cloneGraph(node, visited);\n}", "javascript": "class Node {\n    constructor(val, neighbors) {\n        this.val = val === undefined ? 0 : val;\n        this.neighbors = neighbors === undefined ? [] : neighbors;\n    }\n}\n\nfunction cloneGraph(node, visited = new Map()) {\n    if (node === null) {\n        return null;\n    }\n\n    if (visited.has(node)) {\n        return visited.get(node);\n    }\n\n    const cloneNode = new Node(node.val);\n    visited.set(node, cloneNode);\n\n    for (const neighbor of node.neighbors) {\n        cloneNode.neighbors.push(cloneGraph(neighbor, visited));\n    }\n\n    return cloneNode;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/134", "prompt": "There are `n` gas stations along a circular route, where the amount of gas at the `ith` station is `gas[i]`.\n\nYou have a car with an unlimited gas tank and it costs `cost[i]` of gas to travel from the `ith` station to its next `(i + 1)th` station. You begin the journey with an empty tank at one of the gas stations.\n\nGiven two integer arrays `gas` and `cost`, return _the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return_ `-1`. If there exists a solution, it is **guaranteed** to be **unique**\n\n**Example 1:**\n\n**Input:** gas = \\[1,2,3,4,5\\], cost = \\[3,4,5,1,2\\]\n**Output:** 3\n**Explanation:**\nStart at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 4. Your tank = 4 - 1 + 5 = 8\nTravel to station 0. Your tank = 8 - 2 + 1 = 7\nTravel to station 1. Your tank = 7 - 3 + 2 = 6\nTravel to station 2. Your tank = 6 - 4 + 3 = 5\nTravel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\nTherefore, return 3 as the starting index.\n\n**Example 2:**\n\n**Input:** gas = \\[2,3,4\\], cost = \\[3,4,3\\]\n**Output:** -1\n**Explanation:**\nYou can't start at station 0 or 1, as there is not enough gas to travel to the next station.\nLet's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 0. Your tank = 4 - 3 + 2 = 3\nTravel to station 1. Your tank = 3 - 3 + 3 = 3\nYou cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\nTherefore, you can't travel around the circuit once no matter where you start.\n\n**Constraints:**\n\n*   `n == gas.length == cost.length`\n*   `1 <= n <= 105`\n*   `0 <= gas[i], cost[i] <= 104`", "entry_point": "gas_station", "canonical_solutions": {"python": "def can_complete_circuit(gas, cost):\n    total_gas, total_cost, start, gas_tank = 0, 0, 0, 0\n    for i in range(len(gas)):\n        total_gas += gas[i]\n        total_cost += cost[i]\n        gas_tank += gas[i] - cost[i]\n        if gas_tank < 0:\n            start = i + 1\n            gas_tank = 0\n    return -1 if total_gas < total_cost else start", "java": "public int canCompleteCircuit(int[] gas, int[] cost) {\n    int totalGas = 0, totalCost = 0, start = 0, gasTank = 0;\n    for (int i = 0; i < gas.length; i++) {\n        totalGas += gas[i];\n        totalCost += cost[i];\n        gasTank += gas[i] - cost[i];\n        if (gasTank < 0) {\n            start = i + 1;\n            gasTank = 0;\n        }\n    }\n    return (totalGas < totalCost) ? -1 : start;\n}", "cpp": "int can_complete_circuit(vector<int>& gas, vector<int>& cost) {\n    int total_gas = 0, total_cost = 0, start = 0, gas_tank = 0;\n    for (int i = 0; i < gas.size(); ++i) {\n        total_gas += gas[i];\n        total_cost += cost[i];\n        gas_tank += gas[i] - cost[i];\n        if (gas_tank < 0) {\n            start = i + 1;\n            gas_tank = 0;\n        }\n    }\n    return (total_gas < total_cost) ? -1 : start;\n}", "javascript": "function canCompleteCircuit(gas, cost) {\n    let totalGas = 0, totalCost = 0, start = 0, gasTank = 0;\n    for (let i = 0; i < gas.length; i++) {\n        totalGas += gas[i];\n        totalCost += cost[i];\n        gasTank += gas[i] - cost[i];\n        if (gasTank < 0) {\n            start = i + 1;\n            gasTank = 0;\n        }\n    }\n    return (totalGas < totalCost) ? -1 : start;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/135", "prompt": "There are `n` children standing in a line. Each child is assigned a rating value given in the integer array `ratings`.\n\nYou are giving candies to these children subjected to the following requirements:\n\n*   Each child must have at least one candy.\n*   Children with a higher rating get more candies than their neighbors.\n\nReturn _the minimum number of candies you need to have to distribute the candies to the children_.\n\n**Example 1:**\n\n**Input:** ratings = \\[1,0,2\\]\n**Output:** 5\n**Explanation:** You can allocate to the first, second and third child with 2, 1, 2 candies respectively.\n\n**Example 2:**\n\n**Input:** ratings = \\[1,2,2\\]\n**Output:** 4\n**Explanation:** You can allocate to the first, second and third child with 1, 2, 1 candies respectively.\nThe third child gets 1 candy because it satisfies the above two conditions.\n\n**Constraints:**\n\n*   `n == ratings.length`\n*   `1 <= n <= 2 * 104`\n*   `0 <= ratings[i] <= 2 * 104`", "entry_point": "candy", "canonical_solutions": {"python": "def min_candies(ratings):\n    n = len(ratings)\n    candies = [1] * n\n\n    for i in range(1, n):\n        if ratings[i] > ratings[i - 1]:\n            candies[i] = candies[i - 1] + 1\n\n    for i in range(n - 2, -1, -1):\n        if ratings[i] > ratings[i + 1]:\n            candies[i] = max(candies[i], candies[i + 1] + 1)\n\n    return sum(candies)", "java": "public int minCandies(int[] ratings) {\n    int n = ratings.length;\n    int[] candies = new int[n];\n    for (int i = 0; i < n; i++) candies[i] = 1;\n\n    for (int i = 1; i < n; i++) {\n        if (ratings[i] > ratings[i - 1]) candies[i] = candies[i - 1] + 1;\n    }\n    for (int i = n - 2; i >= 0; i--) {\n        if (ratings[i] > ratings[i + 1]) candies[i] = Math.max(candies[i], candies[i + 1] + 1);\n    }\n\n    int sum = 0;\n    for (int candy : candies) sum += candy;\n\n    return sum;\n}", "cpp": "#include <vector>\nusing namespace std;\n\nint minCandies(vector<int>& ratings) {\n    int n = ratings.size();\n    vector<int> candies(n, 1);\n\n    for(int i = 1; i < n; i++) {\n        if(ratings[i] > ratings[i-1]) candies[i] = candies[i-1] + 1;\n    }\n    for(int i = n - 2; i >= 0; i--) {\n        if(ratings[i] > ratings[i+1]) candies[i] = max(candies[i], candies[i+1] + 1);\n    }\n\n    int sum = 0;\n    for(int candy : candies) sum += candy;\n\n    return sum;\n}", "javascript": "function minCandies(ratings) {\n    const n = ratings.length;\n    const candies = Array(n).fill(1);\n\n    for (let i = 1; i < n; i++) {\n        if (ratings[i] > ratings[i - 1]) candies[i] = candies[i - 1] + 1;\n    }\n    for (let i = n - 2; i >= 0; i--) {\n        if (ratings[i] > ratings[i + 1]) candies[i] = Math.max(candies[i], candies[i + 1] + 1);\n    }\n\n    return candies.reduce((a, b) => a + b, 0);\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/136", "prompt": "Given a **non-empty** array of integers `nums`, every element appears _twice_ except for one. Find that single one.\n\nYou must implement a solution with a linear runtime complexity and use only constant extra space.\n\n**Example 1:**\n\n**Input:** nums = \\[2,2,1\\]\n**Output:** 1\n\n**Example 2:**\n\n**Input:** nums = \\[4,1,2,1,2\\]\n**Output:** 4\n\n**Example 3:**\n\n**Input:** nums = \\[1\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= nums.length <= 3 * 104`\n*   `-3 * 104 <= nums[i] <= 3 * 104`\n*   Each element in the array appears twice except for one element which appears only once.", "entry_point": "single_number", "canonical_solutions": {"python": "def singleNumber(nums):\n    result = 0\n    for num in nums:\n        result ^= num\n    return result", "java": "public int singleNumber(int[] nums) {\n    int result = 0;\n    for (int num : nums) {\n        result ^= num;\n    }\n    return result;\n}", "cpp": "int singleNumber(vector<int>& nums) {\n    int result = 0;\n    for (int num : nums) {\n        result ^= num;\n    }\n    return result;\n}", "javascript": "function singleNumber(nums) {\n    let result = 0;\n    for (let num of nums) {\n        result ^= num;\n    }\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/137", "prompt": "Given an integer array `nums` where every element appears **three times** except for one, which appears **exactly once**. _Find the single element and return it_.\n\nYou must implement a solution with a linear runtime complexity and use only constant extra space.\n\n**Example 1:**\n\n**Input:** nums = \\[2,2,3,2\\]\n**Output:** 3\n\n**Example 2:**\n\n**Input:** nums = \\[0,1,0,1,0,1,99\\]\n**Output:** 99\n\n**Constraints:**\n\n*   `1 <= nums.length <= 3 * 104`\n*   `-231 <= nums[i] <= 231 - 1`\n*   Each element in `nums` appears exactly **three times** except for one element which appears **once**.", "entry_point": "single_number_ii", "canonical_solutions": {"python": "def singleNumber(nums):\n    ones, twos = 0, 0\n    for n in nums:\n        ones = (ones ^ n) & ~twos\n        twos = (twos ^ n) & ~ones\n    return ones", "java": "public int singleNumber(int[] nums) {\n    int ones = 0, twos = 0;\n    for (int n : nums) {\n        ones = (ones ^ n) & ~twos;\n        twos = (twos ^ n) & ~ones;\n    }\n    return ones;\n}", "cpp": "int singleNumber(vector<int>& nums) {\n    int ones = 0, twos = 0;\n    for (int n : nums) {\n        ones = (ones ^ n) & ~twos;\n        twos = (twos ^ n) & ~ones;\n    }\n    return ones;\n}", "javascript": "function singleNumber(nums) {\n    let ones = 0, twos = 0;\n    for (let n of nums) {\n        ones = (ones ^ n) & ~twos;\n        twos = (twos ^ n) & ~ones;\n    }\n    return ones;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/138", "prompt": "A linked list of length `n` is given such that each node contains an additional random pointer, which could point to any node in the list, or `null`.\n\nConstruct a [**deep copy**](https://en.wikipedia.org/wiki/Object_copying#Deep_copy) of the list. The deep copy should consist of exactly `n` **brand new** nodes, where each new node has its value set to the value of its corresponding original node. Both the `next` and `random` pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. **None of the pointers in the new list should point to nodes in the original list**.\n\nFor example, if there are two nodes `X` and `Y` in the original list, where `X.random --> Y`, then for the corresponding two nodes `x` and `y` in the copied list, `x.random --> y`.\n\nReturn _the head of the copied linked list_.\n\nThe linked list is represented in the input/output as a list of `n` nodes. Each node is represented as a pair of `[val, random_index]` where:\n\n*   `val`: an integer representing `Node.val`\n*   `random_index`: the index of the node (range from `0` to `n-1`) that the `random` pointer points to, or `null` if it does not point to any node.\n\nYour code will **only** be given the `head` of the original linked list.\n\n**Example 1:**\n\n**Input:** head = \\[\\[7,null\\],\\[13,0\\],\\[11,4\\],\\[10,2\\],\\[1,0\\]\\]\n**Output:** \\[\\[7,null\\],\\[13,0\\],\\[11,4\\],\\[10,2\\],\\[1,0\\]\\]\n\n**Example 2:**\n\n**Input:** head = \\[\\[1,1\\],\\[2,1\\]\\]\n**Output:** \\[\\[1,1\\],\\[2,1\\]\\]\n\n**Example 3:**\n\n**Input:** head = \\[\\[3,null\\],\\[3,0\\],\\[3,null\\]\\]\n**Output:** \\[\\[3,null\\],\\[3,0\\],\\[3,null\\]\\]\n\n**Constraints:**\n\n*   `0 <= n <= 1000`\n*   `-104 <= Node.val <= 104`\n*   `Node.random` is `null` or is pointing to some node in the linked list.", "entry_point": "copy_list_with_random_pointer", "canonical_solutions": {"python": "class Node:\n    def __init__(self, val, next=None, random=None):\n        self.val = val\n        self.next = next\n        self.random = random\n        \ndef copyRandomList(head):\n    if not head:\n        return None\n\n    curr = head\n    while curr:\n        temp = Node(curr.val)\n        temp.next = curr.next\n        curr.next = temp\n        curr = curr.next.next\n\n    curr = head\n    while curr:\n        if curr.random:\n            curr.next.random = curr.random.next\n        curr = curr.next.next\n\n    orig = head\n    copy = head.next\n    copy_head = copy\n\n    while orig and copy:\n        orig.next = copy.next\n        orig = orig.next\n        if orig:\n            copy.next = orig.next\n            copy = copy.next\n\n    return copy_head", "java": "class Node {\n    public int val;\n    public Node next;\n    public Node random;\n\n    public Node(int val) {\n        this.val = val;\n        this.next = null;\n        this.random = null;\n    }\n}\n\npublic Node copyRandomList(Node head) {\n    if (head == null) return null;\n\n    Node curr = head;\n    while (curr != null) {\n        Node temp = new Node(curr.val);\n        temp.next = curr.next;\n        curr.next = temp;\n        curr = curr.next.next;\n    }\n\n    curr = head;\n    while (curr != null) {\n        if (curr.random != null) {\n            curr.next.random = curr.random.next;\n        }\n        curr = curr.next.next;\n    }\n\n    Node orig = head;\n    Node copy = head.next;\n    Node copy_head = copy;\n\n    while (orig != null && copy != null) {\n        orig.next = copy.next;\n        orig = orig.next;\n        if (orig != null) {\n            copy.next = orig.next;\n            copy = copy.next;\n        }\n    }\n\n    return copy_head;\n}", "cpp": "class Node {\npublic:\n    int val;\n    Node* next;\n    Node* random;\n\n    Node(int _val) {\n        val = _val;\n        next = nullptr;\n        random = nullptr;\n    }\n};\n\nNode* copyRandomList(Node* head) {\n    if (!head) return nullptr;\n\n    Node* curr = head;\n    while (curr) {\n        Node* temp = new Node(curr->val);\n        temp->next = curr->next;\n        curr->next = temp;\n        curr = curr->next->next;\n    }\n\n    curr = head;\n    while (curr) {\n        if (curr->random) {\n            curr->next->random = curr->random->next;\n        }\n        curr = curr->next->next;\n    }\n\n    Node* orig = head;\n    Node* copy = head->next;\n    Node* copy_head = copy;\n\n    while (orig && copy) {\n        orig->next = copy->next;\n        orig = orig->next;\n        if (orig) {\n            copy->next = orig->next;\n            copy = copy->next;\n        }\n    }\n\n    return copy_head;\n}", "javascript": "class Node {\n    constructor(val, next = null, random = null) {\n        this.val = val;\n        this.next = next;\n        this.random = random;\n    }\n}\n\nfunction copyRandomList(head) {\n    if (!head) return null;\n\n    let curr = head;\n    while (curr) {\n        const temp = new Node(curr.val);\n        temp.next = curr.next;\n        curr.next = temp;\n        curr = curr.next.next;\n    }\n\n    curr = head;\n    while (curr) {\n        if (curr.random) {\n            curr.next.random = curr.random.next;\n        }\n        curr = curr.next.next;\n    }\n\n    let orig = head;\n    let copy = head.next;\n    let copy_head = copy;\n\n    while (orig && copy) {\n        orig.next = copy.next;\n        orig = orig.next;\n        if (orig) {\n            copy.next = orig.next;\n            copy = copy.next;\n        }\n    }\n\n    return copy_head;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/139", "prompt": "Given a string `s` and a dictionary of strings `wordDict`, return `true` if `s` can be segmented into a space-separated sequence of one or more dictionary words.\n\n**Note** that the same word in the dictionary may be reused multiple times in the segmentation.\n\n**Example 1:**\n\n**Input:** s =  \"leetcode \", wordDict = \\[ \"leet \", \"code \"\\]\n**Output:** true\n**Explanation:** Return true because  \"leetcode \" can be segmented as  \"leet code \".\n\n**Example 2:**\n\n**Input:** s =  \"applepenapple \", wordDict = \\[ \"apple \", \"pen \"\\]\n**Output:** true\n**Explanation:** Return true because  \"applepenapple \" can be segmented as  \"apple pen apple \".\nNote that you are allowed to reuse a dictionary word.\n\n**Example 3:**\n\n**Input:** s =  \"catsandog \", wordDict = \\[ \"cats \", \"dog \", \"sand \", \"and \", \"cat \"\\]\n**Output:** false\n\n**Constraints:**\n\n*   `1 <= s.length <= 300`\n*   `1 <= wordDict.length <= 1000`\n*   `1 <= wordDict[i].length <= 20`\n*   `s` and `wordDict[i]` consist of only lowercase English letters.\n*   All the strings of `wordDict` are **unique**.", "entry_point": "word_break", "canonical_solutions": {"python": "def word_break(s, word_dict):\n    word_set = set(word_dict)\n    dp = [False] * (len(s) + 1)\n    dp[0] = True\n    for i in range(1, len(s) + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in word_set:\n                dp[i] = True\n                break\n    return dp[len(s)]", "java": "import java.util.List;\nimport java.util.Set;\nimport java.util.HashSet;\n\npublic boolean wordBreak(String s, List<String> wordDict) {\n    Set<String> dict = new HashSet<>(wordDict);\n    boolean[] dp = new boolean[s.length() + 1];\n    dp[0] = true;\n    for (int i = 1; i <= s.length(); i++) {\n        for (int j = 0; j < i; j++) {\n            if (dp[j] && dict.contains(s.substring(j, i))) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    return dp[s.length()];\n}", "cpp": "#include <vector>\n#include <string>\n#include <unordered_set>\n\nbool wordBreak(std::string s, std::vector<std::string>& wordDict) {\n    std::unordered_set<std::string> dict(wordDict.begin(), wordDict.end());\n    std::vector<bool> dp(s.size() + 1, false);\n    dp[0] = true;\n    for (size_t i = 1; i <= s.size(); ++i) {\n        for (size_t j = 0; j < i; ++j) {\n            if (dp[j] && dict.find(s.substr(j, i - j)) != dict.end()) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    return dp[s.size()];\n}", "javascript": "function wordBreak(s, wordDict) {\n    const dict = new Set(wordDict);\n    const dp = Array(s.length + 1).fill(false);\n    dp[0] = true;\n    for (let i = 1; i <= s.length; i++) {\n        for (let j = 0; j < i; j++) {\n            if (dp[j] && dict.has(s.slice(j, i))) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    return dp[s.length];\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/140", "prompt": "Given a string `s` and a dictionary of strings `wordDict`, add spaces in `s` to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in **any order**.\n\n**Note** that the same word in the dictionary may be reused multiple times in the segmentation.\n\n**Example 1:**\n\n**Input:** s =  \"catsanddog \", wordDict = \\[ \"cat \", \"cats \", \"and \", \"sand \", \"dog \"\\]\n**Output:** \\[ \"cats and dog \", \"cat sand dog \"\\]\n\n**Example 2:**\n\n**Input:** s =  \"pineapplepenapple \", wordDict = \\[ \"apple \", \"pen \", \"applepen \", \"pine \", \"pineapple \"\\]\n**Output:** \\[ \"pine apple pen apple \", \"pineapple pen apple \", \"pine applepen apple \"\\]\n**Explanation:** Note that you are allowed to reuse a dictionary word.\n\n**Example 3:**\n\n**Input:** s =  \"catsandog \", wordDict = \\[ \"cats \", \"dog \", \"sand \", \"and \", \"cat \"\\]\n**Output:** \\[\\]\n\n**Constraints:**\n\n*   `1 <= s.length <= 20`\n*   `1 <= wordDict.length <= 1000`\n*   `1 <= wordDict[i].length <= 10`\n*   `s` and `wordDict[i]` consist of only lowercase English letters.\n*   All the strings of `wordDict` are **unique**.\n*   Input is generated in a way that the length of the answer doesn't exceed 105.", "entry_point": "word_break_ii", "canonical_solutions": {"python": "def word_break(s, word_dict):\n    def helper(s, dict, memo):\n        if s in memo:\n            return memo[s]\n\n        res = []\n        if s in dict:\n            res.append(s)\n\n        for i in range(1, len(s)):\n            prefix = s[:i]\n            if prefix not in dict:\n                continue\n            suffix = s[i:]\n            temp = helper(suffix, dict, memo)\n            for t in temp:\n                res.append(prefix + \" \" + t)\n\n        memo[s] = res\n        return res\n\n    word_set = set(word_dict)\n    memo = {}\n    return helper(s, word_set, memo)", "java": "import java.util.*;\n\npublic List<String> wordBreak(String s, List<String> wordDict) {\n    HashSet<String> dict = new HashSet<>(wordDict);\n    HashMap<String, List<String>> memo = new HashMap<>();\n    return helper(s, dict, memo);\n}\n\nprivate List<String> helper(String s, HashSet<String> dict, HashMap<String, List<String>> memo) {\n    if (memo.containsKey(s)) {\n        return memo.get(s);\n    }\n    \n    List<String> res = new ArrayList<>();\n    if (dict.contains(s)) {\n        res.add(s);\n    }\n    \n    for (int i = 1; i < s.length(); ++i) {\n        String prefix = s.substring(0, i);\n        if (!dict.contains(prefix)) continue;\n        String suffix = s.substring(i);\n        List<String> temp = helper(suffix, dict, memo);\n        for (String t : temp) {\n            res.add(prefix + \" \" + t);\n        }\n    }\n\n    memo.put(s, res);\n    return res;\n}", "cpp": "#include <vector>\n#include <string>\n#include <unordered_set>\n\nstd::vector<std::string> helper(const std::string& s, const std::unordered_set<std::string>& dict, std::unordered_map<std::string, std::vector<std::string>>& memo) {\n    if (memo.count(s)) return memo[s];\n\n    std::vector<std::string> res;\n    if (dict.count(s)) res.push_back(s);\n\n    for (int i = 1; i < s.size(); ++i) {\n        std::string prefix = s.substr(0, i);\n        if (!dict.count(prefix)) continue;\n        std::string suffix = s.substr(i);\n        auto temp = helper(suffix, dict, memo);\n        for (const auto& t : temp) {\n            res.push_back(prefix + \" \" + t);\n        }\n    }\n    memo[s] = res;\n    return res;\n}\n\nstd::vector<std::string> wordBreak(std::string s, std::vector<std::string>& wordDict) {\n    std::unordered_set<std::string> dict(wordDict.begin(), wordDict.end());\n    std::unordered_map<std::string, std::vector<std::string>> memo;\n    return helper(s, dict, memo);\n}", "javascript": "function wordBreak(s, wordDict) {\n    const dict = new Set(wordDict);\n    const memo = {};\n\n    function helper(s, dict, memo) {\n        if (s in memo) {\n            return memo[s];\n        }\n        \n        const res = [];\n        if (dict.has(s)) {\n            res.push(s);\n        }\n        \n        for (let i = 1; i < s.length; ++i) {\n            const prefix = s.slice(0, i);\n            if (!dict.has(prefix)) continue;\n            const suffix = s.slice(i);\n            const temp = helper(suffix, dict, memo);\n            for (const t of temp) {\n                res.push(prefix + \" \" + t);\n            }\n        }\n\n        memo[s] = res;\n        return res;\n    }\n\n    return helper(s, dict, memo);\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/141", "prompt": "Given `head`, the head of a linked list, determine if the linked list has a cycle in it.\n\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer. Internally, `pos` is used to denote the index of the node that tail's `next` pointer is connected to. **Note that `pos` is not passed as a parameter**.\n\nReturn `true` _if there is a cycle in the linked list_. Otherwise, return `false`.\n\n**Example 1:**\n\n**Input:** head = \\[3,2,0,-4\\], pos = 1\n**Output:** true\n**Explanation:** There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\n\n**Example 2:**\n\n**Input:** head = \\[1,2\\], pos = 0\n**Output:** true\n**Explanation:** There is a cycle in the linked list, where the tail connects to the 0th node.\n\n**Example 3:**\n\n**Input:** head = \\[1\\], pos = -1\n**Output:** false\n**Explanation:** There is no cycle in the linked list.\n\n**Constraints:**\n\n*   The number of the nodes in the list is in the range `[0, 104]`.\n*   `-105 <= Node.val <= 105`\n*   `pos` is `-1` or a **valid index** in the linked-list.\n\n**Follow up:** Can you solve it using `O(1)` (i.e. constant) memory?", "entry_point": "linked_list_cycle", "canonical_solutions": {"python": "def hasCycle(head):\n    slow = fast = head\n    while fast is not None and fast.next is not None:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            return True\n    return False", "java": "public boolean hasCycle(ListNode head) {\n    ListNode slow = head, fast = head;\n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow == fast) {\n            return true;\n        }\n    }\n    return false;\n}", "cpp": "bool hasCycle(ListNode *head) {\n    ListNode *slow = head, *fast = head;\n    while (fast != nullptr && fast->next != nullptr) {\n        slow = slow->next;\n        fast = fast->next->next;\n        if (slow == fast) {\n            return true;\n        }\n    }\n    return false;\n}", "javascript": "function hasCycle(head) {\n    let slow = head, fast = head;\n    while (fast !== null && fast.next !== null) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow === fast) {\n            return true;\n        }\n    }\n    return false;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/142", "prompt": "Given the `head` of a linked list, return _the node where the cycle begins. If there is no cycle, return_ `null`.\n\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer. Internally, `pos` is used to denote the index of the node that tail's `next` pointer is connected to (**0-indexed**). It is `-1` if there is no cycle. **Note that** `pos` **is not passed as a parameter**.\n\n**Do not modify** the linked list.\n\n**Example 1:**\n\n**Input:** head = \\[3,2,0,-4\\], pos = 1\n**Output:** tail connects to node index 1\n**Explanation:** There is a cycle in the linked list, where tail connects to the second node.\n\n**Example 2:**\n\n**Input:** head = \\[1,2\\], pos = 0\n**Output:** tail connects to node index 0\n**Explanation:** There is a cycle in the linked list, where tail connects to the first node.\n\n**Example 3:**\n\n**Input:** head = \\[1\\], pos = -1\n**Output:** no cycle\n**Explanation:** There is no cycle in the linked list.\n\n**Constraints:**\n\n*   The number of the nodes in the list is in the range `[0, 104]`.\n*   `-105 <= Node.val <= 105`\n*   `pos` is `-1` or a **valid index** in the linked-list.\n\n**Follow up:** Can you solve it using `O(1)` (i.e. constant) memory?", "entry_point": "linked_list_cycle_ii", "canonical_solutions": {"python": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef detectCycle(head):\n    slow, fast = head, head\n    \n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        \n        if slow == fast:\n            start = head\n            while start != slow:\n                start = start.next\n                slow = slow.next\n            return start\n    \n    return None", "java": "public class ListNode {\n    int val;\n    ListNode next;\n}\n\npublic ListNode detectCycle(ListNode head) {\n    ListNode slow = head, fast = head;\n    \n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n        \n        if (slow == fast) {\n            ListNode start = head;\n            while (start != slow) {\n                start = start.next;\n                slow = slow.next;\n            }\n            return start;\n        }\n    }\n    \n    return null;\n}", "cpp": "class ListNode {\npublic:\n    int val;\n    ListNode* next;\n};\n\nListNode* detectCycle(ListNode* head) {\n    ListNode* slow = head;\n    ListNode* fast = head;\n    \n    while (fast != nullptr && fast->next != nullptr) {\n        slow = slow->next;\n        fast = fast->next->next;\n        \n        if (slow == fast) {\n            ListNode* start = head;\n            while (start != slow) {\n                start = start->next;\n                slow = slow->next;\n            }\n            return start;\n        }\n    }\n    \n    return nullptr;\n}", "javascript": "class ListNode {\n    constructor(val, next = null) {\n        this.val = val;\n        this.next = next;\n    }\n}\n\nfunction detectCycle(head) {\n    let slow = head, fast = head;\n    \n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n        \n        if (slow === fast) {\n            let start = head;\n            while (start !== slow) {\n                start = start.next;\n                slow = slow.next;\n            }\n            return start;\n        }\n    }\n    \n    return null;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/143", "prompt": "You are given the head of a singly linked-list. The list can be represented as:\n\nL0 -> L1 -> ... -> Ln - 1 -> Ln\n\n_Reorder the list to be on the following form:_\n\nL0 -> Ln -> L1 -> Ln - 1 -> L2 -> Ln - 2 -> ...\n\nYou may not modify the values in the list's nodes. Only nodes themselves may be changed.\n\n**Example 1:**\n\n**Input:** head = \\[1,2,3,4\\]\n**Output:** \\[1,4,2,3\\]\n\n**Example 2:**\n\n**Input:** head = \\[1,2,3,4,5\\]\n**Output:** \\[1,5,2,4,3\\]\n\n**Constraints:**\n\n*   The number of nodes in the list is in the range `[1, 5 * 104]`.\n*   `1 <= Node.val <= 1000`", "entry_point": "reorder_list", "canonical_solutions": {"python": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef reorderList(head):\n    if not head or not head.next or not head.next.next:\n        return\n\n    # Find the middle node\n    slow = head\n    fast = head\n    while fast.next and fast.next.next:\n        slow = slow.next\n        fast = fast.next.next\n\n    # Reverse the second half\n    prev = None\n    curr = slow.next\n    while curr:\n        next = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next\n    slow.next = None\n\n    # Merge two halves\n    first = head\n    second = prev\n    while second:\n        next = first.next\n        first.next = second\n        first = second\n        second = next", "java": "public class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) { val = x; }\n}\n\npublic void reorderList(ListNode head) {\n    if (head == null || head.next == null || head.next.next == null) return;\n\n    // Find the middle node\n    ListNode slow = head;\n    ListNode fast = head;\n    while (fast.next != null && fast.next.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n\n    // Reverse the second half\n    ListNode prev = null;\n    ListNode curr = slow.next;\n    ListNode next;\n    while (curr != null) {\n        next = curr.next;\n        curr.next = prev;\n        prev = curr;\n        curr = next;\n    }\n    slow.next = null;\n\n    // Merge two halves\n    ListNode first = head;\n    ListNode second = prev;\n    while (second != null) {\n        next = first.next;\n        first.next = second;\n        first = second;\n        second = next;\n    }\n}", "cpp": "class ListNode {\npublic:\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nvoid reorderList(ListNode* head) {\n    if (!head || !head->next || !head->next->next) return;\n\n    // Find the middle node\n    ListNode* slow = head;\n    ListNode* fast = head;\n    while (fast->next && fast->next->next) {\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n\n    // Reverse the second half\n    ListNode* prev = nullptr;\n    ListNode* curr = slow->next;\n    ListNode* next;\n    while (curr) {\n        next = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = next;\n    }\n    slow->next = nullptr;\n\n    // Merge two halves\n    ListNode* first = head;\n    ListNode* second = prev;\n    while (second) {\n        next = first->next;\n        first = first->next = second;\n        second = next;\n    }\n}", "javascript": "class ListNode {\n    constructor(val, next = null) {\n        this.val = val;\n        this.next = next;\n    }\n}\n\nfunction reorderList(head) {\n    if (!head || !head.next || !head.next.next) return;\n\n    // Find the middle node\n    let slow = head;\n    let fast = head;\n    while (fast.next && fast.next.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n\n    // Reverse the second half\n    let prev = null;\n    let curr = slow.next;\n    let next;\n    while (curr) {\n        next = curr.next;\n        curr.next = prev;\n        prev = curr;\n        curr = next;\n    }\n    slow.next = null;\n\n    // Merge two halves\n    let first = head;\n    let second = prev;\n    while (second) {\n        next = first.next;\n        first.next = second;\n        first = second;\n        second = next;\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/144", "prompt": "Given the `root` of a binary tree, return _the preorder traversal of its nodes' values_.\n\n**Example 1:**\n\n**Input:** root = \\[1,null,2,3\\]\n**Output:** \\[1,2,3\\]\n\n**Example 2:**\n\n**Input:** root = \\[\\]\n**Output:** \\[\\]\n\n**Example 3:**\n\n**Input:** root = \\[1\\]\n**Output:** \\[1\\]\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 100]`.\n*   `-100 <= Node.val <= 100`\n\n**Follow up:** Recursive solution is trivial, could you do it iteratively?", "entry_point": "binary_tree_preorder_traversal", "canonical_solutions": {"python": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef preorderTraversal(root):\n    if root is None:\n        return []\n        \n    return [root.val] + preorderTraversal(root.left) + preorderTraversal(root.right)", "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\npublic List<Integer> preorderTraversal(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    \n    if (root == null) {\n        return result;\n    }\n    \n    result.add(root.val);\n    result.addAll(preorderTraversal(root.left));\n    result.addAll(preorderTraversal(root.right));\n \n    return result;\n}", "cpp": "#include<vector>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nstd::vector<int> preorderTraversal(TreeNode* root) {\n    std::vector<int> result;\n    if (root == nullptr) {\n        return result;\n    }\n    \n    result.push_back(root->val);\n    std::vector<int> left = preorderTraversal(root->left);\n    std::vector<int> right = preorderTraversal(root->right);\n    \n    result.insert(result.end(), left.begin(), left.end());\n    result.insert(result.end(), right.begin(), right.end());\n    \n    return result;\n}", "javascript": "class TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction preorderTraversal(root) {\n    if (!root) {\n        return [];\n    }\n    \n    let result = [root.val];\n    result = result.concat(preorderTraversal(root.left));\n    result = result.concat(preorderTraversal(root.right));\n    \n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/145", "prompt": "Given the `root` of a binary tree, return _the postorder traversal of its nodes' values_.\n\n**Example 1:**\n\n**Input:** root = \\[1,null,2,3\\]\n**Output:** \\[3,2,1\\]\n\n**Example 2:**\n\n**Input:** root = \\[\\]\n**Output:** \\[\\]\n\n**Example 3:**\n\n**Input:** root = \\[1\\]\n**Output:** \\[1\\]\n\n**Constraints:**\n\n*   The number of the nodes in the tree is in the range `[0, 100]`.\n*   `-100 <= Node.val <= 100`\n\n**Follow up:** Recursive solution is trivial, could you do it iteratively?", "entry_point": "binary_tree_postorder_traversal", "canonical_solutions": {"python": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef postorderTraversal(root):\n    if not root:\n        return []\n\n    result = []\n    s = [root]\n    while s:\n        current = s.pop()\n        result.insert(0, current.val)\n        if current.left:\n            s.append(current.left)\n        if current.right:\n            s.append(current.right)\n\n    return result", "java": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Stack;\n\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic List<Integer> postorderTraversal(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    Stack<TreeNode> s = new Stack<>();\n\n    if (root == null) return result;\n\n    s.push(root);\n    while (!s.isEmpty()) {\n        TreeNode current = s.pop();\n        result.add(0, current.val);\n        if (current.left != null) s.push(current.left);\n        if (current.right != null) s.push(current.right);\n    }\n\n    return result;\n}", "cpp": "#include <vector>\n#include <stack>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nvector<int> postorderTraversal(TreeNode* root) {\n    vector<int> result;\n    stack<TreeNode*> s;\n\n    if (!root) return result;\n\n    s.push(root);\n    while (!s.empty()) {\n        TreeNode *current = s.top();\n        s.pop();\n        result.insert(result.begin(), current->val);\n        if (current->left) s.push(current->left);\n        if (current->right) s.push(current->right);\n    }\n\n    return result;\n}", "javascript": "class TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction postorderTraversal(root) {\n    if (!root) {\n        return [];\n    }\n\n    let result = [];\n    let s = [root];\n    while (s.length) {\n        let current = s.pop();\n        result.unshift(current.val);\n        if (current.left) {\n            s.push(current.left);\n        }\n        if (current.right) {\n            s.push(current.right);\n        }\n    }\n\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/146", "prompt": "Design a data structure that follows the constraints of a **[Least Recently Used (LRU) cache](https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU)**.\n\nImplement the `LRUCache` class:\n\n*   `LRUCache(int capacity)` Initialize the LRU cache with **positive** size `capacity`.\n*   `int get(int key)` Return the value of the `key` if the key exists, otherwise return `-1`.\n*   `void put(int key, int value)` Update the value of the `key` if the `key` exists. Otherwise, add the `key-value` pair to the cache. If the number of keys exceeds the `capacity` from this operation, **evict** the least recently used key.\n\nThe functions `get` and `put` must each run in `O(1)` average time complexity.\n\n**Example 1:**\n\n**Input**\n\\[ \"LRUCache \",  \"put \",  \"put \",  \"get \",  \"put \",  \"get \",  \"put \",  \"get \",  \"get \",  \"get \"\\]\n\\[\\[2\\], \\[1, 1\\], \\[2, 2\\], \\[1\\], \\[3, 3\\], \\[2\\], \\[4, 4\\], \\[1\\], \\[3\\], \\[4\\]\\]\n**Output**\n\\[null, null, null, 1, null, -1, null, -1, 3, 4\\]\n\n**Explanation**\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4\n\n**Constraints:**\n\n*   `1 <= capacity <= 3000`\n*   `0 <= key <= 104`\n*   `0 <= value <= 105`\n*   At most `2 * 105` calls will be made to `get` and `put`.", "entry_point": "lru_cache", "canonical_solutions": {"python": "from collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        value = self.cache.pop(key)\n        self.cache[key] = value\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache.pop(key)\n        elif len(self.cache) >= self.capacity:\n            self.cache.popitem(last=False)\n        self.cache[key] = value", "java": "import java.util.HashMap;\n\npublic class LRUCache {\n    int capacity;\n    private HashMap<Integer, Node> cache;\n    private Node head, tail;\n\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        cache = new HashMap<>();\n        head = new Node();\n        tail = new Node();\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int get(int key) {\n        Node node = cache.get(key);\n        if (node == null) return -1;\n        moveToHead(node);\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        Node node = cache.get(key);\n        if (node != null) {\n            node.value = value;\n            moveToHead(node);\n        } else {\n            node = new Node(key, value);\n            cache.put(key, node);\n            addToHead(node);\n            if (cache.size() > capacity) {\n                cache.remove(removeTail().key);\n            }\n        }\n    }\n\n    private void addToHead(Node node) {\n        node.next = head.next;\n        node.prev = head;\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    private void moveToHead(Node node) {\n        removeFromList(node);\n        addToHead(node);\n    }\n\n    private void removeFromList(Node node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private Node removeTail() {\n        Node res = tail.prev;\n        removeFromList(res);\n        return res;\n    }\n\n    class Node {\n        int key;\n        int value;\n        Node prev;\n        Node next;\n\n        public Node() {\n        }\n\n        public Node(int key, int value) {\n            this.key = key;\n            this.value = value;\n        }\n    }\n}", "cpp": "#include <unordered_map>\n#include <list>\nusing namespace std;\n\nclass LRUCache {\n    int capacity;\n    list<pair<int, int>> lru_list;\n    unordered_map<int, list<pair<int, int>>::iterator> cache;\n\npublic:\n    LRUCache(int cap) : capacity(cap) {}\n\n    int get(int key) {\n        auto it = cache.find(key);\n        if (it == cache.end()) {\n            return -1;\n        }\n        lru_list.splice(lru_list.begin(), lru_list, it->second);\n        return it->second->second;\n    }\n\n    void put(int key, int value) {\n        auto it = cache.find(key);\n        if (it != cache.end()) {\n            lru_list.erase(it->second);\n        } else if (lru_list.size() == (size_t)capacity) {\n            cache.erase(lru_list.rbegin()->first);\n            lru_list.pop_back();\n        }\n        lru_list.emplace_front(key, value);\n        cache[key] = lru_list.begin();\n    }\n};", "javascript": "class LRUCache {\n    constructor(capacity) {\n        this.capacity = capacity;\n        this.cache = new Map();\n    }\n\n    get(key) {\n        if (!this.cache.has(key)) {\n            return -1;\n        }\n        const value = this.cache.get(key);\n        this.cache.delete(key);\n        this.cache.set(key, value);\n        return value;\n    }\n\n    put(key, value) {\n        if (this.cache.has(key)) {\n            this.cache.delete(key);\n        } else if (this.cache.size >= this.capacity) {\n            this.cache.delete(this.cache.keys().next().value);\n        }\n        this.cache.set(key, value);\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/147", "prompt": "Given the `head` of a singly linked list, sort the list using **insertion sort**, and return _the sorted list's head_.\n\nThe steps of the **insertion sort** algorithm:\n\n1.  Insertion sort iterates, consuming one input element each repetition and growing a sorted output list.\n2.  At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list and inserts it there.\n3.  It repeats until no input elements remain.\n\nThe following is a graphical example of the insertion sort algorithm. The partially sorted list (black) initially contains only the first element in the list. One element (red) is removed from the input data and inserted in-place into the sorted list with each iteration.\n\n**Example 1:**\n\n**Input:** head = \\[4,2,1,3\\]\n**Output:** \\[1,2,3,4\\]\n\n**Example 2:**\n\n**Input:** head = \\[-1,5,3,4,0\\]\n**Output:** \\[-1,0,3,4,5\\]\n\n**Constraints:**\n\n*   The number of nodes in the list is in the range `[1, 5000]`.\n*   `-5000 <= Node.val <= 5000`", "entry_point": "insertion_sort_list", "canonical_solutions": {"python": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef insertionSortList(head):\n    dummy = ListNode(0)\n    cur = dummy\n\n    while head:\n        while cur.next and cur.next.val < head.val:\n            cur = cur.next\n        \n        temp = head.next\n        head.next = cur.next\n        cur.next = head\n        head = temp\n        cur = dummy\n\n    return dummy.next", "java": "class ListNode {\n    int val;\n    ListNode next;\n}\n\npublic ListNode insertionSortList(ListNode head) {\n    ListNode dummy = new ListNode(0);\n    ListNode cur;\n\n    while (head != null) {\n        cur = dummy;\n        while (cur.next != null && cur.next.val < head.val) {\n            cur = cur.next;\n        }\n\n        ListNode temp = head.next;\n        head.next = cur.next;\n        cur.next = head;\n        head = temp;\n    }\n\n    return dummy.next;\n}", "cpp": "class ListNode {\npublic:\n    int val;\n    ListNode *next;\n};\n\nListNode* insertionSortList(ListNode* head) {\n    ListNode dummy(0);\n    ListNode *cur;\n\n    while (head) {\n        cur = &dummy;\n        while (cur->next && cur->next->val < head->val)\n            cur = cur->next;\n\n        ListNode* temp = head->next;\n        head->next = cur->next;\n        cur->next = head;\n        head = temp;\n    }\n\n    return dummy.next;\n}", "javascript": "class ListNode {\n    constructor(val, next) {\n        this.val = (val === undefined ? 0 : val);\n        this.next = (next === undefined ? null : next);\n    }\n}\n\nfunction insertionSortList(head) {\n    let dummy = new ListNode(0);\n    let cur;\n\n    while (head) {\n        cur = dummy;\n        while (cur.next && cur.next.val < head.val) {\n            cur = cur.next;\n        }\n\n        let temp = head.next;\n        head.next = cur.next;\n        cur.next = head;\n        head = temp;\n    }\n\n    return dummy.next;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/148", "prompt": "Given the `head` of a linked list, return _the list after sorting it in **ascending order**_.\n\n**Example 1:**\n\n**Input:** head = \\[4,2,1,3\\]\n**Output:** \\[1,2,3,4\\]\n\n**Example 2:**\n\n**Input:** head = \\[-1,5,3,4,0\\]\n**Output:** \\[-1,0,3,4,5\\]\n\n**Example 3:**\n\n**Input:** head = \\[\\]\n**Output:** \\[\\]\n\n**Constraints:**\n\n*   The number of nodes in the list is in the range `[0, 5 * 104]`.\n*   `-105 <= Node.val <= 105`\n\n**Follow up:** Can you sort the linked list in `O(n logn)` time and `O(1)` memory (i.e. constant space)?", "entry_point": "sort_list", "canonical_solutions": {"python": "class ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\ndef sortList(head):\n    if not head or not head.next:\n        return head\n\n    slow, fast = head, head.next\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n    mid = slow.next\n    slow.next = None\n\n    return merge(sortList(head), sortList(mid))\n\ndef merge(left, right):\n    if not left:\n        return right\n    if not right:\n        return left\n    if left.val < right.val:\n        left.next = merge(left.next, right)\n        return left\n    else:\n        right.next = merge(left, right.next)\n        return right", "java": "public class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) { val = x; }\n}\n\npublic ListNode sortList(ListNode head) {\n    if (head == null || head.next == null) return head;\n\n    ListNode slow = head, fast = head.next;\n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n\n    ListNode mid = slow.next;\n    slow.next = null;\n\n    return merge(sortList(head), sortList(mid));\n}\n\nprivate ListNode merge(ListNode left, ListNode right) {\n    if (left == null) return right;\n    if (right == null) return left;\n    if (left.val < right.val) {\n        left.next = merge(left.next, right);\n        return left;\n    } else {\n        right.next = merge(left, right.next);\n        return right;\n    }\n}", "cpp": "#include <iostream>\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nListNode* merge(ListNode* left, ListNode* right){\n    if(left == NULL) return right;\n    if(right == NULL) return left;\n    if(left->val < right->val){\n        left->next = merge(left->next, right);\n        return left;\n    } else{\n        right->next = merge(left, right->next);\n        return right;\n    }\n}\n\nListNode* sortList(ListNode* head) {\n    if (head == NULL || head->next == NULL) return head;\n\n    ListNode* slow = head;\n    ListNode* fast = head->next;\n    while (fast != NULL && fast->next != NULL) {\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n\n    ListNode* mid = slow->next;\n    slow->next = NULL;\n\n    return merge(sortList(head), sortList(mid));\n}", "javascript": "class ListNode {\n    constructor(val, next = null) {\n        this.val = val;\n        this.next = next;\n    }\n}\n\nfunction sortList(head) {\n    if (!head || !head.next) return head;\n\n    let slow = head, fast = head.next;\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n\n    const mid = slow.next;\n    slow.next = null;\n\n    return merge(sortList(head), sortList(mid));\n}\n\nfunction merge(left, right) {\n    if (!left) return right;\n    if (!right) return left;\n    if (left.val < right.val) {\n        left.next = merge(left.next, right);\n        return left;\n    } else {\n        right.next = merge(left, right.next);\n        return right;\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/149", "prompt": "Given an array of `points` where `points[i] = [xi, yi]` represents a point on the **X-Y** plane, return _the maximum number of points that lie on the same straight line_.\n\n**Example 1:**\n\n**Input:** points = \\[\\[1,1\\],\\[2,2\\],\\[3,3\\]\\]\n**Output:** 3\n\n**Example 2:**\n\n**Input:** points = \\[\\[1,1\\],\\[3,2\\],\\[5,3\\],\\[4,1\\],\\[2,3\\],\\[1,4\\]\\]\n**Output:** 4\n\n**Constraints:**\n\n*   `1 <= points.length <= 300`\n*   `points[i].length == 2`\n*   `-104 <= xi, yi <= 104`\n*   All the `points` are **unique**.", "entry_point": "max_points_on_a_line", "canonical_solutions": {"python": "from math import gcd\nfrom collections import defaultdict\n\ndef maxPoints(points):\n    n = len(points)\n    if n <= 2:\n        return n\n\n    max_count = 0\n\n    for i in range(n):\n        slope_map = defaultdict(int)\n        duplicates = 0\n        local_max = 0\n\n        for j in range(i+1, n):\n            deltaX = points[j][0] - points[i][0]\n            deltaY = points[j][1] - points[i][1]\n\n            if deltaX == 0 and deltaY == 0:\n                duplicates += 1\n                continue\n\n            g = gcd(deltaX, deltaY)\n            deltaX = deltaX // g\n            deltaY = deltaY // g\n\n            key = f\"{deltaX}_{deltaY}\"\n            slope_map[key] += 1\n            local_max = max(local_max, slope_map[key])\n\n        max_count = max(max_count, local_max + duplicates + 1)\n\n    return max_count", "java": "import java.util.HashMap;\n\npublic int maxPoints(int[][] points) {\n    int n = points.length;\n    if (n <= 2) return n;\n    int maxCount = 0;\n\n    for (int i = 0; i < n-1; i++) {\n        HashMap<String, Integer> slopeMap = new HashMap<>();\n        int duplicates = 0, localMax = 0;\n\n        for (int j = i+1; j < n; j++) {\n            int deltaX = points[j][0] - points[i][0];\n            int deltaY = points[j][1] - points[i][1];\n\n            if (deltaX == 0 && deltaY == 0) {\n                duplicates++;\n                continue;\n            }\n\n            int gcd = gcd(deltaX, deltaY);\n            deltaX /= gcd;\n            deltaY /= gcd;\n\n            String key = deltaX + \"_\" + deltaY;\n            slopeMap.put(key, slopeMap.getOrDefault(key, 0) + 1);\n            localMax = Math.max(localMax, slopeMap.get(key));\n        }\n        maxCount = Math.max(maxCount, localMax + duplicates + 1);\n    }\n\n    return maxCount;\n}\n\nprivate int gcd(int a, int b) {\n    if(b == 0) return a;\n    return gcd(b, a % b);\n}", "cpp": "#include <unordered_map>\n\nint maxPoints(vector<vector<int>>& points) {\n    int n = points.size();\n    if (n <= 2) return n;\n    int max_count = 0;\n\n    for (int i = 0; i < n; i++) {\n        std::unordered_map<string, int> slope_map;\n        int duplicates = 0, local_max = 0;\n\n        for (int j = i + 1; j < n; j++) {\n            int deltaX = points[j][0] - points[i][0];\n            int deltaY = points[j][1] - points[i][1];\n\n            if (deltaX == 0 && deltaY == 0) {\n                duplicates++;\n                continue;\n            }\n\n            int gcd = std::gcd(deltaX, deltaY);\n            deltaX /= gcd;\n            deltaY /= gcd;\n\n            string key = to_string(deltaX) + \"_\" + to_string(deltaY);\n            slope_map[key]++;\n            local_max = max(local_max, slope_map[key]);\n        }\n        max_count = max(max_count, local_max + duplicates + 1);\n    }\n\n    return max_count;\n}", "javascript": "function maxPoints(points) {\n    const n = points.length;\n    if (n <= 2) return n;\n\n    let maxCount = 0;\n\n    for (let i = 0; i < n; i++) {\n        const slopeMap = new Map();\n        let duplicates = 0, localMax = 0;\n\n        for (let j = i + 1; j < n; j++) {\n            let deltaX = points[j][0] - points[i][0];\n            let deltaY = points[j][1] - points[i][1];\n\n            if (deltaX === 0 && deltaY === 0) {\n                duplicates++;\n                continue;\n            }\n\n            const gcdVal = gcd(deltaX, deltaY);\n            deltaX /= gcdVal;\n            deltaY /= gcdVal;\n\n            const key = `${deltaX}_${deltaY}`;\n            slopeMap.set(key, (slopeMap.get(key) || 0) + 1);\n            localMax = Math.max(localMax, slopeMap.get(key));\n        }\n        maxCount = Math.max(maxCount, localMax + duplicates + 1);\n    }\n\n    return maxCount;\n}\n\nfunction gcd(a, b) {\n    if (b === 0) return a;\n    return gcd(b, a % b);\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/150", "prompt": "You are given an array of strings `tokens` that represents an arithmetic expression in a [Reverse Polish Notation](http://en.wikipedia.org/wiki/Reverse_Polish_notation).\n\nEvaluate the expression. Return _an integer that represents the value of the expression_.\n\n**Note** that:\n\n*   The valid operators are `'+'`, `'-'`, `'*'`, and `'/'`.\n*   Each operand may be an integer or another expression.\n*   The division between two integers always **truncates toward zero**.\n*   There will not be any division by zero.\n*   The input represents a valid arithmetic expression in a reverse polish notation.\n*   The answer and all the intermediate calculations can be represented in a **32-bit** integer.\n\n**Example 1:**\n\n**Input:** tokens = \\[ \"2 \", \"1 \", \"+ \", \"3 \", \"\\* \"\\]\n**Output:** 9\n**Explanation:** ((2 + 1) \\* 3) = 9\n\n**Example 2:**\n\n**Input:** tokens = \\[ \"4 \", \"13 \", \"5 \", \"/ \", \"+ \"\\]\n**Output:** 6\n**Explanation:** (4 + (13 / 5)) = 6\n\n**Example 3:**\n\n**Input:** tokens = \\[ \"10 \", \"6 \", \"9 \", \"3 \", \"+ \", \"-11 \", \"\\* \", \"/ \", \"\\* \", \"17 \", \"+ \", \"5 \", \"+ \"\\]\n**Output:** 22\n**Explanation:** ((10 \\* (6 / ((9 + 3) \\* -11))) + 17) + 5\n= ((10 \\* (6 / (12 \\* -11))) + 17) + 5\n= ((10 \\* (6 / -132)) + 17) + 5\n= ((10 \\* 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22\n\n**Constraints:**\n\n*   `1 <= tokens.length <= 104`\n*   `tokens[i]` is either an operator: `\"+ \"`, `\"- \"`, `\"* \"`, or `\"/ \"`, or an integer in the range `[-200, 200]`.", "entry_point": "evaluate_reverse_polish_notation", "canonical_solutions": {"python": "def evalRPN(tokens):\n    stack = []\n    for token in tokens:\n        if token in {\"+\", \"-\", \"*\", \"/\"}:\n            b = stack.pop()\n            a = stack.pop()\n            if token == \"+\":\n                stack.append(a + b)\n            elif token == \"-\":\n                stack.append(a - b)\n            elif token == \"*\":\n                stack.append(a * b)\n            else:\n                stack.append(int(a / b))\n        else:\n            stack.append(int(token))\n    return stack[-1]", "java": "import java.util.Stack;\n\npublic int evalRPN(String[] tokens) {\n    Stack<Integer> stack = new Stack<>();\n    for (String token : tokens) {\n        if (token.equals(\"+\") || token.equals(\"-\") || token.equals(\"*\") || token.equals(\"/\")) {\n            int b = stack.pop();\n            int a = stack.pop();\n            if (token.equals(\"+\")) stack.push(a + b);\n            else if (token.equals(\"-\")) stack.push(a - b);\n            else if (token.equals(\"*\")) stack.push(a * b);\n            else stack.push(a / b);\n        } else {\n            stack.push(Integer.parseInt(token));\n        }\n    }\n    return stack.pop();\n}", "cpp": "#include <vector>\n#include <string>\n#include <stack>\n\nint evalRPN(vector<string>& tokens) {\n    stack<int> s;\n    for (const string& token : tokens) {\n        if(token == \"+\" || token == \"-\" || token == \"*\" || token == \"/\") {\n            int b = s.top(); s.pop();\n            int a = s.top(); s.pop();\n            if (token == \"+\") s.push(a + b);\n            else if (token == \"-\") s.push(a - b);\n            else if (token == \"*\") s.push(a * b);\n            else s.push(a / b);\n        } else {\n            s.push(stoi(token));\n        }\n    }\n    return s.top();\n}", "javascript": "function evalRPN(tokens) {\n    const stack = [];\n    for (const token of tokens) {\n        if (token === \"+\" || token === \"-\" || token === \"*\" || token === \"/\") {\n            const b = stack.pop();\n            const a = stack.pop();\n            if (token === \"+\") stack.push(a + b);\n            else if (token === \"-\") stack.push(a - b);\n            else if (token === \"*\") stack.push(a * b);\n            else stack.push(Math.trunc(a / b));\n        } else {\n            stack.push(parseInt(token));\n        }\n    }\n    return stack.pop();\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/151", "prompt": "Given an input string `s`, reverse the order of the **words**.\n\nA **word** is defined as a sequence of non-space characters. The **words** in `s` will be separated by at least one space.\n\nReturn _a string of the words in reverse order concatenated by a single space._\n\n**Note** that `s` may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.\n\n**Example 1:**\n\n**Input:** s =  \"the sky is blue \"\n**Output:**  \"blue is sky the \"\n\n**Example 2:**\n\n**Input:** s =  \"  hello world   \"\n**Output:**  \"world hello \"\n**Explanation:** Your reversed string should not contain leading or trailing spaces.\n\n**Example 3:**\n\n**Input:** s =  \"a good   example \"\n**Output:**  \"example good a \"\n**Explanation:** You need to reduce multiple spaces between two words to a single space in the reversed string.\n\n**Constraints:**\n\n*   `1 <= s.length <= 104`\n*   `s` contains English letters (upper-case and lower-case), digits, and spaces `' '`.\n*   There is **at least one** word in `s`.\n\n**Follow-up:** If the string data type is mutable in your language, can you solve it **in-place** with `O(1)` extra space?", "entry_point": "reverse_words_in_a_string", "canonical_solutions": {"python": "def reverseWords(s):\n    words = s.split()\n    words.reverse()\n    return ' '.join(words)", "java": "import java.util.*;\n\npublic String reverseWords(String s) {\n    String[] words = s.trim().split(\"\\\\s+\");\n    Collections.reverse(Arrays.asList(words));\n    return String.join(\" \", words);\n}", "cpp": "#include <string>\n#include <sstream>\n#include <vector>\n#include <algorithm>\n\nstd::string reverseWords(std::string s) {\n    std::stringstream ss(s);\n    std::vector<std::string> words;\n    std::string temp;\n\n    while (ss >> temp) {\n        words.push_back(temp);\n    }\n\n    std::reverse(words.begin(), words.end());\n\n    std::string result;\n    for (size_t i = 0; i < words.size(); ++i) {\n        result += words[i] + (i < words.size() - 1 ? \" \" : \"\");\n    }\n\n    return result;\n}", "javascript": "function reverseWords(s) {\n    return s.trim().split(/\\s+/).reverse().join(' ');\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/152", "prompt": "Given an integer array `nums`, find a subarray that has the largest product, and return _the product_.\n\nThe test cases are generated so that the answer will fit in a **32-bit** integer.\n\n**Example 1:**\n\n**Input:** nums = \\[2,3,-2,4\\]\n**Output:** 6\n**Explanation:** \\[2,3\\] has the largest product 6.\n\n**Example 2:**\n\n**Input:** nums = \\[-2,0,-1\\]\n**Output:** 0\n**Explanation:** The result cannot be 2, because \\[-2,-1\\] is not a subarray.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 2 * 104`\n*   `-10 <= nums[i] <= 10`\n*   The product of any prefix or suffix of `nums` is **guaranteed** to fit in a **32-bit** integer.", "entry_point": "maximum_product_subarray", "canonical_solutions": {"python": "def maxProduct(nums):\n    max_so_far = min_so_far = result = nums[0]\n    \n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            max_so_far, min_so_far = min_so_far, max_so_far\n        \n        max_so_far = max(nums[i], max_so_far * nums[i])\n        min_so_far = min(nums[i], min_so_far * nums[i])\n        result = max(result, max_so_far)\n    \n    return result", "java": "public int maxProduct(int[] nums) {\n    int max_so_far = nums[0];\n    int min_so_far = nums[0];\n    int result = nums[0];\n    \n    for (int i = 1; i < nums.length; i++) {\n        if (nums[i] < 0) {\n            int temp = max_so_far;\n            max_so_far = min_so_far;\n            min_so_far = temp;\n        }\n        \n        max_so_far = Math.max(nums[i], max_so_far * nums[i]);\n        min_so_far = Math.min(nums[i], min_so_far * nums[i]);\n        result = Math.max(result, max_so_far);\n    }\n    return result;\n}", "cpp": "int maxProduct(vector<int>& nums) {\n    int max_so_far = nums[0];\n    int min_so_far = nums[0];\n    int result = nums[0];\n    \n    for (int i = 1; i < nums.size(); i++) {\n        if (nums[i] < 0)\n            swap(max_so_far, min_so_far);\n        \n        max_so_far = max(nums[i], max_so_far * nums[i]);\n        min_so_far = min(nums[i], min_so_far * nums[i]);\n        result = max(result, max_so_far);\n    }\n    return result;\n}", "javascript": "function maxProduct(nums) {\n    let max_so_far = nums[0];\n    let min_so_far = nums[0];\n    let result = nums[0];\n    \n    for (let i = 1; i < nums.length; i++) {\n        if (nums[i] < 0) {\n            [max_so_far, min_so_far] = [min_so_far, max_so_far];\n        }\n        \n        max_so_far = Math.max(nums[i], max_so_far * nums[i]);\n        min_so_far = Math.min(nums[i], min_so_far * nums[i]);\n        result = Math.max(result, max_so_far);\n    }\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/153", "prompt": "Suppose an array of length `n` sorted in ascending order is **rotated** between `1` and `n` times. For example, the array `nums = [0,1,2,4,5,6,7]` might become:\n\n*   `[4,5,6,7,0,1,2]` if it was rotated `4` times.\n*   `[0,1,2,4,5,6,7]` if it was rotated `7` times.\n\nNotice that **rotating** an array `[a[0], a[1], a[2], ..., a[n-1]]` 1 time results in the array `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.\n\nGiven the sorted rotated array `nums` of **unique** elements, return _the minimum element of this array_.\n\nYou must write an algorithm that runs in `O(log n) time.`\n\n**Example 1:**\n\n**Input:** nums = \\[3,4,5,1,2\\]\n**Output:** 1\n**Explanation:** The original array was \\[1,2,3,4,5\\] rotated 3 times.\n\n**Example 2:**\n\n**Input:** nums = \\[4,5,6,7,0,1,2\\]\n**Output:** 0\n**Explanation:** The original array was \\[0,1,2,4,5,6,7\\] and it was rotated 4 times.\n\n**Example 3:**\n\n**Input:** nums = \\[11,13,15,17\\]\n**Output:** 11\n**Explanation:** The original array was \\[11,13,15,17\\] and it was rotated 4 times. \n\n**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 5000`\n*   `-5000 <= nums[i] <= 5000`\n*   All the integers of `nums` are **unique**.\n*   `nums` is sorted and rotated between `1` and `n` times.", "entry_point": "find_minimum_in_rotated_sorted_array", "canonical_solutions": {"python": "def find_min(nums):\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        mid = left + (right - left) // 2\n        if nums[mid] > nums[right]:\n            left = mid + 1\n        else:\n            right = mid\n    return nums[left]", "java": "public int findMin(int[] nums) {\n    int left = 0, right = nums.length - 1;\n\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] > nums[right]) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return nums[left];\n}", "cpp": "int findMin(vector<int>& nums) {\n    int left = 0, right = nums.size() - 1;\n\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] > nums[right]) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return nums[left];\n}", "javascript": "function findMin(nums) {\n    let left = 0, right = nums.length - 1;\n\n    while (left < right) {\n        let mid = left + Math.floor((right - left) / 2);\n        if (nums[mid] > nums[right]) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return nums[left];\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/154", "prompt": "Suppose an array of length `n` sorted in ascending order is **rotated** between `1` and `n` times. For example, the array `nums = [0,1,4,4,5,6,7]` might become:\n\n*   `[4,5,6,7,0,1,4]` if it was rotated `4` times.\n*   `[0,1,4,4,5,6,7]` if it was rotated `7` times.\n\nNotice that **rotating** an array `[a[0], a[1], a[2], ..., a[n-1]]` 1 time results in the array `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.\n\nGiven the sorted rotated array `nums` that may contain **duplicates**, return _the minimum element of this array_.\n\nYou must decrease the overall operation steps as much as possible.\n\n**Example 1:**\n\n**Input:** nums = \\[1,3,5\\]\n**Output:** 1\n\n**Example 2:**\n\n**Input:** nums = \\[2,2,2,0,1\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 5000`\n*   `-5000 <= nums[i] <= 5000`\n*   `nums` is sorted and rotated between `1` and `n` times.\n\n**Follow up:** This problem is similar to [Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/), but `nums` may contain **duplicates**. Would this affect the runtime complexity? How and why?", "entry_point": "find_minimum_in_rotated_sorted_array_ii", "canonical_solutions": {"python": "def findMin(nums):\n    low, high = 0, len(nums) - 1\n    \n    while low < high:\n        mid = low + (high - low) // 2\n        if nums[mid] > nums[high]:\n            low = mid + 1\n        elif nums[mid] < nums[high]:\n            high = mid\n        else:\n            high -= 1\n            \n    return nums[low]", "java": "public int findMin(int[] nums) {\n    int low = 0, high = nums.length - 1;\n    \n    while (low < high) {\n        int mid = low + (high - low) / 2;\n        if (nums[mid] > nums[high]) {\n            low = mid + 1;\n        } else if (nums[mid] < nums[high]) {\n            high = mid;\n        } else {\n            high--;\n        }\n    }\n    return nums[low];\n}", "cpp": "int findMin(vector<int>& nums) {\n    int low = 0, high = nums.size() - 1;\n    \n    while (low < high) {\n        int mid = low + (high - low) / 2;\n        if (nums[mid] > nums[high]) {\n            low = mid + 1;\n        } else if (nums[mid] < nums[high]) {\n            high = mid;\n        } else {\n            high--;\n        }\n    }\n    return nums[low];\n}", "javascript": "function findMin(nums) {\n    let low = 0, high = nums.length - 1;\n    \n    while (low < high) {\n        let mid = low + Math.floor((high - low) / 2);\n        if (nums[mid] > nums[high]) {\n            low = mid + 1;\n        } else if (nums[mid] < nums[high]) {\n            high = mid;\n        } else {\n            high--;\n        }\n    }\n    return nums[low];\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/155", "prompt": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\nImplement the `MinStack` class:\n\n*   `MinStack()` initializes the stack object.\n*   `void push(int val)` pushes the element `val` onto the stack.\n*   `void pop()` removes the element on the top of the stack.\n*   `int top()` gets the top element of the stack.\n*   `int getMin()` retrieves the minimum element in the stack.\n\nYou must implement a solution with `O(1)` time complexity for each function.\n\n**Example 1:**\n\n**Input**\n\\[ \"MinStack \", \"push \", \"push \", \"push \", \"getMin \", \"pop \", \"top \", \"getMin \"\\]\n\\[\\[\\],\\[-2\\],\\[0\\],\\[-3\\],\\[\\],\\[\\],\\[\\],\\[\\]\\]\n\n**Output**\n\\[null,null,null,null,-3,null,0,-2\\]\n\n**Explanation**\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin(); // return -3\nminStack.pop();\nminStack.top();    // return 0\nminStack.getMin(); // return -2\n\n**Constraints:**\n\n*   `-231 <= val <= 231 - 1`\n*   Methods `pop`, `top` and `getMin` operations will always be called on **non-empty** stacks.\n*   At most `3 * 104` calls will be made to `push`, `pop`, `top`, and `getMin`.", "entry_point": "min_stack", "canonical_solutions": {"python": "class MinStack:\n\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n        \n    def push(self, val: int):\n        self.stack.append(val)\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n        \n    def pop(self):\n        if self.stack[-1] == self.min_stack[-1]:\n            self.min_stack.pop()\n        self.stack.pop()\n\n    def top(self) -> int:\n        return self.stack[-1]\n\n    def getMin(self) -> int:\n        return self.min_stack[-1]", "java": "import java.util.Stack;\n\npublic class MinStack {\n    Stack<Integer> stack = new Stack<>();\n    Stack<Integer> minStack = new Stack<>();\n\n    public void push(int val) {\n        stack.push(val);\n        if (minStack.isEmpty() || val <= minStack.peek()) {\n            minStack.push(val);\n        }\n    }\n\n    public void pop() {\n        if (stack.peek().equals(minStack.peek())) {\n            minStack.pop();\n        }\n        stack.pop();\n    }\n\n    public int top() {\n        return stack.peek();\n    }\n\n    public int getMin() {\n        return minStack.peek();\n    }\n}", "cpp": "class MinStack {\n    stack<int> s;\n    stack<int> minS;\n\npublic:\n    void push(int val) {\n        s.push(val);\n        if (minS.empty() || val <= minS.top())\n            minS.push(val);\n    }\n\n    void pop() {\n        if (s.top() == minS.top())\n            minS.pop();\n        s.pop();\n    }\n\n    int top() {\n        return s.top();\n    }\n\n    int getMin() {\n        return minS.top();\n    }\n};", "javascript": "class MinStack {\n    constructor() {\n        this.stack = [];\n        this.minStack = [];\n    }\n\n    push(val) {\n        this.stack.push(val);\n        if (this.minStack.length === 0 || val <= this.minStack[this.minStack.length - 1])\n            this.minStack.push(val);\n    }\n\n    pop() {\n        if (this.stack[this.stack.length - 1] === this.minStack[this.minStack.length - 1])\n            this.minStack.pop();\n        this.stack.pop();\n    }\n\n    top() {\n        return this.stack[this.stack.length - 1];\n    }\n\n    getMin() {\n        return this.minStack[this.minStack.length - 1];\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/156", "prompt": "Given the `root` of a binary tree, turn the tree upside down and return _the new root_.\n\nYou can turn a binary tree upside down with the following steps:\n\n1.  The original left child becomes the new root.\n2.  The original root becomes the new right child.\n3.  The original right child becomes the new left child.\n\nThe mentioned steps are done level by level. It is **guaranteed** that every right node has a sibling (a left node with the same parent) and has no children.\n\n**Example 1:**\n\n**Input:** root = \\[1,2,3,4,5\\]\n**Output:** \\[4,5,2,null,null,3,1\\]\n\n**Example 2:**\n\n**Input:** root = \\[\\]\n**Output:** \\[\\]\n\n**Example 3:**\n\n**Input:** root = \\[1\\]\n**Output:** \\[1\\]\n\n**Constraints:**\n\n*   The number of nodes in the tree will be in the range `[0, 10]`.\n*   `1 <= Node.val <= 10`\n*   Every right node in the tree has a sibling (a left node that shares the same parent).\n*   Every right node in the tree has no children.", "entry_point": "binary_tree_upside_down", "canonical_solutions": {"python": "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef upside_down_binary_tree(root):\n    if not root or not root.left:\n        return root\n    new_root = upside_down_binary_tree(root.left)\n    root.left.right = root\n    root.left.left = root.right\n    root.left = None\n    root.right = None\n    return new_root", "java": "public class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic TreeNode upsideDownBinaryTree(TreeNode root) {\n    if (root == null || root.left == null) {\n        return root;\n    }\n    TreeNode new_root = upsideDownBinaryTree(root.left);\n    root.left.right = root;\n    root.left.left = root.right;\n    root.left = null;\n    root.right = null;\n    return new_root;\n}", "cpp": "class TreeNode {\npublic:\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nTreeNode* upsideDownBinaryTree(TreeNode* root) {\n    if (root == nullptr || root->left == nullptr) {\n        return root;\n    }\n    TreeNode* new_root = upsideDownBinaryTree(root->left);\n    root->left->right = root;\n    root->left->left = root->right;\n    root->left = nullptr;\n    root->right = nullptr;\n    return new_root;\n}", "javascript": "function TreeNode(val, left, right) {\n    this.val = (val === undefined ? 0 : val);\n    this.left = (left === undefined ? null : left);\n    this.right = (right === undefined ? null : right);\n}\n\nfunction upsideDownBinaryTree(root) {\n    if (!root || !root.left) {\n        return root;\n    }\n    let new_root = upsideDownBinaryTree(root.left);\n    root.left.right = root;\n    root.left.left = root.right;\n    root.left = null;\n    root.right = null;\n    return new_root;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/157", "prompt": "Given a `file` and assume that you can only read the file using a given method `read4`, implement a method to read `n` characters.\n\n**Method read4:**\n\nThe API `read4` reads **four consecutive characters** from `file`, then writes those characters into the buffer array `buf4`.\n\nThe return value is the number of actual characters read.\n\nNote that `read4()` has its own file pointer, much like `FILE *fp` in C.\n\n**Definition of read4:**\n\n    Parameter:  char\\[\\] buf4\n    Returns:    int\n\nbuf4\\[\\] is a destination, not a source. The results from read4 will be copied to buf4\\[\\].\n\nBelow is a high-level example of how `read4` works:\n\nFile file( \"abcde `\"); // File is  \"`abcde `\", initially file pointer (fp) points to 'a' char[] buf4 = new char[4]; // Create buffer with enough space to store characters read4(buf4); // read4 returns 4. Now buf4 =  \"abcd \", fp points to 'e' read4(buf4); // read4 returns 1. Now buf4 =  \"e \", fp points to end of file read4(buf4); // read4 returns 0. Now buf4 =  \" \", fp points to end of file`\n\n**Method read:**\n\nBy using the `read4` method, implement the method read that reads `n` characters from `file` and store it in the buffer array `buf`. Consider that you cannot manipulate `file` directly.\n\nThe return value is the number of actual characters read.\n\n**Definition of read:**\n\n    Parameters:\tchar\\[\\] buf, int n\n    Returns:\tint\n\nbuf\\[\\] is a destination, not a source. You will need to write the results to buf\\[\\].\n\n**Note:**\n\n*   Consider that you cannot manipulate the file directly. The file is only accessible for `read4` but not for `read`.\n*   The `read` function will only be called once for each test case.\n*   You may assume the destination buffer array, `buf`, is guaranteed to have enough space for storing `n` characters.\n\n**Example 1:**\n\n**Input:** file =  \"abc \", n = 4\n**Output:** 3\n**Explanation:** After calling your read method, buf should contain  \"abc \". We read a total of 3 characters from the file, so return 3.\nNote that  \"abc \" is the file's content, not buf. buf is the destination buffer that you will have to write the results to.\n\n**Example 2:**\n\n**Input:** file =  \"abcde \", n = 5\n**Output:** 5\n**Explanation:** After calling your read method, buf should contain  \"abcde \". We read a total of 5 characters from the file, so return 5.\n\n**Example 3:**\n\n**Input:** file =  \"abcdABCD1234 \", n = 12\n**Output:** 12\n**Explanation:** After calling your read method, buf should contain  \"abcdABCD1234 \". We read a total of 12 characters from the file, so return 12.\n\n**Constraints:**\n\n*   `1 <= file.length <= 500`\n*   `file` consist of English letters and digits.\n*   `1 <= n <= 1000`", "entry_point": "read_n_characters_given_read4", "canonical_solutions": {"python": "def read4(buf4: List[str]) -> int:\n    pass\n\ndef read(buf: List[str], n: int) -> int:\n    total_read = 0\n    buf4 = [''] * 4\n\n    while total_read < n:\n        read4_count = read4(buf4)\n        for i in range(read4_count):\n            if total_read < n:\n                buf[total_read] = buf4[i]\n                total_read += 1\n            else:\n                break\n        if read4_count < 4:\n            break\n\n    return total_read", "java": "public int read4(char[] buf4);\n\npublic int read(char[] buf, int n) {\n    int totalRead = 0;\n    char[] buf4 = new char[4];\n\n    while (totalRead < n) {\n        int read4Count = read4(buf4);\n        for (int i = 0; i < read4Count && totalRead < n; i++) {\n            buf[totalRead++] = buf4[i];\n        }\n        if (read4Count < 4) break;\n    }\n\n    return totalRead;\n}", "cpp": "int read4(char *buf4);\n\nint read(char *buf, int n) {\n    int totalRead = 0;\n    char buf4[4];\n\n    while (totalRead < n) {\n        int read4Count = read4(buf4);\n        for (int i = 0; i < read4Count && totalRead < n; ++i) {\n            buf[totalRead++] = buf4[i];\n        }\n        if (read4Count < 4) break;\n    }\n\n    return totalRead;\n}", "javascript": "function read4(buf4) {\n    // Implemented elsewhere\n}\n\nfunction read(buf, n) {\n    let totalRead = 0;\n    const buf4 = new Array(4);\n\n    while (totalRead < n) {\n        const read4Count = read4(buf4);\n        for(let i = 0; i < read4Count && totalRead < n; ++i) {\n            buf[totalRead++] = buf4[i];\n        }\n        if (read4Count < 4) break;\n    }\n\n    return totalRead;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/158", "prompt": "Given a `file` and assume that you can only read the file using a given method `read4`, implement a method `read` to read `n` characters. Your method `read` may be **called multiple times**.\n\n**Method read4:**\n\nThe API `read4` reads **four consecutive characters** from `file`, then writes those characters into the buffer array `buf4`.\n\nThe return value is the number of actual characters read.\n\nNote that `read4()` has its own file pointer, much like `FILE *fp` in C.\n\n**Definition of read4:**\n\n    Parameter:  char\\[\\] buf4\n    Returns:    int\n\nbuf4\\[\\] is a destination, not a source. The results from read4 will be copied to buf4\\[\\].\n\nBelow is a high-level example of how `read4` works:\n\nFile file( \"abcde `\"); // File is  \"`abcde `\", initially file pointer (fp) points to 'a' char[] buf4 = new char[4]; // Create buffer with enough space to store characters read4(buf4); // read4 returns 4. Now buf4 =  \"abcd \", fp points to 'e' read4(buf4); // read4 returns 1. Now buf4 =  \"e \", fp points to end of file read4(buf4); // read4 returns 0. Now buf4 =  \" \", fp points to end of file`\n\n**Method read:**\n\nBy using the `read4` method, implement the method read that reads `n` characters from `file` and store it in the buffer array `buf`. Consider that you cannot manipulate `file` directly.\n\nThe return value is the number of actual characters read.\n\n**Definition of read:**\n\n    Parameters:\tchar\\[\\] buf, int n\n    Returns:\tint\n\nbuf\\[\\] is a destination, not a source. You will need to write the results to buf\\[\\].\n\n**Note:**\n\n*   Consider that you cannot manipulate the file directly. The file is only accessible for `read4` but not for `read`.\n*   The read function may be **called multiple times**.\n*   Please remember to **RESET** your class variables declared in Solution, as static/class variables are persisted across multiple test cases. Please see [here](https://leetcode.com/faq/) for more details.\n*   You may assume the destination buffer array, `buf`, is guaranteed to have enough space for storing `n` characters.\n*   It is guaranteed that in a given test case the same buffer `buf` is called by `read`.\n\n**Example 1:**\n\n**Input:** file =  \"abc \", queries = \\[1,2,1\\]\n**Output:** \\[1,2,0\\]\n**Explanation:** The test case represents the following scenario:\nFile file( \"abc \");\nSolution sol;\nsol.read(buf, 1); // After calling your read method, buf should contain  \"a \". We read a total of 1 character from the file, so return 1.\nsol.read(buf, 2); // Now buf should contain  \"bc \". We read a total of 2 characters from the file, so return 2.\nsol.read(buf, 1); // We have reached the end of file, no more characters can be read. So return 0.\nAssume buf is allocated and guaranteed to have enough space for storing all characters from the file.\n\n**Example 2:**\n\n**Input:** file =  \"abc \", queries = \\[4,1\\]\n**Output:** \\[3,0\\]\n**Explanation:** The test case represents the following scenario:\nFile file( \"abc \");\nSolution sol;\nsol.read(buf, 4); // After calling your read method, buf should contain  \"abc \". We read a total of 3 characters from the file, so return 3.\nsol.read(buf, 1); // We have reached the end of file, no more characters can be read. So return 0.\n\n**Constraints:**\n\n*   `1 <= file.length <= 500`\n*   `file` consist of English letters and digits.\n*   `1 <= queries.length <= 10`\n*   `1 <= queries[i] <= 500`", "entry_point": "read_n_characters_given_read4_ii_call_multiple_times", "canonical_solutions": {"python": "class Solution:\n    def __init__(self):\n        self.buffer_index = 0\n        self.buffer_len = 0\n        self.buf4 = [None] * 4\n\n    def read(self, buf, n):\n        cnt = 0\n        while cnt < n:\n            if self.buffer_index == self.buffer_len:\n                self.buffer_len = self.read4(self.buf4)\n                self.buffer_index = 0\n            if self.buffer_len == 0:\n                break\n            while cnt < n and self.buffer_index < self.buffer_len:\n                buf[cnt] = self.buf4[self.buffer_index]\n                cnt += 1\n                self.buffer_index += 1\n        return cnt\n\n    def read4(self, buf4):\n        return 0", "java": "class Solution {\n    private int buffer_index = 0;\n    private int buffer_len = 0;\n    private char[] buf4 = new char[4];\n\n    public int read(char[] buf, int n) {\n        int cnt = 0;\n        while (cnt < n) {\n            if (buffer_index == buffer_len) {\n                buffer_len = read4(buf4);\n                buffer_index = 0;\n            }\n            if (buffer_len == 0) break;\n            while (cnt < n && buffer_index < buffer_len) {\n                buf[cnt++] = buf4[buffer_index++];\n            }\n        }\n        return cnt;\n    }\n\n    //dummy method\n    private int read4(char[] buf4) {\n        return 0;\n    }\n}", "cpp": "class Solution {\n    int buffer_index = 0;\n    int buffer_len = 0;\n    char buf4[4];\n\npublic:\n    int read(char* buf, int n) {\n        int cnt = 0;\n        while (cnt < n) {\n            if (buffer_index == buffer_len) {\n                buffer_len = read4(buf4);\n                buffer_index = 0;\n            }\n            if (buffer_len == 0) break;\n            while (cnt < n && buffer_index < buffer_len) {\n                buf[cnt++] = buf4[buffer_index++];\n            }\n        }\n        return cnt;\n    }\n};", "javascript": "class Solution {\n    constructor() {\n        this.buffer_index = 0;\n        this.buffer_len = 0;\n        this.buf4 = new Array(4);\n    }\n\n    read(buf, n) {\n        let cnt = 0;\n        while (cnt < n) {\n            if (this.buffer_index === this.buffer_len) {\n                this.buffer_len = this.read4(this.buf4);\n                this.buffer_index = 0;\n            }\n            if (this.buffer_len === 0) break;\n            while (cnt < n && this.buffer_index < this.buffer_len) {\n                buf[cnt++] = this.buf4[this.buffer_index++];\n            }\n        }\n        return cnt;\n    }\n\n    read4(buf4) {\n        return 0;\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/159", "prompt": "Given a string `s`, return _the length of the longest_ _substring_ _that contains at most **two distinct characters**_.\n\n**Example 1:**\n\n**Input:** s =  \"eceba \"\n**Output:** 3\n**Explanation:** The substring is  \"ece \" which its length is 3.\n\n**Example 2:**\n\n**Input:** s =  \"ccaabbb \"\n**Output:** 5\n**Explanation:** The substring is  \"aabbb \" which its length is 5.\n\n**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists of English letters.", "entry_point": "longest_substring_with_at_most_two_distinct_characters", "canonical_solutions": {"python": "def lengthOfLongestSubstringTwoDistinct(s: str) -> int:\n    l, r, max_len, cur_len = 0, 0, 0, 0\n    char_count = {}\n\n    while r < len(s):\n        if s[r] in char_count:\n            char_count[s[r]] += 1\n        else:\n            char_count[s[r]] = 1\n        if len(char_count) <= 2:\n            cur_len += 1\n        else:\n            while len(char_count) > 2 and l <= r:\n                char_count[s[l]] -= 1\n                if char_count[s[l]] == 0:\n                    del char_count[s[l]]\n                l += 1\n                cur_len -= 1\n            cur_len += 1\n        max_len = max(max_len, cur_len)\n        r += 1\n    return max_len", "java": "public int lengthOfLongestSubstringTwoDistinct(String s) {\n    int l = 0, r = 0, max_len = 0, cur_len = 0;\n    HashMap<Character, Integer> char_count = new HashMap<>();\n\n    while (r < s.length()) {\n        char_count.put(s.charAt(r), char_count.getOrDefault(s.charAt(r), 0) + 1);\n        if (char_count.size() <= 2) {\n            cur_len++;\n        } else {\n            while (char_count.size() > 2 && l <= r) {\n                char_count.put(s.charAt(l), char_count.get(s.charAt(l)) - 1);\n                if (char_count.get(s.charAt(l)) == 0) {\n                    char_count.remove(s.charAt(l));\n                }\n                l++;\n                cur_len--;\n            }\n            cur_len++;\n        }\n        max_len = Math.max(max_len, cur_len);\n        r++;\n    }\n    return max_len;\n}", "cpp": "int lengthOfLongestSubstringTwoDistinct(string s) {\n    int l = 0, r = 0, max_len = 0, cur_len = 0;\n    unordered_map<char, int> char_count;\n\n    while (r < s.length()) {\n        char_count[s[r]]++;\n        if (char_count.size() <= 2) {\n            cur_len++;\n        } else {\n            while (char_count.size() > 2 && l <= r) {\n                char_count[s[l]]--;\n                if (char_count[s[l]] == 0) {\n                    char_count.erase(s[l]);\n                }\n                l++;\n                cur_len--;\n            }\n            cur_len++;\n        }\n        max_len = max(max_len, cur_len);\n        r++;\n    }\n    return max_len;\n}", "javascript": "function lengthOfLongestSubstringTwoDistinct(s) {\n    let l = 0, r = 0, max_len = 0, cur_len = 0;\n    const char_count = new Map();\n\n    while (r < s.length) {\n        char_count.set(s[r], (char_count.get(s[r]) || 0) + 1);\n        if (char_count.size <= 2) {\n            cur_len++;\n        } else {\n            while (char_count.size > 2 && l <= r) {\n                char_count.set(s[l], char_count.get(s[l]) - 1);\n                if (char_count.get(s[l]) === 0) {\n                    char_count.delete(s[l]);\n                }\n                l++;\n                cur_len--;\n            }\n            cur_len++;\n        }\n        max_len = Math.max(max_len, cur_len);\n        r++;\n    }\n    return max_len;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/160", "prompt": "Given the heads of two singly linked-lists `headA` and `headB`, return _the node at which the two lists intersect_. If the two linked lists have no intersection at all, return `null`.\n\nFor example, the following two linked lists begin to intersect at node `c1`:\n\nThe test cases are generated such that there are no cycles anywhere in the entire linked structure.\n\n**Note** that the linked lists must **retain their original structure** after the function returns.\n\n**Custom Judge:**\n\nThe inputs to the **judge** are given as follows (your program is **not** given these inputs):\n\n*   `intersectVal` - The value of the node where the intersection occurs. This is `0` if there is no intersected node.\n*   `listA` - The first linked list.\n*   `listB` - The second linked list.\n*   `skipA` - The number of nodes to skip ahead in `listA` (starting from the head) to get to the intersected node.\n*   `skipB` - The number of nodes to skip ahead in `listB` (starting from the head) to get to the intersected node.\n\nThe judge will then create the linked structure based on these inputs and pass the two heads, `headA` and `headB` to your program. If you correctly return the intersected node, then your solution will be **accepted**.\n\n**Example 1:**\n\n**Input:** intersectVal = 8, listA = \\[4,1,8,4,5\\], listB = \\[5,6,1,8,4,5\\], skipA = 2, skipB = 3\n**Output:** Intersected at '8'\n**Explanation:** The intersected node's value is 8 (note that this must not be 0 if the two lists intersect).\nFrom the head of A, it reads as \\[4,1,8,4,5\\]. From the head of B, it reads as \\[5,6,1,8,4,5\\]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.\n- Note that the intersected node's value is not 1 because the nodes with value 1 in A and B (2nd node in A and 3rd node in B) are different node references. In other words, they point to two different locations in memory, while the nodes with value 8 in A and B (3rd node in A and 4th node in B) point to the same location in memory.\n\n**Example 2:**\n\n**Input:** intersectVal = 2, listA = \\[1,9,1,2,4\\], listB = \\[3,2,4\\], skipA = 3, skipB = 1\n**Output:** Intersected at '2'\n**Explanation:** The intersected node's value is 2 (note that this must not be 0 if the two lists intersect).\nFrom the head of A, it reads as \\[1,9,1,2,4\\]. From the head of B, it reads as \\[3,2,4\\]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.\n\n**Example 3:**\n\n**Input:** intersectVal = 0, listA = \\[2,6,4\\], listB = \\[1,5\\], skipA = 3, skipB = 2\n**Output:** No intersection\n**Explanation:** From the head of A, it reads as \\[2,6,4\\]. From the head of B, it reads as \\[1,5\\]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.\nExplanation: The two lists do not intersect, so return null.\n\n**Constraints:**\n\n*   The number of nodes of `listA` is in the `m`.\n*   The number of nodes of `listB` is in the `n`.\n*   `1 <= m, n <= 3 * 104`\n*   `1 <= Node.val <= 105`\n*   `0 <= skipA < m`\n*   `0 <= skipB < n`\n*   `intersectVal` is `0` if `listA` and `listB` do not intersect.\n*   `intersectVal == listA[skipA] == listB[skipB]` if `listA` and `listB` intersect.\n\n**Follow up:** Could you write a solution that runs in `O(m + n)` time and use only `O(1)` memory?", "entry_point": "intersection_of_two_linked_lists", "canonical_solutions": {"python": "class ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\ndef getIntersectionNode(headA, headB):\n    pA, pB = headA, headB\n    while pA is not pB:\n        pA = pA.next if pA else headB\n        pB = pB.next if pB else headA\n    return pA", "java": "public class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) {\n        val = x;\n        next = null;\n    }\n}\n\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n    ListNode pA = headA, pB = headB;\n    while (pA != pB) {\n        pA = pA != null ? pA.next : headB;\n        pB = pB != null ? pB.next : headA;\n    }\n    return pA;\n}", "cpp": "struct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n    ListNode *pA = headA, *pB = headB;\n    while (pA != pB) {\n        pA = pA ? pA->next : headB;\n        pB = pB ? pB->next : headA;\n    }\n    return pA;\n}", "javascript": "class ListNode {\n    constructor(val, next = null) {\n        this.val = val;\n        this.next = next;\n    }\n}\n\nfunction getIntersectionNode(headA, headB) {\n    let pA = headA, pB = headB;\n    while (pA !== pB) {\n        pA = pA !== null ? pA.next : headB;\n        pB = pB !== null ? pB.next : headA;\n    }\n    return pA;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/161", "prompt": "Given two strings `s` and `t`, return `true` if they are both one edit distance apart, otherwise return `false`.\n\nA string `s` is said to be one distance apart from a string `t` if you can:\n\n*   Insert **exactly one** character into `s` to get `t`.\n*   Delete **exactly one** character from `s` to get `t`.\n*   Replace **exactly one** character of `s` with **a different character** to get `t`.\n\n**Example 1:**\n\n**Input:** s =  \"ab \", t =  \"acb \"\n**Output:** true\n**Explanation:** We can insert 'c' into s to get t.\n\n**Example 2:**\n\n**Input:** s =  \" \", t =  \" \"\n**Output:** false\n**Explanation:** We cannot get t from s by only one step.\n\n**Constraints:**\n\n*   `0 <= s.length, t.length <= 104`\n*   `s` and `t` consist of lowercase letters, uppercase letters, and digits.", "entry_point": "one_edit_distance", "canonical_solutions": {"python": "def isOneEditDistance(s: str, t: str) -> bool:\n    m, n = len(s), len(t)\n    if m > n:\n        return isOneEditDistance(t, s)\n    if n - m > 1:\n        return False\n    for i in range(m):\n        if s[i] != t[i]:\n            return s[i + (m < n):] == t[i + 1:]\n    return m + 1 == n", "java": "public boolean isOneEditDistance(String s, String t) {\n    int m = s.length();\n    int n = t.length();\n    if (m > n) {\n        return isOneEditDistance(t, s);\n    }\n    if (n - m > 1) {\n        return false;\n    }\n    for (int i = 0; i < m; ++i) {\n        if (s.charAt(i) != t.charAt(i)) {\n            if (m < n) {\n                return s.substring(i).equals(t.substring(i + 1));\n            } else {\n                return s.substring(i + 1).equals(t.substring(i + 1));\n            }\n        }\n    }\n    return m + 1 == n;\n}", "cpp": "bool isOneEditDistance(string s, string t) {\n    int m = s.length(), n = t.length();\n    if (m > n) {\n        return isOneEditDistance(t, s);\n    }\n    if (n - m > 1) {\n        return false;\n    }\n    bool flag = false;\n    for (int i = 0; i < m; ++i) {\n      if (s[i] != t[i]) {\n          if (m < n) {\n              return s.substr(i) == t.substr(i + 1);\n          } else {\n              return s.substr(i + 1) == t.substr(i + 1);\n          }\n      }\n    }\n    return m + 1 == n;\n}", "javascript": "function isOneEditDistance(s, t) {\n    let m = s.length, n = t.length;\n    if (m > n) {\n        return isOneEditDistance(t, s);\n    }\n    if (n - m > 1) {\n        return false;\n    }\n    for (let i = 0; i < m; ++i) {\n        if (s[i] !== t[i]) {\n            if (m < n) {\n                return s.slice(i) === t.slice(i + 1);\n            } else {\n                return s.slice(i + 1) === t.slice(i + 1);\n            }\n        }\n    }\n    return m + 1 === n;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/162", "prompt": "A peak element is an element that is strictly greater than its neighbors.\n\nGiven a **0-indexed** integer array `nums`, find a peak element, and return its index. If the array contains multiple peaks, return the index to **any of the peaks**.\n\nYou may imagine that `nums[-1] = nums[n] = -\u221e`. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\n\nYou must write an algorithm that runs in `O(log n)` time.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 2\n**Explanation:** 3 is a peak element and your function should return the index number 2.\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,1,3,5,6,4\\]\n**Output:** 5\n**Explanation:** Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `-231 <= nums[i] <= 231 - 1`\n*   `nums[i] != nums[i + 1]` for all valid `i`.", "entry_point": "find_peak_element", "canonical_solutions": {"python": "def findPeakElement(nums):\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = left + (right - left) // 2\n        if nums[mid] < nums[mid + 1]:\n            left = mid + 1\n        else:\n            right = mid\n    return left", "java": "public int findPeakElement(int[] nums) {\n    int left = 0, right = nums.length - 1;\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] < nums[mid + 1]) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left;\n}", "cpp": "int findPeakElement(vector<int>& nums) {\n    int left = 0, right = nums.size() - 1;\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] < nums[mid + 1]) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left;\n}", "javascript": "function findPeakElement(nums) {\n    let left = 0, right = nums.length - 1;\n    while (left < right) {\n        let mid = left + Math.floor((right - left) / 2);\n        if (nums[mid] < nums[mid + 1]) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/163", "prompt": "You are given an inclusive range `[lower, upper]` and a **sorted unique** integer array `nums`, where all elements are in the inclusive range.\n\nA number `x` is considered **missing** if `x` is in the range `[lower, upper]` and `x` is not in `nums`.\n\nReturn _the **smallest sorted** list of ranges that **cover every missing number exactly**_. That is, no element of `nums` is in any of the ranges, and each missing number is in one of the ranges.\n\nEach range `[a,b]` in the list should be output as:\n\n*   `\"a->b \"` if `a != b`\n*   `\"a \"` if `a == b`\n\n**Example 1:**\n\n**Input:** nums = \\[0,1,3,50,75\\], lower = 0, upper = 99\n**Output:** \\[ \"2 \", \"4->49 \", \"51->74 \", \"76->99 \"\\]\n**Explanation:** The ranges are:\n\\[2,2\\] -->  \"2 \"\n\\[4,49\\] -->  \"4->49 \"\n\\[51,74\\] -->  \"51->74 \"\n\\[76,99\\] -->  \"76->99 \"\n\n**Example 2:**\n\n**Input:** nums = \\[-1\\], lower = -1, upper = -1\n**Output:** \\[\\]\n**Explanation:** There are no missing ranges since there are no missing numbers.\n\n**Constraints:**\n\n*   `-109 <= lower <= upper <= 109`\n*   `0 <= nums.length <= 100`\n*   `lower <= nums[i] <= upper`\n*   All the values of `nums` are **unique**.", "entry_point": "missing_ranges", "canonical_solutions": {"python": "from typing import List\n\ndef find_missing_ranges(nums: List[int], lower: int, upper: int) -> List[str]:\n    result = []\n    prev = lower - 1\n\n    for i, num in enumerate(nums + [upper + 1]):\n        if num - prev >= 2:\n            result.append(f\"{prev + 1}\" + (\"\" if num - prev == 2 else \"->\") + f\"{num - 1}\")\n        prev = num\n\n    return result", "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> findMissingRanges(int[] nums, int lower, int upper) {\n    List<String> result = new ArrayList<>();\n    long prev = (long) lower - 1;\n\n    for (int i = 0; i <= nums.length; ++i) {\n        long cur = (i == nums.length) ? (long) upper + 1 : nums[i];\n        if (cur - prev >= 2) {\n            result.add(Long.toString(prev + 1) + (cur - prev == 2 ? \"\" : \"->\") + Long.toString(cur - 1));\n        }\n        prev = cur;\n    }\n\n    return result;\n}", "cpp": "#include <vector>\n#include <string>\n\nstd::vector<std::string> findMissingRanges(std::vector<int>& nums, int lower, int upper) {\n    std::vector<std::string> result;\n    long prev = (long)lower - 1;\n\n    for (int i = 0; i <= nums.size(); ++i) {\n        long cur = (i == nums.size()) ? (long)upper + 1 : nums[i];\n        if (cur - prev >= 2) {\n            result.push_back(std::to_string(prev + 1) + (cur - prev == 2 ? \"\" : \"->\") + std::to_string(cur - 1));\n        }\n        prev = cur;\n    }\n\n    return result;\n}", "javascript": "function findMissingRanges(nums, lower, upper) {\n    let result = [];\n    let prev = lower - 1;\n\n    for (let i = 0; i <= nums.length; ++i) {\n        let cur = (i === nums.length) ? upper + 1 : nums[i];\n        if (cur - prev >= 2) {\n            result.push((prev + 1) + (cur - prev === 2 ? \"\" : \"->\") + (cur - 1));\n        }\n        prev = cur;\n    }\n\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/164", "prompt": "Given an integer array `nums`, return _the maximum difference between two successive elements in its sorted form_. If the array contains less than two elements, return `0`.\n\nYou must write an algorithm that runs in linear time and uses linear extra space.\n\n**Example 1:**\n\n**Input:** nums = \\[3,6,9,1\\]\n**Output:** 3\n**Explanation:** The sorted form of the array is \\[1,3,6,9\\], either (3,6) or (6,9) has the maximum difference 3.\n\n**Example 2:**\n\n**Input:** nums = \\[10\\]\n**Output:** 0\n**Explanation:** The array contains less than 2 elements, therefore return 0.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `0 <= nums[i] <= 109`", "entry_point": "maximum_gap", "canonical_solutions": {"python": "def maximumGap(nums):\n    if len(nums) < 2:\n        return 0\n\n    min_val = min(nums)\n    max_val = max(nums)\n    length = len(nums)\n    bucket_size = max(1, (max_val - min_val) // (length - 1))\n    bucket_num = (max_val - min_val) // bucket_size + 1\n    buckets = [[float(\"inf\"), float(\"-inf\")] for _ in range(bucket_num)]\n\n    for num in nums:\n        idx = (num - min_val) // bucket_size\n        buckets[idx][0] = min(buckets[idx][0], num)\n        buckets[idx][1] = max(buckets[idx][1], num)\n\n    max_gap = 0\n    prev_max = min_val\n    for bucket in buckets:\n        if bucket[0] == float(\"inf\"):\n            continue\n        max_gap = max(max_gap, bucket[0] - prev_max)\n        prev_max = bucket[1]\n    return max_gap", "java": "public int maximumGap(int[] nums) {\n    if (nums.length < 2) return 0;\n\n    int min_val = Arrays.stream(nums).min().getAsInt();\n    int max_val = Arrays.stream(nums).max().getAsInt();\n    int len = nums.length;\n    int bucket_size = Math.max(1, (max_val - min_val) / (len - 1));\n    int bucket_num = (max_val - min_val) / bucket_size + 1;\n    int[][] buckets = new int[bucket_num][2];\n    for (int i = 0; i < bucket_num; i++) {\n        buckets[i] = new int[]{Integer.MAX_VALUE, Integer.MIN_VALUE};\n    }\n\n    for (int num : nums) {\n        int idx = (num - min_val) / bucket_size;\n        buckets[idx][0] = Math.min(buckets[idx][0], num);\n        buckets[idx][1] = Math.max(buckets[idx][1], num);\n    }\n\n    int max_gap = 0, prev_max = min_val;\n    for (int[] bucket : buckets) {\n        if (bucket[0] == Integer.MAX_VALUE) continue;\n        max_gap = Math.max(max_gap, bucket[0] - prev_max);\n        prev_max = bucket[1];\n    }\n    return max_gap;\n}", "cpp": "int maximumGap(vector<int>& nums) {\n    if (nums.size() < 2) return 0;\n    \n    int min_val = *min_element(nums.begin(), nums.end());\n    int max_val = *max_element(nums.begin(), nums.end());\n    int len = nums.size();\n    int bucket_size = max(1, (max_val - min_val) / (len - 1));\n    int bucket_num = (max_val - min_val) / bucket_size + 1;\n    vector<pair<int, int>> buckets(bucket_num, {INT_MAX, INT_MIN});\n\n    for (int num : nums) {\n        int idx = (num - min_val) / bucket_size;\n        buckets[idx].first = min(buckets[idx].first, num);\n        buckets[idx].second = max(buckets[idx].second, num);\n    }\n\n    int max_gap = 0, prev_max = min_val;\n    for (auto& bucket : buckets) {\n        if (bucket.first == INT_MAX) continue;\n        max_gap = max(max_gap, bucket.first - prev_max);\n        prev_max = bucket.second;\n    }\n    return max_gap;\n}", "javascript": "function maximumGap(nums) {\n    if (nums.length < 2) return 0;\n\n    let min_val = Math.min(...nums);\n    let max_val = Math.max(...nums);\n    let len = nums.length;\n    let bucket_size = Math.max(1, Math.floor((max_val - min_val) / (len - 1)));\n    let bucket_num = Math.floor((max_val - min_val) / bucket_size) + 1;\n    let buckets = Array.from({ length: bucket_num }, () => [Infinity, -Infinity]);\n\n    for (let num of nums) {\n        let idx = Math.floor((num - min_val) / bucket_size);\n        buckets[idx][0] = Math.min(buckets[idx][0], num);\n        buckets[idx][1] = Math.max(buckets[idx][1], num);\n    }\n\n    let max_gap = 0, prev_max = min_val;\n    for (let bucket of buckets) {\n        if (bucket[0] === Infinity) continue;\n        max_gap = Math.max(max_gap, bucket[0] - prev_max);\n        prev_max = bucket[1];\n    }\n    return max_gap;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/165", "prompt": "Given two version numbers, `version1` and `version2`, compare them.\n\nVersion numbers consist of **one or more revisions** joined by a dot `'.'`. Each revision consists of **digits** and may contain leading **zeros**. Every revision contains **at least one character**. Revisions are **0-indexed from left to right**, with the leftmost revision being revision 0, the next revision being revision 1, and so on. For example `2.5.33` and `0.1` are valid version numbers.\n\nTo compare version numbers, compare their revisions in **left-to-right order**. Revisions are compared using their **integer value ignoring any leading zeros**. This means that revisions `1` and `001` are considered **equal**. If a version number does not specify a revision at an index, then **treat the revision as `0`**. For example, version `1.0` is less than version `1.1` because their revision 0s are the same, but their revision 1s are `0` and `1` respectively, and `0 < 1`.\n\n_Return the following:_\n\n*   If `version1 < version2`, return `-1`.\n*   If `version1 > version2`, return `1`.\n*   Otherwise, return `0`.\n\n**Example 1:**\n\n**Input:** version1 =  \"1.01 \", version2 =  \"1.001 \"\n**Output:** 0\n**Explanation:** Ignoring leading zeroes, both  \"01 \" and  \"001 \" represent the same integer  \"1 \".\n\n**Example 2:**\n\n**Input:** version1 =  \"1.0 \", version2 =  \"1.0.0 \"\n**Output:** 0\n**Explanation:** version1 does not specify revision 2, which means it is treated as  \"0 \".\n\n**Example 3:**\n\n**Input:** version1 =  \"0.1 \", version2 =  \"1.1 \"\n**Output:** -1\n**Explanation:** version1's revision 0 is  \"0 \", while version2's revision 0 is  \"1 \". 0 < 1, so version1 < version2.\n\n**Constraints:**\n\n*   `1 <= version1.length, version2.length <= 500`\n*   `version1` and `version2` only contain digits and `'.'`.\n*   `version1` and `version2` **are valid version numbers**.\n*   All the given revisions in `version1` and `version2` can be stored in a **32-bit integer**.", "entry_point": "compare_version_numbers", "canonical_solutions": {"python": "def compare_version(version1, version2):\n    v1 = version1.split('.')\n    v2 = version2.split('.')\n    \n    while v1 or v2:\n        num1 = int(v1.pop(0)) if v1 else 0\n        num2 = int(v2.pop(0)) if v2 else 0\n        \n        if num1 < num2:\n            return -1\n        if num1 > num2:\n            return 1\n    return 0", "java": "public int compareVersion(String version1, String version2) {\n    int i = 0, j = 0;\n    while (i < version1.length() || j < version2.length()) {\n        int num1 = 0, num2 = 0;\n        while (i < version1.length() && version1.charAt(i) != '.') {\n            num1 = num1 * 10 + (version1.charAt(i++) - '0');\n        }\n        while (j < version2.length() && version2.charAt(j) != '.') {\n            num2 = num2 * 10 + (version2.charAt(j++) - '0');\n        }\n        if (num1 < num2) return -1;\n        if (num1 > num2) return 1;\n        i++; j++;\n    }\n    return 0;\n}", "cpp": "int compareVersion(string version1, string version2) {\n    int i = 0, j = 0;\n    while (i < version1.size() || j < version2.size()) {\n        int num1 = 0, num2 = 0;\n        while (i < version1.size() && version1[i] != '.') {\n            num1 = num1 * 10 + (version1[i++] - '0');\n        }\n        while (j < version2.size() && version2[j] != '.') {\n            num2 = num2 * 10 + (version2[j++] - '0');\n        }\n        if (num1 < num2) return -1;\n        if (num1 > num2) return 1;\n        i++; j++;\n    }\n    return 0;\n}", "javascript": "function compareVersion(version1, version2) {\n    const v1 = version1.split('.');\n    const v2 = version2.split('.');\n    \n    while (v1.length > 0 || v2.length > 0) {\n        const num1 = v1.length > 0 ? parseInt(v1.shift()) : 0;\n        const num2 = v2.length > 0 ? parseInt(v2.shift()) : 0;\n        \n        if (num1 < num2) return -1;\n        if (num1 > num2) return 1;\n    }\n    return 0;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/166", "prompt": "Given two integers representing the `numerator` and `denominator` of a fraction, return _the fraction in string format_.\n\nIf the fractional part is repeating, enclose the repeating part in parentheses.\n\nIf multiple answers are possible, return **any of them**.\n\nIt is **guaranteed** that the length of the answer string is less than `104` for all the given inputs.\n\n**Example 1:**\n\n**Input:** numerator = 1, denominator = 2\n**Output:**  \"0.5 \"\n\n**Example 2:**\n\n**Input:** numerator = 2, denominator = 1\n**Output:**  \"2 \"\n\n**Example 3:**\n\n**Input:** numerator = 4, denominator = 333\n**Output:**  \"0.(012) \"\n\n**Constraints:**\n\n*   `-231 <= numerator, denominator <= 231 - 1`\n*   `denominator != 0`", "entry_point": "fraction_to_recurring_decimal", "canonical_solutions": {"python": "def fraction_to_decimal(numerator, denominator):\n    if numerator == 0:\n        return \"0\"\n    res = []\n    if (numerator > 0) ^ (denominator > 0):\n        res.append(\"-\")\n    num = abs(numerator)\n    den = abs(denominator)\n    res.append(str(num // den))\n    num %= den\n    if num == 0:\n        return \"\".join(res)\n    res.append(\".\")\n    map = {}\n    while num:\n        if num in map:\n            res.insert(map[num], \"(\")\n            res.append(\")\")\n            break\n        map[num] = len(res)\n        num *= 10\n        res.append(str(num // den))\n        num %= den\n    return \"\".join(res)", "java": "import java.util.HashMap;\n\npublic String fractionToDecimal(int numerator, int denominator) {\n    if (numerator == 0) return \"0\";\n    StringBuilder res = new StringBuilder();\n    if ((numerator > 0) ^ (denominator > 0)) res.append('-');\n    long num = Math.abs((long)numerator), den = Math.abs((long)denominator);\n    res.append(num / den);\n    num %= den;\n    if (num == 0) return res.toString();\n    res.append('.');\n    HashMap<Long, Integer> map = new HashMap<>();\n    while (num != 0) {\n        if (map.containsKey(num)) {\n            res.insert(map.get(num), \"(\");\n            res.append(\")\");\n            break;\n        }\n        map.put(num, res.length());\n        num *= 10;\n        res.append(num / den);\n        num %= den;\n    }\n    return res.toString();\n}", "cpp": "#include <unordered_map>\nstd::string fractionToDecimal(int numerator, int denominator) {\n    if (numerator == 0) return \"0\";\n    std::string res;\n    if ((numerator > 0) ^ (denominator > 0)) res += '-';\n    long num = std::abs((long)numerator), den = std::abs((long)denominator);\n    res += std::to_string(num / den);\n    num %= den;\n    if (num == 0) return res;\n    res += '.';\n    std::unordered_map<int, int> map;\n    while (num) {\n        if (map.find(num) != map.end()) {\n            res.insert(map[num], \"(\");\n            res += \")\";\n            break;\n        }\n        map[num] = res.size();\n        num *= 10;\n        res += std::to_string(num / den);\n        num %= den;\n    }\n    return res;\n}", "javascript": "function fractionToDecimal(numerator, denominator) {\n    if (numerator === 0) return \"0\";\n    let res = \"\";\n    if ((numerator > 0) ^ (denominator > 0)) res += '-';\n    let num = Math.abs(numerator), den = Math.abs(denominator);\n    res += Math.floor(num / den);\n    num %= den;\n    if (num === 0) return res;\n    res += '.';\n    let map = new Map();\n    while (num) {\n        if (map.has(num)) {\n            res = res.slice(0, map.get(num)) + \"(\" + res.slice(map.get(num)) + \")\";\n            break;\n        }\n        map.set(num, res.length);\n        num *= 10;\n        res += Math.floor(num / den);\n        num %= den;\n    }\n    return res;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/167", "prompt": "Given a **1-indexed** array of integers `numbers` that is already **_sorted in non-decreasing order_**, find two numbers such that they add up to a specific `target` number. Let these two numbers be `numbers[index1]` and `numbers[index2]` where `1 <= index1 < index2 <= numbers.length`.\n\nReturn _the indices of the two numbers,_ `index1` _and_ `index2`_, **added by one** as an integer array_ `[index1, index2]` _of length 2._\n\nThe tests are generated such that there is **exactly one solution**. You **may not** use the same element twice.\n\nYour solution must use only constant extra space.\n\n**Example 1:**\n\n**Input:** numbers = \\[2,7,11,15\\], target = 9\n**Output:** \\[1,2\\]\n**Explanation:** The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return \\[1, 2\\].\n\n**Example 2:**\n\n**Input:** numbers = \\[2,3,4\\], target = 6\n**Output:** \\[1,3\\]\n**Explanation:** The sum of 2 and 4 is 6. Therefore index1 = 1, index2 = 3. We return \\[1, 3\\].\n\n**Example 3:**\n\n**Input:** numbers = \\[\\-1,0\\], target = -1\n**Output:** \\[1,2\\]\n**Explanation:** The sum of -1 and 0 is -1. Therefore index1 = 1, index2 = 2. We return \\[1, 2\\].\n\n**Constraints:**\n\n*   `2 <= numbers.length <= 3 * 104`\n*   `-1000 <= numbers[i] <= 1000`\n*   `numbers` is sorted in **non-decreasing order**.\n*   `-1000 <= target <= 1000`\n*   The tests are generated such that there is **exactly one solution**.", "entry_point": "two_sum_ii_input_array_is_sorted", "canonical_solutions": {"python": "def twoSum(numbers, target):\n    left, right = 0, len(numbers) - 1\n    while left < right:\n        current_sum = numbers[left] + numbers[right]\n        if current_sum == target:\n            return [left + 1, right + 1]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []", "java": "public int[] twoSum(int[] numbers, int target) {\n    int left = 0, right = numbers.length - 1;\n    while (left < right) {\n        int current_sum = numbers[left] + numbers[right];\n        if (current_sum == target) {\n            return new int[]{left + 1, right + 1};\n        } else if (current_sum < target) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return new int[]{};\n}", "cpp": "#include <vector>\nusing namespace std;\n\nvector<int> twoSum(vector<int>& numbers, int target) {\n    int left = 0, right = numbers.size() - 1;\n    while (left < right) {\n        int current_sum = numbers[left] + numbers[right];\n        if (current_sum == target) {\n            return {left + 1, right + 1};\n        } else if (current_sum < target) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return {};\n}", "javascript": "function twoSum(numbers, target) {\n    let left = 0, right = numbers.length - 1;\n    while (left < right) {\n        let current_sum = numbers[left] + numbers[right];\n        if (current_sum === target) {\n            return [left + 1, right + 1];\n        } else if (current_sum < target) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return [];\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/168", "prompt": "Given an integer `columnNumber`, return _its corresponding column title as it appears in an Excel sheet_.\n\nFor example:\n\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n\n**Example 1:**\n\n**Input:** columnNumber = 1\n**Output:**  \"A \"\n\n**Example 2:**\n\n**Input:** columnNumber = 28\n**Output:**  \"AB \"\n\n**Example 3:**\n\n**Input:** columnNumber = 701\n**Output:**  \"ZY \"\n\n**Constraints:**\n\n*   `1 <= columnNumber <= 231 - 1`", "entry_point": "excel_sheet_column_title", "canonical_solutions": {"python": "def convert_to_title(columnNumber: int) -> str:\n    result = \"\"\n    while columnNumber:\n        columnNumber -= 1\n        result = chr(columnNumber % 26 + ord('A')) + result\n        columnNumber //= 26\n    return result", "java": "public String convertToTitle(int columnNumber) {\n    StringBuilder result = new StringBuilder();\n    while (columnNumber > 0) {\n        columnNumber--;\n        result.insert(0, (char) ('A' + columnNumber % 26));\n        columnNumber /= 26;\n    }\n    return result.toString();\n}", "cpp": "#include <string>\n\nstd::string convertToTitle(int columnNumber) {\n    std::string result = \"\";\n    while (columnNumber) {\n        columnNumber--;\n        result = (char)(columnNumber % 26 + 'A') + result;\n        columnNumber /= 26;\n    }\n    return result;\n}", "javascript": "function convertToTitle(columnNumber) {\n    let result = \"\";\n    while (columnNumber) {\n        columnNumber--;\n        result = String.fromCharCode(columnNumber % 26 + 'A'.charCodeAt(0)) + result;\n        columnNumber = Math.floor(columnNumber / 26);\n    }\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/169", "prompt": "Given an array `nums` of size `n`, return _the majority element_.\n\nThe majority element is the element that appears more than `\u230an / 2\u230b` times. You may assume that the majority element always exists in the array.\n\n**Example 1:**\n\n**Input:** nums = \\[3,2,3\\]\n**Output:** 3\n\n**Example 2:**\n\n**Input:** nums = \\[2,2,1,1,1,2,2\\]\n**Output:** 2\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 5 * 104`\n*   `-109 <= nums[i] <= 109`\n\n**Follow-up:** Could you solve the problem in linear time and in `O(1)` space?", "entry_point": "majority_element", "canonical_solutions": {"python": "def majority_element(nums):\n    count = 0\n    candidate = None\n\n    for num in nums:\n        if count == 0:\n            candidate = num\n        count += (num == candidate) - (num != candidate)\n\n    return candidate", "java": "public int majorityElement(int[] nums) {\n    int count = 0;\n    Integer candidate = null;\n\n    for (int num : nums) {\n        if (count == 0) {\n            candidate = num;\n        }\n        count += (num == candidate) ? 1 : -1;\n    }\n\n    return candidate;\n}", "cpp": "int majorityElement(vector<int>& nums) {\n    int count = 0;\n    int candidate;\n\n    for (int num : nums) {\n        if (count == 0) {\n            candidate = num;\n        }\n        count += (num == candidate) ? 1 : -1;\n    }\n\n    return candidate;\n}", "javascript": "function majorityElement(nums) {\n    let count = 0;\n    let candidate = null;\n\n    for (const num of nums) {\n        if (count === 0) {\n            candidate = num;\n        }\n        count += (num === candidate) ? 1 : -1;\n    }\n\n    return candidate;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/170", "prompt": "Design a data structure that accepts a stream of integers and checks if it has a pair of integers that sum up to a particular value.\n\nImplement the `TwoSum` class:\n\n*   `TwoSum()` Initializes the `TwoSum` object, with an empty array initially.\n*   `void add(int number)` Adds `number` to the data structure.\n*   `boolean find(int value)` Returns `true` if there exists any pair of numbers whose sum is equal to `value`, otherwise, it returns `false`.\n\n**Example 1:**\n\n**Input**\n\\[ \"TwoSum \",  \"add \",  \"add \",  \"add \",  \"find \",  \"find \"\\]\n\\[\\[\\], \\[1\\], \\[3\\], \\[5\\], \\[4\\], \\[7\\]\\]\n**Output**\n\\[null, null, null, null, true, false\\]\n\n**Explanation**\nTwoSum twoSum = new TwoSum();\ntwoSum.add(1);   // \\[\\] --> \\[1\\]\ntwoSum.add(3);   // \\[1\\] --> \\[1,3\\]\ntwoSum.add(5);   // \\[1,3\\] --> \\[1,3,5\\]\ntwoSum.find(4);  // 1 + 3 = 4, return true\ntwoSum.find(7);  // No two integers sum up to 7, return false\n\n**Constraints:**\n\n*   `-105 <= number <= 105`\n*   `-231 <= value <= 231 - 1`\n*   At most `104` calls will be made to `add` and `find`.", "entry_point": "two_sum_iii_data_structure_design", "canonical_solutions": {"python": "class TwoSum:\n\n    def __init__(self):\n        self.nums = {}\n\n    def add(self, number: int) -> None:\n        if number in self.nums:\n            self.nums[number] += 1\n        else:\n            self.nums[number] = 1\n\n    def find(self, value: int) -> bool:\n        for num in self.nums:\n            target = value - num\n            if target in self.nums:\n                if target != num or self.nums[num] > 1:\n                    return True\n        return False", "java": "import java.util.HashMap;\n\nclass TwoSum {\n    private HashMap<Integer, Integer> nums;\n\n    public TwoSum() {\n        nums = new HashMap<>();\n    }\n\n    public void add(int number) {\n        nums.put(number, nums.getOrDefault(number, 0) + 1);\n    }\n\n    public boolean find(int value) {\n        for (Integer i : nums.keySet()) {\n            int complement = value - i;\n            if (nums.containsKey(complement)) {\n                if (i != complement || nums.get(i) > 1) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}", "cpp": "class TwoSum {\npublic:\n    unordered_map<int, int> m;\n\n    TwoSum() {\n\n    }\n\n    void add(int number) {\n        m[number]++;\n    }\n\n    bool find(int value) {\n        for (auto &pair : m) {\n            int num1 = pair.first;\n            int num2 = value - num1;\n            if (num1 == num2 && pair.second > 1 || num1 != num2 && m.count(num2)) {\n                return true;\n            }\n        }\n        return false;\n    }\n};", "javascript": "class TwoSum {\n    constructor() {\n        this.nums = {};\n    }\n\n    add(number) {\n        if (this.nums.hasOwnProperty(number)) {\n            this.nums[number]++;\n        } else {\n            this.nums[number] = 1;\n        }\n    }\n\n    find(value) {\n        for (let num in this.nums) {\n            let target = value - num;\n            if (this.nums.hasOwnProperty(target)) {\n                if (target !== num || this.nums[num] > 1) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/171", "prompt": "Given a string `columnTitle` that represents the column title as appears in an Excel sheet, return _its corresponding column number_.\n\nFor example:\n\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n\n**Example 1:**\n\n**Input:** columnTitle =  \"A \"\n**Output:** 1\n\n**Example 2:**\n\n**Input:** columnTitle =  \"AB \"\n**Output:** 28\n\n**Example 3:**\n\n**Input:** columnTitle =  \"ZY \"\n**Output:** 701\n\n**Constraints:**\n\n*   `1 <= columnTitle.length <= 7`\n*   `columnTitle` consists only of uppercase English letters.\n*   `columnTitle` is in the range `[ \"A \", \"FXSHRXW \"]`.", "entry_point": "excel_sheet_column_number", "canonical_solutions": {"python": "def title_to_number(column_title: str) -> int:\n    result = 0\n    for c in column_title:\n        result = result * 26 + (ord(c) - ord('A') + 1)\n    return result", "java": "public int titleToNumber(String columnTitle) {\n    int result = 0;\n    for (char c : columnTitle.toCharArray()) {\n        result = result * 26 + (c - 'A' + 1);\n    }\n    return result;\n}", "cpp": "int titleToNumber(string columnTitle) {\n    int result = 0;\n    for (char c : columnTitle) {\n        result = result * 26 + (c - 'A' + 1);\n    }\n    return result;\n}", "javascript": "function titleToNumber(columnTitle) {\n    let result = 0;\n    for (let c of columnTitle) {\n        result = result * 26 + (c.charCodeAt(0) - 'A'.charCodeAt(0) + 1);\n    }\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/172", "prompt": "Given an integer `n`, return _the number of trailing zeroes in_ `n!`.\n\nNote that `n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1`.\n\n**Example 1:**\n\n**Input:** n = 3\n**Output:** 0\n**Explanation:** 3! = 6, no trailing zero.\n\n**Example 2:**\n\n**Input:** n = 5\n**Output:** 1\n**Explanation:** 5! = 120, one trailing zero.\n\n**Example 3:**\n\n**Input:** n = 0\n**Output:** 0\n\n**Constraints:**\n\n*   `0 <= n <= 104`\n\n**Follow up:** Could you write a solution that works in logarithmic time complexity?", "entry_point": "factorial_trailing_zeroes", "canonical_solutions": {"python": "def trailing_zeroes(n: int) -> int:\n    count = 0\n    while n > 0:\n        n //= 5\n        count += n\n    return count", "java": "public int trailingZeroes(int n) {\n    int count = 0;\n    while (n > 0) {\n        n = n / 5;\n        count += n;\n    }\n    return count;\n}", "cpp": "int trailingZeroes(int n) {\n    int count = 0;\n    while (n > 0) {\n        n /= 5;\n        count += n;\n    }\n    return count;\n}", "javascript": "function trailingZeroes(n) {\n    let count = 0;\n    while (n > 0) {\n        n = Math.floor(n / 5);\n        count += n;\n    }\n    return count;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/173", "prompt": "Implement the `BSTIterator` class that represents an iterator over the **[in-order traversal](https://en.wikipedia.org/wiki/Tree_traversal#In-order_(LNR))** of a binary search tree (BST):\n\n*   `BSTIterator(TreeNode root)` Initializes an object of the `BSTIterator` class. The `root` of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.\n*   `boolean hasNext()` Returns `true` if there exists a number in the traversal to the right of the pointer, otherwise returns `false`.\n*   `int next()` Moves the pointer to the right, then returns the number at the pointer.\n\nNotice that by initializing the pointer to a non-existent smallest number, the first call to `next()` will return the smallest element in the BST.\n\nYou may assume that `next()` calls will always be valid. That is, there will be at least a next number in the in-order traversal when `next()` is called.\n\n**Example 1:**\n\n**Input**\n\\[ \"BSTIterator \",  \"next \",  \"next \",  \"hasNext \",  \"next \",  \"hasNext \",  \"next \",  \"hasNext \",  \"next \",  \"hasNext \"\\]\n\\[\\[\\[7, 3, 15, null, null, 9, 20\\]\\], \\[\\], \\[\\], \\[\\], \\[\\], \\[\\], \\[\\], \\[\\], \\[\\], \\[\\]\\]\n**Output**\n\\[null, 3, 7, true, 9, true, 15, true, 20, false\\]\n\n**Explanation**\nBSTIterator bSTIterator = new BSTIterator(\\[7, 3, 15, null, null, 9, 20\\]);\nbSTIterator.next();    // return 3\nbSTIterator.next();    // return 7\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 9\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 15\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 20\nbSTIterator.hasNext(); // return False\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 105]`.\n*   `0 <= Node.val <= 106`\n*   At most `105` calls will be made to `hasNext`, and `next`.\n\n**Follow up:**\n\n*   Could you implement `next()` and `hasNext()` to run in average `O(1)` time and use `O(h)` memory, where `h` is the height of the tree?", "entry_point": "binary_search_tree_iterator", "canonical_solutions": {"python": "class BSTIterator:\n\n    def __init__(self, root):\n        self.stack = []\n        self.push_left(root)\n\n    def next(self):\n        top = self.stack.pop()\n        self.push_left(top.right)\n        return top.val\n\n    def hasNext(self):\n        return len(self.stack) > 0\n\n    def push_left(self, node):\n        while node:\n            self.stack.append(node)\n            node = node.left", "java": "import java.util.Stack;\n\npublic class BSTIterator {\n    private final Stack<TreeNode> stack;\n\n    public BSTIterator(TreeNode root) {\n        stack = new Stack<>();\n        pushLeft(root);\n    }\n\n    public int next() {\n        TreeNode top = stack.pop();\n        pushLeft(top.right);\n        return top.val;\n    }\n\n    public boolean hasNext() {\n        return !stack.isEmpty();\n    }\n\n    private void pushLeft(TreeNode node) {\n        while (node != null) {\n            stack.push(node);\n            node = node.left;\n        }\n    }\n}", "cpp": "class BSTIterator {\npublic:\n    stack<TreeNode*> stk;\n\n    BSTIterator(TreeNode* root) {\n        pushLeft(root);\n    }\n\n    int next() {\n        TreeNode* top = stk.top();\n        stk.pop();\n        pushLeft(top->right);\n        return top->val;\n    }\n\n    bool hasNext() {\n        return !stk.empty();\n    }\n\nprivate:\n    void pushLeft(TreeNode* node) {\n        while (node) {\n            stk.push(node);\n            node = node->left;\n        }\n    }\n};", "javascript": "class BSTIterator {\n    constructor(root) {\n        this.stack = [];\n        this.pushLeft(root);\n    }\n\n    next() {\n        let top = this.stack.pop();\n        this.pushLeft(top.right);\n        return top.val;\n    }\n\n    hasNext() {\n        return this.stack.length > 0;\n    }\n\n    pushLeft(node) {\n        while (node) {\n            this.stack.push(node);\n            node = node.left;\n        }\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/174", "prompt": "The demons had captured the princess and imprisoned her in **the bottom-right corner** of a `dungeon`. The `dungeon` consists of `m x n` rooms laid out in a 2D grid. Our valiant knight was initially positioned in **the top-left room** and must fight his way through `dungeon` to rescue the princess.\n\nThe knight has an initial health point represented by a positive integer. If at any point his health point drops to `0` or below, he dies immediately.\n\nSome of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight's health (represented by positive integers).\n\nTo reach the princess as quickly as possible, the knight decides to move only **rightward** or **downward** in each step.\n\nReturn _the knight's minimum initial health so that he can rescue the princess_.\n\n**Note** that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.\n\n**Example 1:**\n\n**Input:** dungeon = \\[\\[-2,-3,3\\],\\[-5,-10,1\\],\\[10,30,-5\\]\\]\n**Output:** 7\n**Explanation:** The initial health of the knight must be at least 7 if he follows the optimal path: RIGHT-> RIGHT -> DOWN -> DOWN.\n\n**Example 2:**\n\n**Input:** dungeon = \\[\\[0\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `m == dungeon.length`\n*   `n == dungeon[i].length`\n*   `1 <= m, n <= 200`\n*   `-1000 <= dungeon[i][j] <= 1000`", "entry_point": "dungeon_game", "canonical_solutions": {"python": "def calculateMinimumHP(dungeon):\n    m, n = len(dungeon), len(dungeon[0])\n    dp = [[0] * n for _ in range(m)]\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if i == m - 1 and j == n - 1:\n                dp[i][j] = min(0, dungeon[i][j])\n            elif i == m - 1:\n                dp[i][j] = min(0, dp[i][j + 1] + dungeon[i][j])\n            elif j == n - 1:\n                dp[i][j] = min(0, dp[i + 1][j] + dungeon[i][j])\n            else:\n                dp[i][j] = min(0, max(dp[i + 1][j], dp[i][j + 1]) + dungeon[i][j])\n\n    return abs(dp[0][0]) + 1", "java": "public int calculateMinimumHP(int[][] dungeon) {\n    int m = dungeon.length, n = dungeon[0].length;\n    int[][] dp = new int[m][n];\n\n    for (int i = m - 1; i >= 0; i--) {\n        for (int j = n - 1; j >= 0; j--) {\n            if(i == m-1 && j == n-1)\n                dp[i][j] = Math.min(0, dungeon[i][j]);\n            else if (i == m - 1)\n                dp[i][j] = Math.min(0, dp[i][j + 1] + dungeon[i][j]);\n            else if (j == n - 1)\n                dp[i][j] = Math.min(0, dp[i + 1][j] + dungeon[i][j]);\n            else\n                dp[i][j] = Math.min(0, Math.max(dp[i + 1][j], dp[i][j + 1]) + dungeon[i][j]);\n        }\n    }\n\n    return Math.abs(dp[0][0]) + 1;\n}", "cpp": "#include<vector>\nusing namespace std;\n\nint calculateMinimumHP(vector<vector<int>>& dungeon) {\n    int m = dungeon.size(), n = dungeon[0].size();\n    vector<vector<int>> dp(m, vector<int>(n));\n\n    for (int i = m - 1; i >= 0; i--) {\n        for (int j = n - 1; j >= 0; j--) {\n            if(i == m-1 && j == n-1){\n                dp[i][j] = min(0, dungeon[i][j]);\n            }\n            else if (i == m - 1) {\n                dp[i][j] = min(0, dp[i][j + 1] + dungeon[i][j]);\n            }\n            else if (j == n - 1) {\n                dp[i][j] = min(0, dp[i + 1][j] + dungeon[i][j]);\n            }\n            else {\n                dp[i][j] = min(0, max(dp[i + 1][j], dp[i][j + 1]) + dungeon[i][j]);\n            }\n        }\n    }\n\n    return abs(dp[0][0]) + 1;\n}", "javascript": "function calculateMinimumHP(dungeon) {\n    const m = dungeon.length, n = dungeon[0].length;\n    const dp = new Array(m).fill(0).map(() => new Array(n).fill(0));\n\n    for (let i = m - 1; i >= 0; i--) {\n        for (let j = n - 1; j >= 0; j--) {\n            if (i === m - 1 && j === n - 1)\n                dp[i][j] = Math.min(0, dungeon[i][j]);\n            else if (i === m - 1)\n                dp[i][j] = Math.min(0, dp[i][j + 1] + dungeon[i][j]);\n            else if (j === n - 1)\n                dp[i][j] = Math.min(0, dp[i + 1][j] + dungeon[i][j]);\n            else\n                dp[i][j] = Math.min(0, Math.max(dp[i + 1][j], dp[i][j + 1]) + dungeon[i][j]);\n        }\n    }\n\n    return Math.abs(dp[0][0]) + 1;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/179", "prompt": "Given a list of non-negative integers `nums`, arrange them such that they form the largest number and return it.\n\nSince the result may be very large, so you need to return a string instead of an integer.\n\n**Example 1:**\n\n**Input:** nums = \\[10,2\\]\n**Output:**  \"210 \"\n\n**Example 2:**\n\n**Input:** nums = \\[3,30,34,5,9\\]\n**Output:**  \"9534330 \"\n\n**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 109`", "entry_point": "largest_number", "canonical_solutions": {"python": "from functools import cmp_to_key\n\ndef largestNumber(nums):\n    def comparator(a, b):\n        return -1 if a + b > b + a else int(a + b < b + a)\n\n    nums_as_str = list(map(str, nums))\n    nums_as_str.sort(key=cmp_to_key(comparator))\n    return '0' if nums_as_str[0] == \"0\" else \"\".join(nums_as_str)", "java": "import java.util.Arrays;\nimport java.util.Comparator;\n\npublic class Solution {\n    public String largestNumber(int[] nums) {\n        String[] strNums = new String[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            strNums[i] = String.valueOf(nums[i]);\n        }\n        Arrays.sort(strNums, (a, b) -> (b + a).compareTo(a + b));\n        if (strNums[0].equals(\"0\")) {\n            return \"0\";\n        }\n        StringBuilder sb = new StringBuilder();\n        for (String str : strNums) sb.append(str);\n        return sb.toString();\n    }\n}", "cpp": "#include <algorithm>\n#include <string>\n#include <vector>\n\nbool compare(std::string a, std::string b) {\n    return a+b > b+a;\n}\n\nstd::string largestNumber(std::vector<int>& nums) {\n    std::vector<std::string> asStrs;\n    for (int num : nums) asStrs.push_back(std::to_string(num));\n    std::sort(asStrs.begin(), asStrs.end(), compare);\n    std::string res;\n    for (std::string s: asStrs) res += s;\n    return res[0] == '0' ? \"0\" : res;\n}", "javascript": "function largestNumber(nums) {\n    const numsAsStrings = nums.map(String);\n    numsAsStrings.sort((a, b) => (b + a).localeCompare(a + b));\n    return numsAsStrings[0] === '0' ? '0' : numsAsStrings.join('');\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/186", "prompt": "Given a character array `s`, reverse the order of the **words**.\n\nA **word** is defined as a sequence of non-space characters. The **words** in `s` will be separated by a single space.\n\nYour code must solve the problem **in-place,** i.e. without allocating extra space.\n\n**Example 1:**\n\n**Input:** s = \\[\"t\",\"h\",\"e\",\" \",\"s\",\"k\",\"y\",\" \",\"i\",\"s\",\" \",\"b\",\"l\",\"u\",\"e\"\\]\n**Output:** \\[\"b\",\"l\",\"u\",\"e\",\" \",\"i\",\"s\",\" \",\"s\",\"k\",\"y\",\" \",\"t\",\"h\",\"e\"\\]\n\n**Example 2:**\n\n**Input:** s = \\[\"a\"\\]\n**Output:** \\[\"a\"\\]\n\n**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s[i]` is an English letter (uppercase or lowercase), digit, or space `' '`.\n*   There is **at least one** word in `s`.\n*   `s` does not contain leading or trailing spaces.\n*   All the words in `s` are guaranteed to be separated by a single space.", "entry_point": "reverse_words_in_a_string_ii", "canonical_solutions": {"python": "def reverseWords(s: list) -> None:\n    def reverse(s, start, end):\n        while start < end:\n            s[start], s[end] = s[end], s[start]\n            start += 1\n            end -= 1\n\n    reverse(s, 0, len(s)-1)\n    start = 0\n    for i, char in enumerate(s + [' ']):\n        if char == ' ':\n            reverse(s, start, i - 1)\n            start = i + 1", "java": "public void reverseWords(char[] s) {\n    reverse(s, 0, s.length - 1);\n    int start = 0;\n    for (int i = 0; i <= s.length; i++) {\n        if (i == s.length || s[i] == ' ') {\n            reverse(s, start, i - 1);\n            start = i + 1;\n        }\n    }\n}\n\nprivate void reverse(char[] s, int start, int end) {\n    while (start < end) {\n        char temp = s[start];\n        s[start++] = s[end];\n        s[end--] = temp;\n    }\n}", "cpp": "void reverseWords(vector<char>& s) {\n    reverse(s.begin(), s.end());\n    int start = 0, end;\n    while ((end = find(s.begin() + start, s.end(), ' ') - s.begin()) < s.size()) {\n        reverse(s.begin() + start, s.begin() + end);\n        start = end + 1;\n    }\n    reverse(s.begin() + start, s.end());\n}", "javascript": "function reverseWords(s) {\n    function reverse(s, start, end) {\n        while (start < end) {\n            [s[start], s[end]] = [s[end], s[start]];\n            start++;\n            end--;\n        }\n    }\n\n    reverse(s, 0, s.length - 1);\n    let start = 0;\n    for (let i = 0; i <= s.length; i++) {\n        if (i === s.length || s[i] === ' ') {\n            reverse(s, start, i - 1);\n            start = i + 1;\n        }\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/187", "prompt": "The **DNA sequence** is composed of a series of nucleotides abbreviated as `'A'`, `'C'`, `'G'`, and `'T'`.\n\n*   For example, `\"ACGAATTCCG \"` is a **DNA sequence**.\n\nWhen studying **DNA**, it is useful to identify repeated sequences within the DNA.\n\nGiven a string `s` that represents a **DNA sequence**, return all the **`10`\\-letter-long** sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in **any order**.\n\n**Example 1:**\n\n**Input:** s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\n**Output:** \\[\"AAAAACCCCC\",\"CCCCCAAAAA\"\\]\n\n**Example 2:**\n\n**Input:** s = \"AAAAAAAAAAAAA\"\n**Output:** \\[\"AAAAAAAAAA\"\\]\n\n**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s[i]` is either `'A'`, `'C'`, `'G'`, or `'T'`.", "entry_point": "repeated_dna_sequences", "canonical_solutions": {"python": "from collections import defaultdict\n\ndef findRepeatedDnaSequences(s: str):\n    dna_counter = defaultdict(int)\n    result = []\n\n    for i in range(len(s) - 9):\n        sequence = s[i:i + 10]\n        dna_counter[sequence] += 1\n        if dna_counter[sequence] == 2:\n            result.append(sequence)\n\n    return result", "java": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\n\npublic List<String> findRepeatedDnaSequences(String s) {\n    List<String> result = new ArrayList<>();\n    HashMap<String, Integer> dnaCounter = new HashMap<>();\n\n    for (int i = 0; i <= s.length() - 10; i++) {\n        String sequence = s.substring(i, i + 10);\n        dnaCounter.put(sequence, dnaCounter.getOrDefault(sequence, 0) + 1);\n        if (dnaCounter.get(sequence) == 2) {\n            result.add(sequence);\n        }\n    }\n\n    return result;\n}", "cpp": "#include <vector>\n#include <string>\n#include <unordered_map>\n\nstd::vector<std::string> findRepeatedDnaSequences(std::string s) {\n    std::vector<std::string> result;\n    std::unordered_map<std::string, int> dna_counter;\n\n    for (size_t i = 0; i <= s.length() - 10; ++i) {\n        std::string sequence = s.substr(i, 10);\n        dna_counter[sequence]++;\n        if (dna_counter[sequence] == 2) {\n            result.push_back(sequence);\n        }\n    }\n\n    return result;\n}", "javascript": "function findRepeatedDnaSequences(s) {\n    const dnaCounter = new Map();\n    const result = [];\n\n    for (let i = 0; i <= s.length - 10; i++) {\n        const sequence = s.slice(i, i + 10);\n        dnaCounter.set(sequence, (dnaCounter.get(sequence) || 0) + 1);\n        if (dnaCounter.get(sequence) === 2) {\n            result.push(sequence);\n        }\n    }\n\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/188", "prompt": "You are given an integer array `prices` where `prices[i]` is the price of a given stock on the `ith` day, and an integer `k`.\n\nFind the maximum profit you can achieve. You may complete at most `k` transactions: i.e. you may buy at most `k` times and sell at most `k` times.\n\n**Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\n**Example 1:**\n\n**Input:** k = 2, prices = \\[2,4,1\\]\n**Output:** 2\n**Explanation:** Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.\n\n**Example 2:**\n\n**Input:** k = 2, prices = \\[3,2,6,5,0,3\\]\n**Output:** 7\n**Explanation:** Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\n\n**Constraints:**\n\n*   `1 <= k <= 100`\n*   `1 <= prices.length <= 1000`\n*   `0 <= prices[i] <= 1000`", "entry_point": "best_time_to_buy_and_sell_stock_iv", "canonical_solutions": {"python": "def maxProfit(k, prices):\n    n = len(prices)\n    if k > n // 2:\n        return sum(max(prices[i] - prices[i - 1], 0) for i in range(1, n))\n\n    dp = [[0] * n for _ in range(k + 1)]\n    for i in range(1, k + 1):\n        max_diff = -prices[0]\n        for j in range(1, n):\n            dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff)\n            max_diff = max(max_diff, dp[i - 1][j] - prices[j])\n    return dp[k][n - 1]", "java": "public int maxProfit(int k, int[] prices) {\n    int n = prices.length;\n    if (k > n / 2) {\n        int maxProfit = 0;\n        for (int i = 1; i < n; ++i)\n            maxProfit += Math.max(prices[i] - prices[i - 1], 0);\n        return maxProfit;  \n    }\n\n    int[][] dp = new int[k + 1][n];\n    for (int i = 1; i <= k; ++i) {\n        int maxDiff = -prices[0];\n        for (int j = 1; j < n; ++j) {\n            dp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff);\n            maxDiff = Math.max(maxDiff, dp[i - 1][j] - prices[j]);\n        }\n    }\n    return dp[k][n - 1];\n}", "cpp": "#include <vector>\n#include <algorithm>\nint maxProfit(int k, std::vector<int>& prices) {\n    int n = prices.size();\n    if (k > n / 2) {\n        int max_profit = 0;\n        for (int i = 1; i < n; ++i)\n            max_profit += std::max(prices[i] - prices[i - 1], 0);\n        return max_profit;  \n    }\n\n    std::vector<std::vector<int>> dp(k + 1, std::vector<int>(n, 0));\n    for (int i = 1; i <= k; ++i) {\n        int max_diff = -prices[0];\n        for (int j = 1; j < n; ++j) {\n            dp[i][j] = std::max(dp[i][j - 1], prices[j] + max_diff);\n            max_diff = std::max(max_diff, dp[i - 1][j] - prices[j]);\n        }\n    }\n    return dp[k][n - 1];\n}", "javascript": "function maxProfit(k, prices) {\n    let n = prices.length;\n    if (k > n / 2) {\n        let maxProfit = 0;\n        for (let i = 1; i < n; ++i)\n            maxProfit += Math.max(prices[i] - prices[i - 1], 0);\n        return maxProfit;  \n    }\n\n    let dp = new Array(k + 1).fill(null).map(() => new Array(n).fill(0));\n    for (let i = 1; i <= k; ++i) {\n        let maxDiff = -prices[0];\n        for (let j = 1; j < n; ++j) {\n            dp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff);\n            maxDiff = Math.max(maxDiff, dp[i - 1][j] - prices[j]);\n        }\n    }\n    return dp[k][n - 1];\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/189", "prompt": "Given an integer array `nums`, rotate the array to the right by `k` steps, where `k` is non-negative.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3,4,5,6,7\\], k = 3\n**Output:** \\[5,6,7,1,2,3,4\\]\n**Explanation:**\nrotate 1 steps to the right: \\[7,1,2,3,4,5,6\\]\nrotate 2 steps to the right: \\[6,7,1,2,3,4,5\\]\nrotate 3 steps to the right: \\[5,6,7,1,2,3,4\\]\n\n**Example 2:**\n\n**Input:** nums = \\[-1,-100,3,99\\], k = 2\n**Output:** \\[3,99,-1,-100\\]\n**Explanation:** \nrotate 1 steps to the right: \\[99,-1,-100,3\\]\nrotate 2 steps to the right: \\[3,99,-1,-100\\]\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-231 <= nums[i] <= 231 - 1`\n*   `0 <= k <= 105`\n\n**Follow up:**\n\n*   Try to come up with as many solutions as you can. There are at least **three** different ways to solve this problem.\n*   Could you do it in-place with `O(1)` extra space?", "entry_point": "rotate_array", "canonical_solutions": {"python": "def rotate(nums, k):\n    n = len(nums)\n    k %= n\n    nums[:] = nums[-k:] + nums[:-k]", "java": "public void rotate(int[] nums, int k) {\n    int n = nums.length;\n    k %= n;\n    reverse(nums, 0, n - 1);\n    reverse(nums, 0, k - 1);\n    reverse(nums, k, n - 1);\n}\n\nprivate void reverse(int[] nums, int start, int end) {\n    while (start < end) {\n        int temp = nums[start];\n        nums[start++] = nums[end];\n        nums[end--] = temp;\n    }\n}", "cpp": "#include <vector>\nusing namespace std;\n\nvoid rotate(vector<int>& nums, int k) {\n    int n = nums.size();\n    k %= n;\n    reverse(nums.begin(), nums.end());\n    reverse(nums.begin(), nums.begin() + k);\n    reverse(nums.begin() + k, nums.end());\n}", "javascript": "function rotate(nums, k) {\n    const n = nums.length;\n    k %= n;\n    reverse(nums, 0, n - 1);\n    reverse(nums, 0, k - 1);\n    reverse(nums, k, n - 1);\n}\n\nfunction reverse(nums, start, end) {\n    while (start < end) {\n        [nums[start], nums[end]] = [nums[end], nums[start]];\n        start++;\n        end--;\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/190", "prompt": "Reverse bits of a given 32 bits unsigned integer.\n\n**Note:**\n\n*   Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.\n*   In Java, the compiler represents the signed integers using [2's complement notation](https://en.wikipedia.org/wiki/Two%27s_complement). Therefore, in **Example 2** above, the input represents the signed integer `-3` and the output represents the signed integer `-1073741825`.\n\n**Example 1:**\n\n**Input:** n = 00000010100101000001111010011100\n**Output:**    964176192 (00111001011110000010100101000000)\n**Explanation:** The input binary string **00000010100101000001111010011100** represents the unsigned integer 43261596, so return 964176192 which its binary representation is **00111001011110000010100101000000**.\n\n**Example 2:**\n\n**Input:** n = 11111111111111111111111111111101\n**Output:**   3221225471 (10111111111111111111111111111111)\n**Explanation:** The input binary string **11111111111111111111111111111101** represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is **10111111111111111111111111111111**.\n\n**Constraints:**\n\n*   The input must be a **binary string** of length `32`\n\n**Follow up:** If this function is called many times, how would you optimize it?", "entry_point": "reverse_bits", "canonical_solutions": {"python": "def reverse_bits(n: int) -> int:\n    res = 0\n    for _ in range(32):\n        res <<= 1\n        res |= n & 1\n        n >>= 1\n    return res", "java": "public int reverseBits(int n) {\n    int res = 0;\n    for (int i = 0; i < 32; ++i) {\n        res <<= 1;\n        res |= n & 1;\n        n >>= 1;\n    }\n    return res;\n}", "cpp": "unsigned int reverseBits(unsigned int n) {\n    unsigned int res = 0;\n    for (int i = 0; i < 32; ++i) {\n        res <<= 1;\n        res |= n & 1;\n        n >>= 1;\n    }\n    return res;\n}", "javascript": "function reverseBits(n) {\n    let res = 0;\n    for (let i = 0; i < 32; ++i) {\n        res <<= 1;\n        res |= n & 1;\n        n >>= 1;\n    }\n    return res >>> 0;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/191", "prompt": "Write a function that takes the binary representation of an unsigned integer and returns the number of '1' bits it has (also known as the [Hamming weight](http://en.wikipedia.org/wiki/Hamming_weight)).\n\n**Note:**\n\n*   Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.\n*   In Java, the compiler represents the signed integers using [2's complement notation](https://en.wikipedia.org/wiki/Two%27s_complement). Therefore, in **Example 3**, the input represents the signed integer. `-3`.\n\n**Example 1:**\n\n**Input:** n = 00000000000000000000000000001011\n**Output:** 3\n**Explanation:** The input binary string **00000000000000000000000000001011** has a total of three '1' bits.\n\n**Example 2:**\n\n**Input:** n = 00000000000000000000000010000000\n**Output:** 1\n**Explanation:** The input binary string **00000000000000000000000010000000** has a total of one '1' bit.\n\n**Example 3:**\n\n**Input:** n = 11111111111111111111111111111101\n**Output:** 31\n**Explanation:** The input binary string **11111111111111111111111111111101** has a total of thirty one '1' bits.\n\n**Constraints:**\n\n*   The input must be a **binary string** of length `32`.\n\n**Follow up:** If this function is called many times, how would you optimize it?", "entry_point": "number_of_1_bits", "canonical_solutions": {"python": "def hamming_weight(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count", "java": "public int hammingWeight(int n) {\n    int count = 0;\n    while (n != 0) {\n        count += n & 1;\n        n >>>= 1;\n    }\n    return count;\n}", "cpp": "int hammingWeight(uint32_t n) {\n    int count = 0;\n    while (n != 0) {\n        count += n & 1;\n        n >>= 1;\n    }\n    return count;\n}", "javascript": "function hammingWeight(n) {\n    let count = 0;\n    while (n != 0) {\n        count += n & 1;\n        n >>>= 1;\n    }\n    return count;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/194", "prompt": "Given a text file `file.txt`, transpose its content.\n\nYou may assume that each row has the same number of columns, and each field is separated by the `' '` character.\n\n**Example:**\n\nIf `file.txt` has the following content:\n\nname age\nalice 21\nryan 30\n\nOutput the following:\n\nname alice ryan\nage 21 30", "entry_point": "title_slug", "canonical_solutions": {"python": "def transpose(content):\n    data = [line.split(\" \") for line in content]\n    result = [\" \".join(data[j][i] for j in range(len(data))) for i in range(len(data[0]))]\n    return result", "java": "import java.util.*;\n\npublic List<String> transpose(List<String> content) {\n    List<List<String>> data = new ArrayList<>();\n    for (String line : content) {\n        List<String> row = new ArrayList<>(Arrays.asList(line.split(\" \")));\n        data.add(row);\n    }\n\n    List<String> result = new ArrayList<>(Collections.nCopies(data.get(0).size(), \"\"));\n    for (int i = 0; i < data.get(0).size(); i++) {\n        for (int j = 0; j < data.size(); j++) {\n            result.set(i, result.get(i) + (j > 0 ? \" \" : \"\") + data.get(j).get(i));\n        }\n    }\n\n    return result;\n}", "cpp": "#include <vector>\n#include <string>\n#include <sstream>\n\nstd::vector<std::string> transpose(std::vector<std::string> &content)\n{\n    std::vector<std::vector<std::string>> data;\n    for (const std::string &line : content)\n    {\n        std::vector<std::string> row;\n        std::stringstream ss(line);\n        std::string word;\n        while (ss >> word)\n            row.push_back(word);\n        data.push_back(row);\n    }\n\n    std::vector<std::string> result(data[0].size(), \"\");\n    for (size_t i = 0; i < data[0].size(); ++i)\n    {\n        for (size_t j = 0; j < data.size(); ++j)\n        {\n            result[i] += data[j][i];\n            if (j < data.size() - 1)\n                result[i] += \" \";\n        }\n    }\n\n    return result;\n}", "javascript": "function transpose(content) {\n    let data = content.map(line => line.split(\" \"));\n    let result = new Array(data[0].length).fill(\"\");\n    for (let i = 0; i < data[0].length; i++) {\n        for (let j = 0; j < data.length; j++) {\n            result[i] += (j > 0 ? \" \" : \"\") + data[j][i];\n        }\n    }\n\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/198", "prompt": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\n\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n\n**Example 2:**\n\n**Input:** nums = \\[2,7,9,3,1\\]\n**Output:** 12\n**Explanation:** Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 400`", "entry_point": "house_robber", "canonical_solutions": {"python": "def rob(nums):\n    prev1, prev2 = 0, 0\n    for num in nums:\n        prev1, prev2 = max(prev2 + num, prev1), prev1\n    return prev1", "java": "public int rob(int[] nums) {\n    int prev1 = 0, prev2 = 0;\n    for (int num : nums) {\n        int temp = prev1;\n        prev1 = Math.max(prev2 + num, prev1);\n        prev2 = temp;\n    }\n    return prev1;\n}", "cpp": "int rob(vector<int>& nums) {\n    int prev1 = 0, prev2 = 0;\n    for (const auto& num : nums) {\n        int tmp = prev1;\n        prev1 = max(prev2 + num, prev1);\n        prev2 = tmp;\n    }\n    return prev1;\n}", "javascript": "function rob(nums) {\n    let prev1 = 0, prev2 = 0;\n    for (let num of nums) {\n        let temp = prev1;\n        prev1 = Math.max(prev2 + num, prev1);\n        prev2 = temp;\n    }\n    return prev1;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/199", "prompt": "Given the `root` of a binary tree, imagine yourself standing on the **right side** of it, return _the values of the nodes you can see ordered from top to bottom_.\n\n**Example 1:**\n\n**Input:** root = \\[1,2,3,null,5,null,4\\]\n**Output:** \\[1,3,4\\]\n\n**Example 2:**\n\n**Input:** root = \\[1,null,3\\]\n**Output:** \\[1,3\\]\n\n**Example 3:**\n\n**Input:** root = \\[\\]\n**Output:** \\[\\]\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 100]`.\n*   `-100 <= Node.val <= 100`", "entry_point": "binary_tree_right_side_view", "canonical_solutions": {"python": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef rightSideView(root):\n    if not root:\n        return []\n\n    result = []\n    queue = [root]\n\n    while queue:\n        level_size = len(queue)\n\n        for i in range(level_size):\n            current = queue.pop(0)\n\n            if i == level_size - 1:\n                result.append(current.val)\n            \n            if current.left:\n                queue.append(current.left)\n            if current.right:\n                queue.append(current.right)\n\n    return result", "java": "import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int _val) { val = _val; }\n}\n\npublic List<Integer> rightSideView(TreeNode root) {\n    if (root == null) return new ArrayList<>();\n\n    List<Integer> result = new ArrayList<>();\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.offer(root);\n\n    while (!queue.isEmpty()) {\n        int level_size = queue.size();\n\n        for (int i = 0; i < level_size; i++) {\n            TreeNode current = queue.poll();\n\n            if (i == level_size - 1) result.add(current.val);\n            if (current.left != null) queue.offer(current.left);\n            if (current.right != null) queue.offer(current.right);\n        }\n    }\n\n    return result;\n}", "cpp": "#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int _val) : val(_val), left(nullptr), right(nullptr) {}\n};\n\nvector<int> rightSideView(TreeNode* root) {\n    if (!root) return {};\n\n    vector<int> result;\n    queue<TreeNode*> q;\n    q.push(root);\n\n    while (!q.empty()) {\n        int level_size = q.size();\n\n        for (int i = 0; i < level_size; ++i) {\n            TreeNode* current = q.front();\n            q.pop();\n\n            if (i == level_size - 1) result.push_back(current->val);\n            if (current->left) q.push(current->left);\n            if (current->right) q.push(current->right);\n        }\n    }\n\n    return result;\n}", "javascript": "class TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction rightSideView(root) {\n    if (!root) return [];\n\n    const result = [];\n    const queue = [root];\n\n    while (queue.length) {\n        const level_size = queue.length;\n\n        for (let i = 0; i < level_size; i++) {\n            const current = queue.shift();\n\n            if (i === level_size - 1) result.push(current.val);\n            if (current.left) queue.push(current.left);\n            if (current.right) queue.push(current.right);\n        }\n    }\n\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/200", "prompt": "Given an `m x n` 2D binary grid `grid` which represents a map of `'1'`s (land) and `'0'`s (water), return _the number of islands_.\n\nAn **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n\n**Example 1:**\n\n**Input:** grid = \\[\n  \\[ \"1 \", \"1 \", \"1 \", \"1 \", \"0 \"\\],\n  \\[ \"1 \", \"1 \", \"0 \", \"1 \", \"0 \"\\],\n  \\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n  \\[ \"0 \", \"0 \", \"0 \", \"0 \", \"0 \"\\]\n\\]\n**Output:** 1\n\n**Example 2:**\n\n**Input:** grid = \\[\n  \\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n  \\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n  \\[ \"0 \", \"0 \", \"1 \", \"0 \", \"0 \"\\],\n  \\[ \"0 \", \"0 \", \"0 \", \"1 \", \"1 \"\\]\n\\]\n**Output:** 3\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 300`\n*   `grid[i][j]` is `'0'` or `'1'`.", "entry_point": "number_of_islands", "canonical_solutions": {"python": "def dfs(grid, i, j):\n    if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '0':\n        return\n\n    grid[i][j] = '0'\n    dfs(grid, i + 1, j)\n    dfs(grid, i - 1, j)\n    dfs(grid, i, j + 1)\n    dfs(grid, i, j - 1)\n\ndef numIslands(grid):\n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == '1':\n                count += 1\n                dfs(grid, i, j)\n    return count", "java": "class Solution {\n    private void dfs(char[][] grid, int i, int j) {\n        if(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == '0')\n            return;\n\n        grid[i][j] = '0';\n        dfs(grid, i + 1, j);\n        dfs(grid, i - 1, j);\n        dfs(grid, i, j + 1);\n        dfs(grid, i, j - 1);\n    }\n\n    public int numIslands(char[][] grid) {\n        int count = 0;\n        for(int i = 0; i < grid.length; i++) {\n            for(int j = 0; j < grid[0].length; j++) {\n                if(grid[i][j] == '1') {\n                    count++;\n                    dfs(grid, i, j);\n                }\n            }\n        }\n        return count;\n    }\n}", "cpp": "void dfs(vector<vector<char>>& grid, int i, int j) {\n    if(i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size() || grid[i][j] == '0')\n        return;\n\n    grid[i][j] = '0';\n    dfs(grid, i + 1, j);\n    dfs(grid, i - 1, j);\n    dfs(grid, i, j + 1);\n    dfs(grid, i, j - 1);\n}\n\nint numIslands(vector<vector<char>>& grid) {\n    int count = 0;\n    for(int i = 0; i < grid.size(); i++) {\n        for(int j = 0; j < grid[0].size(); j++) {\n            if(grid[i][j] == '1') {\n                count++;\n                dfs(grid, i, j);\n            }\n        }\n    }\n    return count;\n}", "javascript": "function dfs(grid, i, j) {\n    if(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] === '0')\n        return;\n\n    grid[i][j] = '0';\n    dfs(grid, i + 1, j);\n    dfs(grid, i - 1, j);\n    dfs(grid, i, j + 1);\n    dfs(grid, i, j - 1);\n}\n\nfunction numIslands(grid) {\n    let count = 0;\n    for(let i = 0; i < grid.length; i++) {\n        for(let j = 0; j < grid[0].length; j++) {\n            if(grid[i][j] === '1') {\n                count++;\n                dfs(grid, i, j);\n            }\n        }\n    }\n    return count;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/201", "prompt": "Given two integers `left` and `right` that represent the range `[left, right]`, return _the bitwise AND of all numbers in this range, inclusive_.\n\n**Example 1:**\n\n**Input:** left = 5, right = 7\n**Output:** 4\n\n**Example 2:**\n\n**Input:** left = 0, right = 0\n**Output:** 0\n\n**Example 3:**\n\n**Input:** left = 1, right = 2147483647\n**Output:** 0\n\n**Constraints:**\n\n*   `0 <= left <= right <= 231 - 1`", "entry_point": "bitwise_and_of_numbers_range", "canonical_solutions": {"python": "def range_bitwise_and(left: int, right: int) -> int:\n    shift = 0\n    while left != right:\n        left >>= 1\n        right >>= 1\n        shift += 1\n    return left << shift", "java": "public int rangeBitwiseAnd(int left, int right) {\n    int shift = 0;\n    while (left != right) {\n        left >>= 1;\n        right >>= 1;\n        shift++;\n    }\n    return left << shift;\n}", "cpp": "int rangeBitwiseAnd(int left, int right) {\n    int shift = 0;\n    while (left != right) {\n        left >>= 1;\n        right >>= 1;\n        ++shift;\n    }\n    return left << shift;\n}", "javascript": "function rangeBitwiseAnd(left, right) {\n    let shift = 0;\n    while (left != right) {\n        left >>= 1;\n        right >>= 1;\n        shift++;\n    }\n    return left << shift;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/202", "prompt": "Write an algorithm to determine if a number `n` is happy.\n\nA **happy number** is a number defined by the following process:\n\n*   Starting with any positive integer, replace the number by the sum of the squares of its digits.\n*   Repeat the process until the number equals 1 (where it will stay), or it **loops endlessly in a cycle** which does not include 1.\n*   Those numbers for which this process **ends in 1** are happy.\n\nReturn `true` _if_ `n` _is a happy number, and_ `false` _if not_.\n\n**Example 1:**\n\n**Input:** n = 19\n**Output:** true\n**Explanation:**\n12 + 92 = 82\n82 + 22 = 68\n62 + 82 = 100\n12 + 02 + 02 = 1\n\n**Example 2:**\n\n**Input:** n = 2\n**Output:** false\n\n**Constraints:**\n\n*   `1 <= n <= 231 - 1`", "entry_point": "happy_number", "canonical_solutions": {"python": "def get_next(n):\n    sum = 0\n    while n > 0:\n        digit = n % 10\n        sum += digit * digit\n        n //= 10\n    return sum\n\ndef is_happy(n):\n    slow, fast = n, get_next(n)\n    while fast != 1 and slow != fast:\n        slow = get_next(slow)\n        fast = get_next(get_next(fast))\n    return fast == 1", "java": "public int getNext(int n) {\n    int sum = 0;\n    while (n > 0) {\n        int digit = n % 10;\n        sum += digit * digit;\n        n /= 10;\n    }\n    return sum;\n}\n\npublic boolean isHappy(int n) {\n    int slow = n, fast = getNext(n);\n    while (fast != 1 && slow != fast) {\n        slow = getNext(slow);\n        fast = getNext(getNext(fast));\n    }\n    return fast == 1;\n}", "cpp": "int getNext(int n) {\n    int sum = 0;\n    while (n > 0) {\n        int digit = n % 10;\n        sum += digit * digit;\n        n /= 10;\n    }\n    return sum;\n}\n\nbool isHappy(int n) {\n    int slow = n, fast = getNext(n);\n    while (fast != 1 && slow != fast) {\n        slow = getNext(slow);\n        fast = getNext(getNext(fast));\n    }\n    return fast == 1;\n}", "javascript": "function getNext(n) {\n    let sum = 0;\n    while (n > 0) {\n        let digit = n % 10;\n        sum += digit * digit;\n        n = Math.floor(n / 10);\n    }\n    return sum;\n}\n\nfunction isHappy(n) {\n    let slow = n, fast = getNext(n);\n    while (fast !== 1 && slow !== fast) {\n        slow = getNext(slow);\n        fast = getNext(getNext(fast));\n    }\n    return fast === 1;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/203", "prompt": "Given the `head` of a linked list and an integer `val`, remove all the nodes of the linked list that has `Node.val == val`, and return _the new head_.\n\n**Example 1:**\n\n**Input:** head = \\[1,2,6,3,4,5,6\\], val = 6\n**Output:** \\[1,2,3,4,5\\]\n\n**Example 2:**\n\n**Input:** head = \\[\\], val = 1\n**Output:** \\[\\]\n\n**Example 3:**\n\n**Input:** head = \\[7,7,7,7\\], val = 7\n**Output:** \\[\\]\n\n**Constraints:**\n\n*   The number of nodes in the list is in the range `[0, 104]`.\n*   `1 <= Node.val <= 50`\n*   `0 <= val <= 50`", "entry_point": "remove_linked_list_elements", "canonical_solutions": {"python": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef remove_elements(head, val):\n    sentinel = ListNode(0)\n    sentinel.next = head\n    prev, curr = sentinel, head\n\n    while curr:\n        if curr.val == val:\n            prev.next = curr.next\n        else:\n            prev = curr\n        curr = curr.next\n\n    return sentinel.next", "java": "public class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) { val = x; }\n}\n\npublic ListNode removeElements(ListNode head, int val) {\n    ListNode sentinel = new ListNode(0);\n    sentinel.next = head;\n    ListNode prev = sentinel, curr = head;\n\n    while (curr != null) {\n        if (curr.val == val) {\n            prev.next = curr.next;\n        } else {\n            prev = curr;\n        }\n        curr = curr.next;\n    }\n\n    return sentinel.next;\n}", "cpp": "class ListNode {\npublic:\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nListNode* removeElements(ListNode* head, int val) {\n    ListNode** current = &head;\n\n    while (*current != NULL) {\n        if ((*current)->val == val) {\n            ListNode* next = (*current)->next;\n            delete *current;\n            *current = next;\n        } else {\n            current = &(*current)->next;\n        }\n    }\n\n    return head;\n}", "javascript": "class ListNode {\n    constructor(val, next = null) {\n        this.val = val;\n        this.next = next;\n    }\n}\n\nfunction removeElements(head, val) {\n    let sentinel = new ListNode(0);\n    sentinel.next = head;\n    let prev = sentinel, curr = head;\n\n    while (curr !== null) {\n        if (curr.val === val) {\n            prev.next = curr.next;\n        } else {\n            prev = curr;\n        }\n        curr = curr.next;\n    }\n\n    return sentinel.next;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/204", "prompt": "Given an integer `n`, return _the number of prime numbers that are strictly less than_ `n`.\n\n**Example 1:**\n\n**Input:** n = 10\n**Output:** 4\n**Explanation:** There are 4 prime numbers less than 10, they are 2, 3, 5, 7.\n\n**Example 2:**\n\n**Input:** n = 0\n**Output:** 0\n\n**Example 3:**\n\n**Input:** n = 1\n**Output:** 0\n\n**Constraints:**\n\n*   `0 <= n <= 5 * 106`", "entry_point": "count_primes", "canonical_solutions": {"python": "def countPrimes(n: int) -> int:\n    if n <= 2:\n        return 0\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i * i, n, i):\n                is_prime[j] = False\n    return sum(is_prime)", "java": "public int countPrimes(int n) {\n    if (n <= 2) return 0;\n    boolean[] isPrime = new boolean[n];\n    Arrays.fill(isPrime, true);\n    isPrime[0] = isPrime[1] = false;\n    for (int i = 2; i * i < n; i++) {\n        if (isPrime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                isPrime[j] = false;\n            }\n        }\n    }\n    int count = 0;\n    for (boolean prime : isPrime) {\n        if (prime) count++;\n    }\n    return count;\n}", "cpp": "int countPrimes(int n) {\n    if (n <= 2) return 0;\n    vector<bool> isPrime(n, true);\n    isPrime[0] = isPrime[1] = false;\n    for (int i = 2; i * i < n; ++i) {\n        if (isPrime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                isPrime[j] = false;\n            }\n        }\n    }\n    return count(isPrime.begin(), isPrime.end(), true);\n}", "javascript": "function countPrimes(n) {\n    if (n <= 2) return 0;\n    const isPrime = Array(n).fill(true);\n    isPrime[0] = isPrime[1] = false;\n    for (let i = 2; i * i < n; i++) {\n        if (isPrime[i]) {\n            for (let j = i * i; j < n; j += i) {\n                isPrime[j] = false;\n            }\n        }\n    }\n    return isPrime.filter(prime => prime).length;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/205", "prompt": "Given two strings `s` and `t`, _determine if they are isomorphic_.\n\nTwo strings `s` and `t` are isomorphic if the characters in `s` can be replaced to get `t`.\n\nAll occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.\n\n**Example 1:**\n\n**Input:** s = \"egg\", t = \"add\"\n**Output:** true\n\n**Example 2:**\n\n**Input:** s = \"foo\", t = \"bar\"\n**Output:** false\n\n**Example 3:**\n\n**Input:** s = \"paper\", t = \"title\"\n**Output:** true\n\n**Constraints:**\n\n*   `1 <= s.length <= 5 * 104`\n*   `t.length == s.length`\n*   `s` and `t` consist of any valid ascii character.", "entry_point": "isomorphic_strings", "canonical_solutions": {"python": "def is_isomorphic(s: str, t: str) -> bool:\n    map1, map2 = {}, {}\n    for char_s, char_t in zip(s, t):\n        if char_s not in map1:\n            map1[char_s] = char_t\n        if char_t not in map2:\n            map2[char_t] = char_s\n        if map1[char_s] != char_t or map2[char_t] != char_s:\n            return False\n    return True", "java": "import java.util.HashMap;\n\npublic boolean isIsomorphic(String s, String t) {\n    HashMap<Character, Character> map1 = new HashMap<>();\n    HashMap<Character, Character> map2 = new HashMap<>();\n    \n    for (int i = 0; i < s.length(); i++) {\n        char sChar = s.charAt(i);\n        char tChar = t.charAt(i);\n        \n        if (!map1.containsKey(sChar)) {\n            map1.put(sChar, tChar);\n        }\n        if (!map2.containsKey(tChar)) {\n            map2.put(tChar, sChar);\n        }\n        \n        if (map1.get(sChar) != tChar || map2.get(tChar) != sChar) {\n           return false;\n        }\n    }\n    return true;\n}", "cpp": "#include <unordered_map>\n\nbool isIsomorphic(std::string s, std::string t) {\n    std::unordered_map<char, char> map1, map2;\n    for (size_t i = 0; i < s.size(); ++i) {\n        if (map1.find(s[i]) == map1.end()) {\n            map1[s[i]] = t[i];\n        }\n        if (map2.find(t[i]) == map2.end()) {\n            map2[t[i]] = s[i];\n        }\n        if (map1[s[i]] != t[i] || map2[t[i]] != s[i]) {\n            return false;\n        }\n    }\n    return true;\n}", "javascript": "function isIsomorphic(s, t) {\n    let map1 = new Map();\n    let map2 = new Map();\n    for (let i = 0; i < s.length; i++) {\n        let sChar = s[i];\n        let tChar = t[i];\n\n        if (!map1.has(sChar)) {\n            map1.set(sChar, tChar);\n        }\n        if (!map2.has(tChar)) {\n            map2.set(tChar, sChar);\n        }\n\n        if (map1.get(sChar) !== tChar || map2.get(tChar) !== sChar) {\n            return false;\n        }\n    }\n    return true;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/206", "prompt": "Given the `head` of a singly linked list, reverse the list, and return _the reversed list_.\n\n**Example 1:**\n\n**Input:** head = \\[1,2,3,4,5\\]\n**Output:** \\[5,4,3,2,1\\]\n\n**Example 2:**\n\n**Input:** head = \\[1,2\\]\n**Output:** \\[2,1\\]\n\n**Example 3:**\n\n**Input:** head = \\[\\]\n**Output:** \\[\\]\n\n**Constraints:**\n\n*   The number of nodes in the list is the range `[0, 5000]`.\n*   `-5000 <= Node.val <= 5000`\n\n**Follow up:** A linked list can be reversed either iteratively or recursively. Could you implement both?", "entry_point": "reverse_linked_list", "canonical_solutions": {"python": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef reverse_list(head):\n    prev = None\n    current = head\n    while current is not None:\n        next = current.next\n        current.next = prev\n        prev = current\n        current = next\n    return prev", "java": "public class ListNode {\n    int val;\n    ListNode next;\n}\n\npublic ListNode reverseList(ListNode head) {\n    ListNode prev = null;\n    ListNode current = head;\n    ListNode next = null;\n    while (current != null) {\n        next = current.next;\n        current.next = prev;\n        prev = current;\n        current = next;\n    }\n    return prev;\n}", "cpp": "class ListNode {\npublic:\n    int val;\n    ListNode *next;\n};\n\nListNode* reverseList(ListNode* head) {\n    ListNode* prev = nullptr;\n    ListNode* current = head;\n    ListNode* next = nullptr;\n    while (current != nullptr) {\n        next = current->next;\n        current->next = prev;\n        prev = current;\n        current = next;\n    }\n    return prev;\n}", "javascript": "class ListNode {\n    constructor(val, next = null) {\n        this.val = val;\n        this.next = next;\n    }\n}\n\nfunction reverseList(head) {\n    let prev = null;\n    let current = head;\n    let next = null;\n    while (current !== null) {\n        next = current.next;\n        current.next = prev;\n        prev = current;\n        current = next;\n    }\n    return prev;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/207", "prompt": "There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you **must** take course `bi` first if you want to take course `ai`.\n\n*   For example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`.\n\nReturn `true` if you can finish all courses. Otherwise, return `false`.\n\n**Example 1:**\n\n**Input:** numCourses = 2, prerequisites = \\[\\[1,0\\]\\]\n**Output:** true\n**Explanation:** There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0. So it is possible.\n\n**Example 2:**\n\n**Input:** numCourses = 2, prerequisites = \\[\\[1,0\\],\\[0,1\\]\\]\n**Output:** false\n**Explanation:** There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\n\n**Constraints:**\n\n*   `1 <= numCourses <= 2000`\n*   `0 <= prerequisites.length <= 5000`\n*   `prerequisites[i].length == 2`\n*   `0 <= ai, bi < numCourses`\n*   All the pairs prerequisites\\[i\\] are **unique**.", "entry_point": "course_schedule", "canonical_solutions": {"python": "from collections import defaultdict, deque\n\ndef canFinish(numCourses, prerequisites):\n    adj = defaultdict(list)\n    inDegree = [0] * numCourses\n    \n    for a, b in prerequisites:\n        adj[b].append(a)\n        inDegree[a] += 1\n    \n    q = deque([i for i in range(numCourses) if inDegree[i]==0])\n    \n    while q:\n        currCourse = q.popleft()\n        numCourses -= 1\n        \n        for nextCourse in adj[currCourse]:\n            inDegree[nextCourse] -= 1\n            if inDegree[nextCourse] == 0:\n                q.append(nextCourse)\n    \n    return numCourses == 0", "java": "import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic boolean canFinish(int numCourses, int[][] prerequisites) {\n    List<List<Integer>> adj = new ArrayList<>(numCourses);\n    int[] inDegree = new int[numCourses];\n    \n    for (int i = 0; i < numCourses; i++)\n        adj.add(new ArrayList<>());\n    \n    for (int[] p : prerequisites) {\n        adj.get(p[1]).add(p[0]);\n        inDegree[p[0]]++;\n    }\n    \n    Queue<Integer> q = new LinkedList<>();\n    for (int i = 0; i < numCourses; i++) {\n        if (inDegree[i] == 0) q.add(i);\n    }\n    \n    while (!q.isEmpty()) {\n        int currCourse = q.poll();\n        numCourses--;\n        \n        for (int nextCourse : adj.get(currCourse)) {\n            inDegree[nextCourse]--;\n            if (inDegree[nextCourse] == 0) q.add(nextCourse);\n        }\n    }\n    \n    return numCourses == 0;\n}", "cpp": "#include <vector>\n#include <queue>\n\nbool canFinish(int numCourses, std::vector<std::vector<int>>& prerequisites) {\n    std::vector<std::vector<int>> adj(numCourses);\n    std::vector<int> inDegree(numCourses, 0);\n    \n    for (auto& p : prerequisites) {\n        adj[p[1]].push_back(p[0]);\n        inDegree[p[0]]++;\n    }\n    \n    std::queue<int> q;\n    for (int i = 0; i < numCourses; i++) {\n        if (inDegree[i] == 0) q.push(i);\n    }\n    \n    while (!q.empty()) {\n        int currCourse = q.front();\n        q.pop();\n        numCourses--;\n        \n        for (int nextCourse : adj[currCourse]) {\n            inDegree[nextCourse]--;\n            if (inDegree[nextCourse] == 0) q.push(nextCourse);\n        }\n    }\n    \n    return numCourses == 0;\n}", "javascript": "function canFinish(numCourses, prerequisites) {\n    let adj = Array.from(Array(numCourses), () => []);\n    let inDegree = Array(numCourses).fill(0);\n    \n    for (let [a, b] of prerequisites) {\n        adj[b].push(a);\n        inDegree[a]++;\n    }\n    \n    let q = [];\n    for (let i = 0; i < numCourses; i++) {\n        if (inDegree[i] === 0) q.push(i);\n    }\n    \n    while (q.length) {\n        const currCourse = q.shift();\n        numCourses--;\n        \n        for (let nextCourse of adj[currCourse]) {\n            inDegree[nextCourse]--;\n            if (inDegree[nextCourse] === 0) q.push(nextCourse);\n        }\n    }\n    \n    return numCourses === 0;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/208", "prompt": "A [**trie**](https://en.wikipedia.org/wiki/Trie) (pronounced as \"try \") or **prefix tree** is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\n\nImplement the Trie class:\n\n*   `Trie()` Initializes the trie object.\n*   `void insert(String word)` Inserts the string `word` into the trie.\n*   `boolean search(String word)` Returns `true` if the string `word` is in the trie (i.e., was inserted before), and `false` otherwise.\n*   `boolean startsWith(String prefix)` Returns `true` if there is a previously inserted string `word` that has the prefix `prefix`, and `false` otherwise.\n\n**Example 1:**\n\n**Input**\n\\[ \"Trie \",  \"insert \",  \"search \",  \"search \",  \"startsWith \",  \"insert \",  \"search \"\\]\n\\[\\[\\], \\[ \"apple \"\\], \\[ \"apple \"\\], \\[ \"app \"\\], \\[ \"app \"\\], \\[ \"app \"\\], \\[ \"app \"\\]\\]\n**Output**\n\\[null, null, true, false, true, null, true\\]\n\n**Explanation**\nTrie trie = new Trie();\ntrie.insert( \"apple \");\ntrie.search( \"apple \");   // return True\ntrie.search( \"app \");     // return False\ntrie.startsWith( \"app \"); // return True\ntrie.insert( \"app \");\ntrie.search( \"app \");     // return True\n\n**Constraints:**\n\n*   `1 <= word.length, prefix.length <= 2000`\n*   `word` and `prefix` consist only of lowercase English letters.\n*   At most `3 * 104` calls **in total** will be made to `insert`, `search`, and `startsWith`.", "entry_point": "implement_trie_prefix_tree", "canonical_solutions": {"python": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for c in word:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for c in prefix:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return True", "java": "class Trie {\n    private class TrieNode {\n        Map<Character, TrieNode> children;\n        boolean isEndOfWord;\n\n        public TrieNode() {\n            children = new HashMap<>();\n            isEndOfWord = false;\n        }\n    }\n\n    private final TrieNode root;\n\n    public Trie() {\n        root = new TrieNode();\n    }\n\n    public void insert(String word) {\n        TrieNode current = root;\n        for (char c : word.toCharArray()) {\n            current.children.putIfAbsent(c, new TrieNode());\n            current = current.children.get(c);\n        }\n        current.isEndOfWord = true;\n    }\n\n    public boolean search(String word) {\n        TrieNode current = root;\n        for (char c : word.toCharArray()) {\n            TrieNode node = current.children.get(c);\n            if (node == null) {\n                return false;\n            }\n            current = node;\n        }\n        return current.isEndOfWord;\n    }\n\n    public boolean startsWith(String prefix) {\n        TrieNode current = root;\n        for (char c : prefix.toCharArray()) {\n            TrieNode node = current.children.get(c);\n            if (node == null) {\n                return false;\n            }\n            current = node;\n        }\n        return true;\n    }\n}", "cpp": "class Trie {\n    struct TrieNode {\n        unordered_map<char, TrieNode*> children;\n        bool isEndOfWord;\n    };\n\n    TrieNode *root;\n\npublic:\n    Trie() {\n        root = new TrieNode();\n        root->isEndOfWord = false;\n    }\n\n    void insert(string word) {\n        TrieNode *curr = root;\n        for (char c : word) {\n            if (curr->children.find(c) == curr->children.end()) {\n                curr->children[c] = new TrieNode();\n            }\n            curr = curr->children[c];\n        }\n        curr->isEndOfWord = true;\n    }\n\n    bool search(string word) {\n        TrieNode *curr = root;\n        for (char c : word) {\n            if (curr->children.find(c) == curr->children.end()) {\n                return false;\n            }\n            curr = curr->children[c];\n        }\n        return curr->isEndOfWord;\n    }\n\n    bool startsWith(string prefix) {\n        TrieNode *curr = root;\n        for (char c : prefix) {\n            if (curr->children.find(c) == curr->children.end()) {\n                return false;\n            }\n            curr = curr->children[c];\n        }\n        return true;\n    }\n};", "javascript": "class TrieNode {\n    constructor() {\n        this.children = {};\n        this.isEndOfWord = false;\n    }\n}\n\nclass Trie {\n    constructor() {\n        this.root = new TrieNode();\n    }\n\n    insert(word) {\n        let node = this.root;\n        for (let char of word) {\n            if (!node.children[char]) {\n                node.children[char] = new TrieNode();\n            }\n            node = node.children[char];\n        }\n        node.isEndOfWord = true;\n    }\n\n    search(word) {\n        let node = this.root;\n        for (let char of word) {\n            node = node.children[char];\n            if (!node) {\n                return false;\n            }\n        }\n        return node.isEndOfWord;\n    }\n\n    startsWith(prefix) {\n        let node = this.root;\n        for (let char of prefix) {\n            node = node.children[char];\n            if (!node) {\n                return false;\n            }\n        }\n        return true;\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/209", "prompt": "Given an array of positive integers `nums` and a positive integer `target`, return _the **minimal length** of a_ _subarray_ _whose sum is greater than or equal to_ `target`. If there is no such subarray, return `0` instead.\n\n**Example 1:**\n\n**Input:** target = 7, nums = \\[2,3,1,2,4,3\\]\n**Output:** 2\n**Explanation:** The subarray \\[4,3\\] has the minimal length under the problem constraint.\n\n**Example 2:**\n\n**Input:** target = 4, nums = \\[1,4,4\\]\n**Output:** 1\n\n**Example 3:**\n\n**Input:** target = 11, nums = \\[1,1,1,1,1,1,1,1\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= target <= 109`\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 104`\n\n**Follow up:** If you have figured out the `O(n)` solution, try coding another solution of which the time complexity is `O(n log(n))`.", "entry_point": "minimum_size_subarray_sum", "canonical_solutions": {"python": "def minSubArrayLen(target: int, nums: List[int]) -> int:\n    left, cur_sum, min_len = 0, 0, float('inf')\n    for right in range(len(nums)):\n        cur_sum += nums[right]\n        while cur_sum >= target:\n            min_len = min(min_len, right - left + 1)\n            cur_sum -= nums[left]\n            left += 1\n    return min_len if min_len != float('inf') else 0", "java": "public int minSubArrayLen(int target, int[] nums) {\n    int left = 0, cur_sum = 0, min_len = Integer.MAX_VALUE;\n    for (int right = 0; right < nums.length; right++) {\n        cur_sum += nums[right];\n        while (cur_sum >= target) {\n            min_len = Math.min(min_len, right - left + 1);\n            cur_sum -= nums[left++];\n        }\n    }\n    return min_len == Integer.MAX_VALUE ? 0 : min_len;\n}", "cpp": "#include <climits>\nint minSubArrayLen(int target, vector<int>& nums) {\n    int left = 0, cur_sum = 0, min_len = INT_MAX;\n    for (int right = 0; right < nums.size(); right++) {\n        cur_sum += nums[right];\n        while (cur_sum >= target) {\n            min_len = min(min_len, right - left + 1);\n            cur_sum -= nums[left++];\n        }\n    }\n    return min_len == INT_MAX ? 0 : min_len;\n}", "javascript": "function minSubArrayLen(target, nums) {\n    let left = 0, cur_sum = 0, min_len = Number.MAX_VALUE;\n    for (let right = 0; right < nums.length; right++) {\n        cur_sum += nums[right];\n        while (cur_sum >= target) {\n            min_len = Math.min(min_len, right - left + 1);\n            cur_sum -= nums[left++];\n        }\n    }\n    return min_len === Number.MAX_VALUE ? 0 : min_len;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/210", "prompt": "There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you **must** take course `bi` first if you want to take course `ai`.\n\n*   For example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`.\n\nReturn _the ordering of courses you should take to finish all courses_. If there are many valid answers, return **any** of them. If it is impossible to finish all courses, return **an empty array**.\n\n**Example 1:**\n\n**Input:** numCourses = 2, prerequisites = \\[\\[1,0\\]\\]\n**Output:** \\[0,1\\]\n**Explanation:** There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is \\[0,1\\].\n\n**Example 2:**\n\n**Input:** numCourses = 4, prerequisites = \\[\\[1,0\\],\\[2,0\\],\\[3,1\\],\\[3,2\\]\\]\n**Output:** \\[0,2,1,3\\]\n**Explanation:** There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\nSo one correct course order is \\[0,1,2,3\\]. Another correct ordering is \\[0,2,1,3\\].\n\n**Example 3:**\n\n**Input:** numCourses = 1, prerequisites = \\[\\]\n**Output:** \\[0\\]\n\n**Constraints:**\n\n*   `1 <= numCourses <= 2000`\n*   `0 <= prerequisites.length <= numCourses * (numCourses - 1)`\n*   `prerequisites[i].length == 2`\n*   `0 <= ai, bi < numCourses`\n*   `ai != bi`\n*   All the pairs `[ai, bi]` are **distinct**.", "entry_point": "course_schedule_ii", "canonical_solutions": {"python": "from collections import deque\n\ndef findOrder(numCourses, prerequisites):\n    in_degree = [0] * numCourses\n    adj_list = [[] for _ in range(numCourses)]\n    \n    for p in prerequisites:\n        adj_list[p[1]].append(p[0])\n        in_degree[p[0]] += 1\n    \n    q = deque([i for i in range(numCourses) if in_degree[i] == 0])\n    order = []\n    \n    while q:\n        curr = q.popleft()\n        order.append(curr)\n        for next in adj_list[curr]:\n            in_degree[next] -= 1\n            if in_degree[next] == 0:\n                q.append(next)\n    \n    return order if len(order) == numCourses else []", "java": "import java.util.*;\n\npublic int[] findOrder(int numCourses, int[][] prerequisites) {\n    int[] inDegree = new int[numCourses];\n    List<List<Integer>> adjList = new ArrayList<>();\n    \n    for (int i = 0; i < numCourses; i++) {\n        adjList.add(new ArrayList<>());\n    }\n    \n    for (int[] p : prerequisites) {\n        adjList.get(p[1]).add(p[0]);\n        inDegree[p[0]]++;\n    }\n    \n    Queue<Integer> q = new LinkedList<>();\n    for (int i = 0; i < numCourses; i++) {\n        if (inDegree[i] == 0) {\n            q.offer(i);\n        }\n    }\n    \n    int[] order = new int[numCourses];\n    int index = 0;\n    \n    while (!q.isEmpty()) {\n        int curr = q.poll();\n        order[index++] = curr;\n        for (int next : adjList.get(curr)) {\n            if (--inDegree[next] == 0) {\n                q.offer(next);\n            }\n        }\n    }\n    \n    return (index == numCourses) ? order : new int[0];\n}", "cpp": "#include <vector>\n#include <queue>\nusing namespace std;\n\nvector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\n    vector<int> inDegree(numCourses, 0);\n    vector<vector<int>> adjList(numCourses);\n    \n    for (auto& p : prerequisites) {\n        adjList[p[1]].push_back(p[0]);\n        inDegree[p[0]]++;\n    }\n    \n    queue<int> q;\n    for (int i = 0; i < numCourses; i++) {\n        if (inDegree[i] == 0) {\n            q.push(i);\n        }\n    }\n    \n    vector<int> order;\n    \n    while (!q.empty()) {\n        int curr = q.front();\n        q.pop();\n        order.push_back(curr);\n        for (auto next : adjList[curr]) {\n            if (--inDegree[next] == 0) {\n                q.push(next);\n            }\n        }\n    }\n    \n    return (order.size() == numCourses) ? order : vector<int>();\n}", "javascript": "function findOrder(numCourses, prerequisites) {\n    const inDegree = new Array(numCourses).fill(0);\n    const adjList = Array.from({ length: numCourses }, () => []);\n    \n    for (const p of prerequisites) {\n        adjList[p[1]].push(p[0]);\n        inDegree[p[0]]++;\n    }\n    \n    const q = [];\n    for (let i = 0; i < numCourses; i++) {\n        if (inDegree[i] === 0) {\n            q.push(i);\n        }\n    }\n    \n    const order = [];\n    \n    while (q.length) {\n        const curr = q.shift();\n        order.push(curr);\n        for (const next of adjList[curr]) {\n            if (--inDegree[next] === 0) {\n                q.push(next);\n            }\n        }\n    }\n    \n    return (order.length === numCourses) ? order : [];\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/211", "prompt": "Design a data structure that supports adding new words and finding if a string matches any previously added string.\n\nImplement the `WordDictionary` class:\n\n*   `WordDictionary()` Initializes the object.\n*   `void addWord(word)` Adds `word` to the data structure, it can be matched later.\n*   `bool search(word)` Returns `true` if there is any string in the data structure that matches `word` or `false` otherwise. `word` may contain dots `'.'` where dots can be matched with any letter.\n\n**Example:**\n\n**Input**\n\\[ \"WordDictionary \", \"addWord \", \"addWord \", \"addWord \", \"search \", \"search \", \"search \", \"search \"\\]\n\\[\\[\\],\\[ \"bad \"\\],\\[ \"dad \"\\],\\[ \"mad \"\\],\\[ \"pad \"\\],\\[ \"bad \"\\],\\[ \".ad \"\\],\\[ \"b.. \"\\]\\]\n**Output**\n\\[null,null,null,null,false,true,true,true\\]\n\n**Explanation**\nWordDictionary wordDictionary = new WordDictionary();\nwordDictionary.addWord( \"bad \");\nwordDictionary.addWord( \"dad \");\nwordDictionary.addWord( \"mad \");\nwordDictionary.search( \"pad \"); // return False\nwordDictionary.search( \"bad \"); // return True\nwordDictionary.search( \".ad \"); // return True\nwordDictionary.search( \"b.. \"); // return True\n\n**Constraints:**\n\n*   `1 <= word.length <= 25`\n*   `word` in `addWord` consists of lowercase English letters.\n*   `word` in `search` consist of `'.'` or lowercase English letters.\n*   There will be at most `2` dots in `word` for `search` queries.\n*   At most `104` calls will be made to `addWord` and `search`.", "entry_point": "design_add_and_search_words_data_structure", "canonical_solutions": {"python": "class TrieNode:\n    def __init__(self):\n        self.children = [None] * 26\n        self.is_word = False\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -> None:\n        current = self.root\n        for c in word:\n            index = ord(c) - ord('a')\n            if current.children[index] is None:\n                current.children[index] = TrieNode()\n            current = current.children[index]\n        current.is_word = True\n\n    def search(self, word: str) -> bool:\n        return self._search_helper(self.root, word, 0)\n\n    def _search_helper(self, node: TrieNode, word: str, index: int) -> bool:\n        if index == len(word):\n            return node.is_word\n\n        if word[index] == '.':\n            for child_node in node.children:\n                if child_node is not None and self._search_helper(child_node, word, index + 1):\n                    return True\n            return False\n        else:\n            child_node = node.children[ord(word[index]) - ord('a')]\n            if child_node is None:\n                return False\n            return self._search_helper(child_node, word, index + 1)", "java": "class WordDictionary {\n    private static class TrieNode {\n        TrieNode[] children = new TrieNode[26];\n        boolean is_word;\n    }\n\n    private TrieNode root;\n\n    public WordDictionary() {\n        root = new TrieNode();\n    }\n\n    public void addWord(String word) {\n        TrieNode current = root;\n        for (char c : word.toCharArray()) {\n            if (current.children[c - 'a'] == null) {\n                current.children[c - 'a'] = new TrieNode();\n            }\n            current = current.children[c - 'a'];\n        }\n        current.is_word = true;\n    }\n\n    public boolean search(String word) {\n        return searchHelper(root, word, 0);\n    }\n\n    private boolean searchHelper(TrieNode node, String word, int index) {\n        if (index == word.length()) {\n            return node.is_word;\n        }\n\n        if (word.charAt(index) == '.') {\n            for (int i = 0; i < 26; i++) {\n                if (node.children[i] != null && searchHelper(node.children[i], word, index + 1)) {\n                    return true;\n                }\n            }\n            return false;\n        } else {\n            if (node.children[word.charAt(index) - 'a'] == null) {\n                return false;\n            }\n            return searchHelper(node.children[word.charAt(index) - 'a'], word, index + 1);\n        }\n    }\n}", "cpp": "class WordDictionary {\npublic:\n    struct TrieNode {\n        TrieNode* children[26];\n        bool is_word;\n    };\n\n    TrieNode* root;\n\n    WordDictionary() {\n        root = new TrieNode();\n    }\n\n    void addWord(string word) {\n        TrieNode* current = root;\n        for (char c : word) {\n            if (current->children[c - 'a'] == nullptr) {\n                current->children[c - 'a'] = new TrieNode();\n            }\n            current = current->children[c - 'a'];\n        }\n        current->is_word = true;\n    }\n\n    bool search(string word) {\n        return searchHelper(root, word, 0);\n    }\n\n    bool searchHelper(TrieNode* node, string& word, int index) {\n        if (index == word.length()) {\n            return node->is_word;\n        }\n\n        if (word[index] == '.') {\n            for (int i = 0; i < 26; i++) {\n                if (node->children[i] != nullptr && searchHelper(node->children[i], word, index + 1)) {\n                    return true;\n                }\n            }\n            return false;\n        } else {\n            if (node->children[word[index] - 'a'] == nullptr) {\n                return false;\n            }\n            return searchHelper(node->children[word[index] - 'a'], word, index + 1);\n        }\n    }\n};", "javascript": "class TrieNode {\n    constructor() {\n        this.children = new Array(26).fill(null);\n        this.is_word = false;\n    }\n}\n\nclass WordDictionary {\n    constructor() {\n        this.root = new TrieNode();\n    }\n\n    addWord(word) {\n        let current = this.root;\n        for (const c of word) {\n            const index = c.charCodeAt(0) - 'a'.charCodeAt(0);\n            if (!current.children[index]) {\n                current.children[index] = new TrieNode();\n            }\n            current = current.children[index];\n        }\n        current.is_word = true;\n    }\n\n    search(word) {\n        return this._searchHelper(this.root, word, 0);\n    }\n\n    _searchHelper(node, word, index) {\n        if (index === word.length) {\n            return node.is_word;\n        }\n\n        if (word[index] === '.') {\n            for (let i = 0; i < 26; i++) {\n                if (node.children[i] && this._searchHelper(node.children[i], word, index + 1)) {\n                    return true;\n                }\n            }\n            return false;\n        } else {\n            const childIndex = word.charCodeAt(index) - 'a'.charCodeAt(0);\n            if (!node.children[childIndex]) {\n                return false;\n            }\n            return this._searchHelper(node.children[childIndex], word, index + 1);\n        }\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/212", "prompt": "Given an `m x n` `board` of characters and a list of strings `words`, return _all words on the board_.\n\nEach word must be constructed from letters of sequentially adjacent cells, where **adjacent cells** are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\n\n**Example 1:**\n\n**Input:** board = \\[\\[ \"o \", \"a \", \"a \", \"n \"\\],\\[ \"e \", \"t \", \"a \", \"e \"\\],\\[ \"i \", \"h \", \"k \", \"r \"\\],\\[ \"i \", \"f \", \"l \", \"v \"\\]\\], words = \\[ \"oath \", \"pea \", \"eat \", \"rain \"\\]\n**Output:** \\[ \"eat \", \"oath \"\\]\n\n**Example 2:**\n\n**Input:** board = \\[\\[ \"a \", \"b \"\\],\\[ \"c \", \"d \"\\]\\], words = \\[ \"abcb \"\\]\n**Output:** \\[\\]\n\n**Constraints:**\n\n*   `m == board.length`\n*   `n == board[i].length`\n*   `1 <= m, n <= 12`\n*   `board[i][j]` is a lowercase English letter.\n*   `1 <= words.length <= 3 * 104`\n*   `1 <= words[i].length <= 10`\n*   `words[i]` consists of lowercase English letters.\n*   All the strings of `words` are unique.", "entry_point": "word_search_ii", "canonical_solutions": {"python": "def findWords(board, words):\n    def dfs(board, word, index, i, j, visited):\n        if index == len(word):\n            return True\n        if i < 0 or j < 0 or i >= len(board) or j >= len(board[0]) or visited[i][j] or board[i][j] != word[index]:\n            return False\n        visited[i][j] = True\n        found = dfs(board, word, index + 1, i - 1, j, visited) or \\\n                dfs(board, word, index + 1, i + 1, j, visited) or \\\n                dfs(board, word, index + 1, i, j - 1, visited) or \\\n                dfs(board, word, index + 1, i, j + 1, visited)\n        visited[i][j] = False\n        return found\n\n    res = []\n    for word in words:\n        if any(dfs(board, word, 0, i, j, [[False] * len(board[0]) for _ in range(len(board))])\n               for i in range(len(board)) for j in range(len(board[0]))):\n            res.append(word)\n    return res", "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> findWords(char[][] board, String[] words) {\n    List<String> result = new ArrayList<>();\n    for (String word : words) {\n        if (exist(board, word)) {\n            result.add(word);\n        }\n    }\n    return result;\n}\n\nprivate boolean exist(char[][] board, String word) {\n    int m = board.length;\n    int n = board[0].length;\n    boolean[][] visited = new boolean[m][n];\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (dfs(board, word, 0, i, j, visited)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nprivate boolean dfs(char[][] board, String word, int index, int i, int j, boolean[][] visited) {\n    if (index == word.length()) {\n        return true;\n    }\n    if (i < 0 || j < 0 || i >= board.length || j >= board[0].length || visited[i][j] || board[i][j] != word.charAt(index)) {\n        return false;\n    }\n    visited[i][j] = true;\n    boolean found =\n            dfs(board, word, index + 1, i - 1, j, visited) ||\n            dfs(board, word, index + 1, i + 1, j, visited) ||\n            dfs(board, word, index + 1, i, j - 1, visited) ||\n            dfs(board, word, index + 1, i, j + 1, visited);\n    visited[i][j] = false;\n    return found;\n}", "cpp": "#include <vector>\n#include <string>\n\nvoid dfs(const std::vector<std::vector<char>>& board, const std::string& word, int index, int i, int j, std::vector<std::vector<bool>>& visited, bool& found){\n    if (index == word.length()) {\n        found = true;\n        return;\n    }\n    if (i < 0 || j < 0 || i >= board.size() || j >= board[0].size() || visited[i][j] || board[i][j] != word[index]){\n        return;\n    }\n    visited[i][j] = true;\n    dfs(board, word, index + 1, i - 1, j, visited, found);\n    dfs(board, word, index + 1, i + 1, j, visited, found);\n    dfs(board, word, index + 1, i, j - 1, visited, found);\n    dfs(board, word, index + 1, i, j + 1, visited, found);\n    visited[i][j] = false;\n}\n\nstd::vector<std::string> findWords(std::vector<std::vector<char>>& board, std::vector<std::string>& words) {\n    std::vector<std::string> result;\n    for (const auto& word : words) {\n        bool found = false;\n        std::vector<std::vector<bool>> visited(board.size(), std::vector<bool>(board[0].size(), false));\n        for (int i = 0; i < board.size() && !found; ++i) {\n            for (int j = 0; j < board[0].size() && !found; ++j) {\n                dfs(board, word, 0, i, j, visited, found);\n            }\n        }\n        if (found) {\n            result.push_back(word);\n        }\n    }\n    return result;\n}", "javascript": "function findWords(board, words) {\n    function dfs(board, word, index, i, j, visited) {\n        if (index === word.length) {\n            return true;\n        }\n        if (i < 0 || j < 0 || i >= board.length || j >= board[0].length || visited[i][j] || board[i][j] !== word.charAt(index)) {\n            return false;\n        }\n        visited[i][j] = true;\n        const found = dfs(board, word, index + 1, i - 1, j, visited) ||\n                      dfs(board, word, index + 1, i + 1, j, visited) ||\n                      dfs(board, word, index + 1, i, j - 1, visited) ||\n                      dfs(board, word, index + 1, i, j + 1, visited);\n        visited[i][j] = false;\n        return found;\n    }\n\n    const res = [];\n    for (const word of words) {\n        let found = false;\n        for (let i = 0; i < board.length && !found; i++) {\n            for (let j = 0; j < board[0].length && !found; j++) {\n                if (dfs(board, word, 0, i, j, Array.from({ length: board.length }, () => Array(board[0].length).fill(false)))) {\n                    found = true;\n                }\n            }\n        }\n        if (found) {\n            res.push(word);\n        }\n    }\n    return res;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/213", "prompt": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle.** That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\n\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n\n**Example 1:**\n\n**Input:** nums = \\[2,3,2\\]\n**Output:** 3\n**Explanation:** You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n\n**Example 3:**\n\n**Input:** nums = \\[1,2,3\\]\n**Output:** 3\n\n**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 1000`", "entry_point": "house_robber_ii", "canonical_solutions": {"python": "def rob(nums):\n    if len(nums) == 1:\n        return nums[0]\n    prev, curr = 0, 0\n    for i in range(len(nums) - 1):\n        temp = max(curr, prev + nums[i])\n        prev, curr = curr, temp\n    res = curr\n    prev, curr = 0, 0\n    for i in range(1, len(nums)):\n        temp = max(curr, prev + nums[i])\n        prev, curr = curr, temp\n    return max(res, curr)", "java": "public int rob(int[] nums) {\n    if (nums.length == 1) return nums[0];\n    int prev = 0, curr = 0;\n    for (int i = 0; i < nums.length - 1; i++) {\n        int temp = Math.max(curr, prev + nums[i]);\n        prev = curr;\n        curr = temp;\n    }\n    int res = curr;\n    prev = 0;\n    curr = 0;\n    for (int i = 1; i < nums.length; i++) {\n        int temp = Math.max(curr, prev + nums[i]);\n        prev = curr;\n        curr = temp;\n    }\n    return Math.max(res, curr);\n}", "cpp": "int rob(vector<int>& nums) {\n    if (nums.size() == 1) return nums[0];\n    int prev = 0, curr = 0;\n    for (int i = 0; i < nums.size() - 1; i++) {\n        int temp = max(curr, prev + nums[i]);\n        prev = curr;\n        curr = temp;\n    }\n    int res = curr;\n    prev = 0;\n    curr = 0;\n    for (int i = 1; i < nums.size(); i++) {\n        int temp = max(curr, prev + nums[i]);\n        prev = curr;\n        curr = temp;\n    }\n    return max(res, curr);\n}", "javascript": "function rob(nums) {\n    if (nums.length === 1) return nums[0];\n    let prev = 0, curr = 0;\n    for (let i = 0; i < nums.length - 1; i++) {\n        let temp = Math.max(curr, prev + nums[i]);\n        prev = curr;\n        curr = temp;\n    }\n    let res = curr;\n    prev = 0;\n    curr = 0;\n    for (let i = 1; i < nums.length; i++) {\n        let temp = Math.max(curr, prev + nums[i]);\n        prev = curr;\n        curr = temp;\n    }\n    return Math.max(res, curr);\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/214", "prompt": "You are given a string `s`. You can convert `s` to a palindrome by adding characters in front of it.\n\nReturn _the shortest palindrome you can find by performing this transformation_.\n\n**Example 1:**\n\n**Input:** s = \"aacecaaa\"\n**Output:** \"aaacecaaa\"\n\n**Example 2:**\n\n**Input:** s = \"abcd\"\n**Output:** \"dcbabcd\"\n\n**Constraints:**\n\n*   `0 <= s.length <= 5 * 104`\n*   `s` consists of lowercase English letters only.", "entry_point": "shortest_palindrome", "canonical_solutions": {"python": "def shortest_palindrome(s: str) -> str:\n    n = len(s)\n    rev_s = s[::-1]\n    \n    for i in range(n):\n        if s[:n - i] == rev_s[i:]:\n            return rev_s[:i] + s\n    return \"\"", "java": "public String shortestPalindrome(String s) {\n    int n = s.length();\n    String rev_s = new StringBuilder(s).reverse().toString();\n    \n    for (int i = 0; i < n; ++i) {\n        if(s.substring(0, n - i).equals(rev_s.substring(i)))\n            return rev_s.substring(0, i) + s;\n    }\n    return \"\";\n}", "cpp": "#include <string>\n\nstd::string shortestPalindrome(std::string s) {\n    int n = s.size();\n    std::string rev_s = s;\n    std::reverse(rev_s.begin(), rev_s.end());\n    \n    for (int i = 0; i < n; ++i) {\n        if(s.substr(0, n - i) == rev_s.substr(i))\n            return rev_s.substr(0, i) + s;\n    }\n    return \"\";\n}", "javascript": "function shortestPalindrome(s) {\n    let n = s.length;\n    let rev_s = s.split('').reverse().join('');\n    \n    for (let i = 0; i < n; ++i) {\n        if (s.slice(0, n - i) === rev_s.slice(i))\n            return rev_s.slice(0, i) + s;\n    }\n    return \"\";\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/215", "prompt": "Given an integer array `nums` and an integer `k`, return _the_ `kth` _largest element in the array_.\n\nNote that it is the `kth` largest element in the sorted order, not the `kth` distinct element.\n\nYou must solve it in `O(n)` time complexity.\n\n**Example 1:**\n\n**Input:** nums = \\[3,2,1,5,6,4\\], k = 2\n**Output:** 5\n\n**Example 2:**\n\n**Input:** nums = \\[3,2,3,1,2,4,5,5,6\\], k = 4\n**Output:** 4\n\n**Constraints:**\n\n*   `1 <= k <= nums.length <= 105`\n*   `-104 <= nums[i] <= 104`", "entry_point": "kth_largest_element_in_an_array", "canonical_solutions": {"python": "def findKthLargest(nums: List[int], k: int) -> int:\n    nums.sort(reverse=True)\n    return nums[k-1]", "java": "import java.util.PriorityQueue;\n\npublic int findKthLargest(int[] nums, int k) {\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>();\n    for (int num : nums) {\n        minHeap.add(num);\n        if (minHeap.size() > k) {\n            minHeap.poll();\n        }\n    }\n    return minHeap.poll();\n}", "cpp": "#include <algorithm>\n#include <vector>\n\nint findKthLargest(std::vector<int>& nums, int k) {\n    std::sort(nums.begin(), nums.end(), std::greater<int>());\n    return nums[k-1];\n}", "javascript": "function findKthLargest(nums, k) {\n    nums.sort((a, b) => b - a);\n    return nums[k - 1];\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/216", "prompt": "Find all valid combinations of `k` numbers that sum up to `n` such that the following conditions are true:\n\n*   Only numbers `1` through `9` are used.\n*   Each number is used **at most once**.\n\nReturn _a list of all possible valid combinations_. The list must not contain the same combination twice, and the combinations may be returned in any order.\n\n**Example 1:**\n\n**Input:** k = 3, n = 7\n**Output:** \\[\\[1,2,4\\]\\]\n**Explanation:**\n1 + 2 + 4 = 7\nThere are no other valid combinations.\n\n**Example 2:**\n\n**Input:** k = 3, n = 9\n**Output:** \\[\\[1,2,6\\],\\[1,3,5\\],\\[2,3,4\\]\\]\n**Explanation:**\n1 + 2 + 6 = 9\n1 + 3 + 5 = 9\n2 + 3 + 4 = 9\nThere are no other valid combinations.\n\n**Example 3:**\n\n**Input:** k = 4, n = 1\n**Output:** \\[\\]\n**Explanation:** There are no valid combinations.\nUsing 4 different numbers in the range \\[1,9\\], the smallest sum we can get is 1+2+3+4 = 10 and since 10 > 1, there are no valid combination.\n\n**Constraints:**\n\n*   `2 <= k <= 9`\n*   `1 <= n <= 60`", "entry_point": "combination_sum_iii", "canonical_solutions": {"python": "def combinationSum3(k, n):\n    def helper(k, n, current, current_comb, result):\n        if k == 0 and n == 0:\n            result.append(list(current_comb))\n        elif k > 0 and n > 0:\n            for i in range(current + 1, 10):\n                current_comb.append(i)\n                helper(k - 1, n - i, i, current_comb, result)\n                current_comb.pop()\n\n    result = []\n    helper(k, n, 0, [], result)\n    return result", "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> combinationSum3(int k, int n) {\n    List<List<Integer>> result = new ArrayList<>();\n    helper(k, n, 0, new ArrayList<>(), result);\n    return result;\n}\n\nprivate void helper(int k, int n, int current, List<Integer> currentComb, List<List<Integer>> result) {\n    if (k == 0 && n == 0) {\n        result.add(new ArrayList<>(currentComb));\n    } else if (k > 0 && n > 0) {\n        for (int i = current + 1; i <= 9; i++) {\n            currentComb.add(i);\n            helper(k - 1, n - i, i, currentComb, result);\n            currentComb.remove(currentComb.size() - 1);\n        }\n    }\n}", "cpp": "#include <vector>\n\nvoid helper(int k, int n, int current, std::vector<int>& current_comb, std::vector<std::vector<int>>& result) {\n    if (k == 0 && n == 0) {\n        result.push_back(current_comb);\n    } else if (k > 0 && n > 0) {\n        for (int i = current + 1; i <= 9; ++i) {\n            current_comb.push_back(i);\n            helper(k - 1, n - i, i, current_comb, result);\n            current_comb.pop_back();\n        }\n    }\n}\n\nstd::vector<std::vector<int>> combinationSum3(int k, int n) {\n    std::vector<std::vector<int>> result;\n    std::vector<int> current_comb;\n    helper(k, n, 0, current_comb, result);\n    return result;\n}", "javascript": "function combinationSum3(k, n) {\n  function helper(k, n, current, currentComb, result) {\n    if (k === 0 && n === 0) {\n      result.push([...currentComb]);\n    } else if (k > 0 && n > 0) {\n      for (let i = current + 1; i <= 9; i++) {\n        currentComb.push(i);\n        helper(k - 1, n - i, i, currentComb, result);\n        currentComb.pop();\n      }\n    }\n  }\n\n  const result = [];\n  helper(k, n, 0, [], result);\n  return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/217", "prompt": "Given an integer array `nums`, return `true` if any value appears **at least twice** in the array, and return `false` if every element is distinct.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** true\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** false\n\n**Example 3:**\n\n**Input:** nums = \\[1,1,1,3,3,4,3,2,4,2\\]\n**Output:** true\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-109 <= nums[i] <= 109`", "entry_point": "contains_duplicate", "canonical_solutions": {"python": "def containsDuplicate(nums):\n    return len(nums) != len(set(nums))", "java": "public boolean containsDuplicate(int[] nums) {\n    Set<Integer> set = new HashSet<Integer>();\n    for (int num : nums) {\n        if (!set.add(num)) {\n            return true;\n        }\n    }\n    return false;\n}", "cpp": "bool containsDuplicate(vector<int>& nums) {\n    unordered_set<int> s;\n    for (int num : nums) {\n        if (s.find(num) != s.end()) {\n            return true;\n        }\n        s.insert(num);\n    }\n    return false;\n}", "javascript": "function containsDuplicate(nums) {\n    const set = new Set();\n    for (const num of nums) {\n        if (set.has(num)) {\n            return true;\n        }\n        set.add(num);\n    }\n    return false;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/218", "prompt": "A city's **skyline** is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return _the **skyline** formed by these buildings collectively_.\n\nThe geometric information of each building is given in the array `buildings` where `buildings[i] = [lefti, righti, heighti]`:\n\n*   `lefti` is the x coordinate of the left edge of the `ith` building.\n*   `righti` is the x coordinate of the right edge of the `ith` building.\n*   `heighti` is the height of the `ith` building.\n\nYou may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height `0`.\n\nThe **skyline** should be represented as a list of \"key points \" **sorted by their x-coordinate** in the form `[[x1,y1],[x2,y2],...]`. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate `0` and is used to mark the skyline's termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline's contour.\n\n**Note:** There must be no consecutive horizontal lines of equal height in the output skyline. For instance, `[...,[2 3],[4 5],[7 5],[11 5],[12 7],...]` is not acceptable; the three lines of height 5 should be merged into one in the final output as such: `[...,[2 3],[4 5],[12 7],...]`\n\n**Example 1:**\n\n**Input:** buildings = \\[\\[2,9,10\\],\\[3,7,15\\],\\[5,12,12\\],\\[15,20,10\\],\\[19,24,8\\]\\]\n**Output:** \\[\\[2,10\\],\\[3,15\\],\\[7,12\\],\\[12,0\\],\\[15,10\\],\\[20,8\\],\\[24,0\\]\\]\n**Explanation:**\nFigure A shows the buildings of the input.\nFigure B shows the skyline formed by those buildings. The red points in figure B represent the key points in the output list.\n\n**Example 2:**\n\n**Input:** buildings = \\[\\[0,2,3\\],\\[2,5,3\\]\\]\n**Output:** \\[\\[0,3\\],\\[5,0\\]\\]\n\n**Constraints:**\n\n*   `1 <= buildings.length <= 104`\n*   `0 <= lefti < righti <= 231 - 1`\n*   `1 <= heighti <= 231 - 1`\n*   `buildings` is sorted by `lefti` in non-decreasing order.", "entry_point": "the_skyline_problem", "canonical_solutions": {"python": "from sortedcontainers import SortedList\n\ndef getSkyline(buildings):\n    points = []\n    for l, r, h in buildings:\n        points.append((l, -h))\n        points.append((r, h))\n    points.sort()\n    heights = SortedList([0])\n    prev = 0\n    skyline = []\n    for x, h in points:\n        if h < 0:\n            heights.add(-h)\n        else:\n            heights.remove(h)\n        cur = heights[-1]\n        if cur != prev:\n            skyline.append([x, cur])\n            prev = cur\n    return skyline", "java": "import java.util.*;\n\nclass Solution {\n    public List<List<Integer>> getSkyline(int[][] buildings) {\n        List<int[]> points = new ArrayList<>();\n        for (int[] b : buildings) {\n            points.add(new int[]{b[0], -b[2]});\n            points.add(new int[]{b[1], b[2]});\n        }\n        Collections.sort(points, (a, b) -> a[0] - b[0]);\n        TreeSet<Integer> heights = new TreeSet<>(Collections.reverseOrder());\n        heights.add(0);\n        int prev = 0;\n        List<List<Integer>> skyline = new ArrayList<>();\n        for (int[] point : points) {\n            int x = point[0], h = point[1];\n            if (h < 0)\n                heights.add(-h);\n            else\n                heights.remove(h);\n            int cur = heights.first();\n            if (cur != prev) {\n                skyline.add(Arrays.asList(x, cur));\n                prev = cur;\n            }\n        }\n        return skyline;\n    }\n}", "cpp": "#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int>> getSkyline(vector<vector<int>>& buildings) {\n    vector<pair<int, int>> points;\n    for (const auto &b : buildings) {\n        points.emplace_back(b[0], -b[2]);\n        points.emplace_back(b[1], b[2]);\n    }\n    sort(points.begin(), points.end());\n    multiset<int> heights = {0};\n    int prev = 0;\n    vector<vector<int>> skyline;\n    for (const auto &[x, h] : points) {\n        if (h < 0)\n            heights.insert(-h);\n        else\n            heights.erase(heights.find(h));\n        int cur = *heights.rbegin();\n        if (cur != prev) {\n            skyline.push_back({x, cur});\n            prev = cur;\n        }\n    }\n    return skyline;\n}", "javascript": "function getSkyline(buildings) {\n    const points = [];\n    for (const [l, r, h] of buildings) {\n        points.push([l, -h]);\n        points.push([r, h]);\n    }\n    points.sort((a, b) => a[0] - b[0]);\n    const heights = new SortedSet([0]);\n    let prev = 0;\n    const skyline = [];\n    for (const [x, h] of points) {\n        if (h < 0) {\n            heights.add(-h);\n        } else {\n            heights.delete(h);\n        }\n        const cur = heights.last();\n        if (cur !== prev) {\n            skyline.push([x, cur]);\n            prev = cur;\n        }\n    }\n    return skyline;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/219", "prompt": "Given an integer array `nums` and an integer `k`, return `true` _if there are two **distinct indices**_ `i` _and_ `j` _in the array such that_ `nums[i] == nums[j]` _and_ `abs(i - j) <= k`.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3,1\\], k = 3\n**Output:** true\n\n**Example 2:**\n\n**Input:** nums = \\[1,0,1,1\\], k = 1\n**Output:** true\n\n**Example 3:**\n\n**Input:** nums = \\[1,2,3,1,2,3\\], k = 2\n**Output:** false\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-109 <= nums[i] <= 109`\n*   `0 <= k <= 105`", "entry_point": "contains_duplicate_ii", "canonical_solutions": {"python": "def containsNearbyDuplicate(nums, k):\n    value_index_map = {}\n    for i, num in enumerate(nums):\n        if num in value_index_map and i - value_index_map[num] <= k:\n            return True\n        value_index_map[num] = i\n    return False", "java": "public boolean containsNearbyDuplicate(int[] nums, int k) {\n    HashMap<Integer, Integer> valueIndexMap = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        if (valueIndexMap.containsKey(nums[i]) && i - valueIndexMap.get(nums[i]) <= k) {\n            return true;\n        }\n        valueIndexMap.put(nums[i], i);\n    }\n    return false;\n}", "cpp": "bool containsNearbyDuplicate(vector<int>& nums, int k) {\n    unordered_map<int, int> valueIndexMap;\n    for (int i = 0; i < nums.size(); i++) {\n        if (valueIndexMap.find(nums[i]) != valueIndexMap.end() && i - valueIndexMap[nums[i]] <= k) {\n            return true;\n        }\n        valueIndexMap[nums[i]] = i;\n    }\n    return false;\n}", "javascript": "function containsNearbyDuplicate(nums, k) {\n    const valueIndexMap = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        if (valueIndexMap.has(nums[i]) && i - valueIndexMap.get(nums[i]) <= k) {\n            return true;\n        }\n        valueIndexMap.set(nums[i], i);\n    }\n    return false;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/220", "prompt": "You are given an integer array `nums` and two integers `indexDiff` and `valueDiff`.\n\nFind a pair of indices `(i, j)` such that:\n\n*   `i != j`,\n*   `abs(i - j) <= indexDiff`.\n*   `abs(nums[i] - nums[j]) <= valueDiff`, and\n\nReturn `true` _if such pair exists or_ `false` _otherwise_.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3,1\\], indexDiff = 3, valueDiff = 0\n**Output:** true\n**Explanation:** We can choose (i, j) = (0, 3).\nWe satisfy the three conditions:\ni != j --> 0 != 3\nabs(i - j) <= indexDiff --> abs(0 - 3) <= 3\nabs(nums\\[i\\] - nums\\[j\\]) <= valueDiff --> abs(1 - 1) <= 0\n\n**Example 2:**\n\n**Input:** nums = \\[1,5,9,1,5,9\\], indexDiff = 2, valueDiff = 3\n**Output:** false\n**Explanation:** After trying all the possible pairs (i, j), we cannot satisfy the three conditions, so we return false.\n\n**Constraints:**\n\n*   `2 <= nums.length <= 105`\n*   `-109 <= nums[i] <= 109`\n*   `1 <= indexDiff <= nums.length`\n*   `0 <= valueDiff <= 109`", "entry_point": "contains_duplicate_iii", "canonical_solutions": {"python": "from sortedcontainers import SortedList\n\ndef containsNearbyAlmostDuplicate(nums, k, t):\n    window = SortedList()\n    for i in range(len(nums)):\n        if i > k:\n            window.remove(nums[i - k - 1])\n        pos = window.bisect_left(nums[i] - t)\n        if pos != len(window) and window[pos] - nums[i] <= t:\n            return True\n        window.add(nums[i])\n    return False", "java": "import java.util.TreeSet;\n\npublic boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\n    TreeSet<Long> window = new TreeSet<>();\n    for(int i = 0; i < nums.length; i++) {\n        if(i > k) {\n            window.remove((long)nums[i - k - 1]);\n        }\n        Long ceil = window.ceiling((long)nums[i] - t);\n        if(ceil != null && ceil - nums[i] <= t) {\n            return true;\n        }\n        window.add((long)nums[i]);\n    }\n    return false;\n}", "cpp": "#include <vector>\n#include <set>\nusing namespace std;\n\nbool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\n    set<long> window;\n    for (int i = 0; i < nums.size(); i++) {\n        if (i > k) {\n            window.erase(nums[i - k - 1]);\n        }\n        auto pos = window.lower_bound((long)nums[i] - t);\n        if (pos != window.end() && *pos - nums[i] <= t) {\n            return true;\n        }\n        window.insert(nums[i]);\n    }\n    return false;\n}", "javascript": "function containsNearbyAlmostDuplicate(nums, k, t) {\n    let window = new Set();\n    for (let i = 0; i < nums.length; i++) {\n        if (i > k) {\n            window.delete(nums[i - k - 1]);\n        }\n        for (const num of window) {\n            if (Math.abs(num - nums[i]) <= t) {\n                return true;\n            }\n        }\n        window.add(nums[i]);\n    }\n    return false;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/221", "prompt": "Given an `m x n` binary `matrix` filled with `0`'s and `1`'s, _find the largest square containing only_ `1`'s _and return its area_.\n\n**Example 1:**\n\n**Input:** matrix = \\[\\[ \"1 \", \"0 \", \"1 \", \"0 \", \"0 \"\\],\\[ \"1 \", \"0 \", \"1 \", \"1 \", \"1 \"\\],\\[ \"1 \", \"1 \", \"1 \", \"1 \", \"1 \"\\],\\[ \"1 \", \"0 \", \"0 \", \"1 \", \"0 \"\\]\\]\n**Output:** 4\n\n**Example 2:**\n\n**Input:** matrix = \\[\\[ \"0 \", \"1 \"\\],\\[ \"1 \", \"0 \"\\]\\]\n**Output:** 1\n\n**Example 3:**\n\n**Input:** matrix = \\[\\[ \"0 \"\\]\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `m == matrix.length`\n*   `n == matrix[i].length`\n*   `1 <= m, n <= 300`\n*   `matrix[i][j]` is `'0'` or `'1'`.", "entry_point": "maximal_square", "canonical_solutions": {"python": "def maximalSquare(matrix):\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    maxSize = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if matrix[i - 1][j - 1] == '1':\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                maxSize = max(maxSize, dp[i][j])\n\n    return maxSize * maxSize", "java": "public int maximalSquare(char[][] matrix) {\n    int m = matrix.length;\n    int n = matrix[0].length;\n    int[][] dp = new int[m + 1][n + 1];\n    int maxSize = 0;\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (matrix[i - 1][j - 1] == '1') {\n                dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;\n                maxSize = Math.max(maxSize, dp[i][j]);\n            }\n        }\n    }\n\n    return maxSize * maxSize;\n}", "cpp": "int maximalSquare(vector<vector<char>>& matrix) {\n    int m = matrix.size();\n    int n = matrix[0].size();\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n    int maxSize = 0;\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (matrix[i - 1][j - 1] == '1') {\n                dp[i][j] = min({dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]}) + 1;\n                maxSize = max(maxSize, dp[i][j]);\n            }\n        }\n    }\n    \n    return maxSize * maxSize;\n}", "javascript": "function maximalSquare(matrix) {\n    const m = matrix.length;\n    const n = matrix[0].length;\n    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));\n    let maxSize = 0;\n\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (matrix[i - 1][j - 1] === '1') {\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1;\n                maxSize = Math.max(maxSize, dp[i][j]);\n            }\n        }\n    }\n\n    return maxSize * maxSize;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/222", "prompt": "Given the `root` of a **complete** binary tree, return the number of the nodes in the tree.\n\nAccording to **[Wikipedia](http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees)**, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between `1` and `2h` nodes inclusive at the last level `h`.\n\nDesign an algorithm that runs in less than `O(n)` time complexity.\n\n**Example 1:**\n\n**Input:** root = \\[1,2,3,4,5,6\\]\n**Output:** 6\n\n**Example 2:**\n\n**Input:** root = \\[\\]\n**Output:** 0\n\n**Example 3:**\n\n**Input:** root = \\[1\\]\n**Output:** 1\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 5 * 104]`.\n*   `0 <= Node.val <= 5 * 104`\n*   The tree is guaranteed to be **complete**.", "entry_point": "count_complete_tree_nodes", "canonical_solutions": {"python": "class TreeNode:\n    def __init__(self, left=None, right=None):\n        self.left = left\n        self.right = right\n\ndef count_nodes(root):\n    if not root:\n        return 0\n    ld = rd = 0\n    l = r = root\n\n    while l:\n        l = l.left\n        ld += 1\n\n    while r:\n        r = r.right\n        rd += 1\n\n    if ld == rd:\n        return (1 << ld) - 1\n    return 1 + count_nodes(root.left) + count_nodes(root.right)", "java": "public class TreeNode {\n    TreeNode left;\n    TreeNode right;\n}\n\npublic int countNodes(TreeNode root) {\n    if (root == null) return 0;\n    int ld = 0, rd = 0;\n    TreeNode l = root, r = root;\n\n    while (l != null) {\n        l = l.left;\n        ld++;\n    }\n\n    while (r != null) {\n        r = r.right;\n        rd++;\n    }\n\n    if (ld == rd) return (1 << ld) - 1;\n    return 1 + countNodes(root.left) + countNodes(root.right);\n}", "cpp": "class TreeNode {\npublic:\n    TreeNode *left, *right;\n};\n\nint countNodes(TreeNode* root) {\n    if (!root) return 0;\n    int ld = 0, rd = 0;\n    TreeNode *l = root, *r = root;\n\n    while (l) {\n        l = l->left;\n        ld++;\n    }\n\n    while (r) {\n        r = r->right;\n        rd++;\n    }\n\n    if (ld == rd) return (1 << ld) - 1;\n    return 1 + countNodes(root->left) + countNodes(root->right);\n}", "javascript": "class TreeNode {\n    constructor(left = null, right = null) {\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction countNodes(root) {\n    if (!root) return 0;\n    let ld = 0, rd = 0;\n    let l = root, r = root;\n\n    while (l) {\n        l = l.left;\n        ld++;\n    }\n\n    while (r) {\n        r = r.right;\n        rd++;\n    }\n\n    if (ld === rd) return (1 << ld) - 1;\n    return 1 + countNodes(root.left) + countNodes(root.right);\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/223", "prompt": "Given the coordinates of two **rectilinear** rectangles in a 2D plane, return _the total area covered by the two rectangles_.\n\nThe first rectangle is defined by its **bottom-left** corner `(ax1, ay1)` and its **top-right** corner `(ax2, ay2)`.\n\nThe second rectangle is defined by its **bottom-left** corner `(bx1, by1)` and its **top-right** corner `(bx2, by2)`.\n\n**Example 1:**\n\n**Input:** ax1 = -3, ay1 = 0, ax2 = 3, ay2 = 4, bx1 = 0, by1 = -1, bx2 = 9, by2 = 2\n**Output:** 45\n\n**Example 2:**\n\n**Input:** ax1 = -2, ay1 = -2, ax2 = 2, ay2 = 2, bx1 = -2, by1 = -2, bx2 = 2, by2 = 2\n**Output:** 16\n\n**Constraints:**\n\n*   `-104 <= ax1 <= ax2 <= 104`\n*   `-104 <= ay1 <= ay2 <= 104`\n*   `-104 <= bx1 <= bx2 <= 104`\n*   `-104 <= by1 <= by2 <= 104`", "entry_point": "rectangle_area", "canonical_solutions": {"python": "def total_area(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2):\n    area1 = (ax2 - ax1) * (ay2 - ay1)\n    area2 = (bx2 - bx1) * (by2 - by1)\n\n    overlap_width = min(ax2, bx2) - max(ax1, bx1)\n    overlap_height = min(ay2, by2) - max(ay1, by1)\n\n    overlap_area = max(overlap_width, 0) * max(overlap_height, 0)\n\n    return area1 + area2 - overlap_area", "java": "public int totalArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\n    int area1 = (ax2 - ax1) * (ay2 - ay1);\n    int area2 = (bx2 - bx1) * (by2 - by1);\n\n    int overlapWidth = Math.min(ax2, bx2) - Math.max(ax1, bx1);\n    int overlapHeight = Math.min(ay2, by2) - Math.max(ay1, by1);\n\n    int overlapArea = Math.max(overlapWidth, 0) * Math.max(overlapHeight, 0);\n\n    return area1 + area2 - overlapArea;\n}", "cpp": "int totalArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\n    int area1 = (ax2 - ax1) * (ay2 - ay1);\n    int area2 = (bx2 - bx1) * (by2 - by1);\n\n    int overlapWidth = min(ax2, bx2) - max(ax1, bx1);\n    int overlapHeight = min(ay2, by2) - max(ay1, by1);\n\n    int overlapArea = max(overlapWidth, 0) * max(overlapHeight, 0);\n\n    return area1 + area2 - overlapArea;\n}", "javascript": "function totalArea(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {\n    const area1 = (ax2 - ax1) * (ay2 - ay1);\n    const area2 = (bx2 - bx1) * (by2 - by1);\n\n    const overlapWidth = Math.min(ax2, bx2) - Math.max(ax1, bx1);\n    const overlapHeight = Math.min(ay2, by2) - Math.max(ay1, by1);\n\n    const overlapArea = Math.max(overlapWidth, 0) * Math.max(overlapHeight, 0);\n\n    return area1 + area2 - overlapArea;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/224", "prompt": "Given a string `s` representing a valid expression, implement a basic calculator to evaluate it, and return _the result of the evaluation_.\n\n**Note:** You are **not** allowed to use any built-in function which evaluates strings as mathematical expressions, such as `eval()`.\n\n**Example 1:**\n\n**Input:** s =  \"1 + 1 \"\n**Output:** 2\n\n**Example 2:**\n\n**Input:** s =  \" 2-1 + 2  \"\n**Output:** 3\n\n**Example 3:**\n\n**Input:** s =  \"(1+(4+5+2)-3)+(6+8) \"\n**Output:** 23\n\n**Constraints:**\n\n*   `1 <= s.length <= 3 * 105`\n*   `s` consists of digits, `'+'`, `'-'`, `'('`, `')'`, and `' '`.\n*   `s` represents a valid expression.\n*   `'+'` is **not** used as a unary operation (i.e., `\"+1 \"` and `\"+(2 + 3) \"` is invalid).\n*   `'-'` could be used as a unary operation (i.e., `\"-1 \"` and `\"-(2 + 3) \"` is valid).\n*   There will be no two consecutive operators in the input.\n*   Every number and running calculation will fit in a signed 32-bit integer.", "entry_point": "basic_calculator", "canonical_solutions": {"python": "def calculate(s: str) -> int:\n    result = 0\n    sign = 1\n    num = 0\n    st = []\n    for c in s:\n        if c.isdigit():\n            num = num * 10 + int(c)\n        else:\n            result += sign * num\n            num = 0\n            if c == '+':\n                sign = 1\n            elif c == '-':\n                sign = -1\n            elif c == '(':\n                st.append(result)\n                st.append(sign)\n                result = 0\n                sign = 1\n            elif c == ')':\n                prev_sign = st.pop()\n                prev_result = st.pop()\n                result = prev_result + prev_sign * result\n    result += sign * num\n    return result", "java": "public int calculate(String s) {\n    int result = 0, sign = 1, num = 0;\n    Stack<Integer> st = new Stack<>();\n    for (char c : s.toCharArray()) {\n        if (Character.isDigit(c)) {\n            num = num * 10 + (c - '0');\n        } else {\n            result += sign * num;\n            num = 0;\n            if (c == '+') {\n                sign = 1;\n            } else if (c == '-') {\n                sign = -1;\n            } else if (c == '(') {\n                st.push(result);\n                st.push(sign);\n                result = 0;\n                sign = 1;\n            } else if (c == ')') {\n                int prev_sign = st.pop();\n                int prev_result = st.pop();\n                result = prev_result + prev_sign * result;\n            }\n        }\n    }\n    result += sign * num;\n    return result;\n}", "cpp": "int calculate(string s) {\n    int result = 0, sign = 1, num = 0;\n    stack<int> st;\n    for (char c : s) {\n        if (isdigit(c)) {\n            num = num * 10 + (c - '0');\n        } else {\n            result += sign * num;\n            num = 0;\n            if (c == '+') {\n                sign = 1;\n            } else if (c == '-') {\n                sign = -1;\n            } else if (c == '(') {\n                st.push(result);\n                st.push(sign);\n                result = 0;\n                sign = 1;\n            } else if (c == ')') {\n                int prev_sign = st.top();\n                st.pop();\n                int prev_result = st.top();\n                st.pop();\n                result = prev_result + prev_sign * result;\n            }\n        }\n    }\n    result += sign * num;\n    return result;\n}", "javascript": "function calculate(s) {\n    let result = 0, sign = 1, num = 0;\n    let st = [];\n    for (let c of s) {\n        if (/\\d/.test(c)) {\n            num = num * 10 + (c - '0');\n        } else {\n            result += sign * num;\n            num = 0;\n            if (c === '+') {\n                sign = 1;\n            } else if (c === '-') {\n                sign = -1;\n            } else if (c === '(') {\n                st.push(result);\n                st.push(sign);\n                result = 0;\n                sign = 1;\n            } else if (c === ')') {\n                let prev_sign = st.pop();\n                let prev_result = st.pop();\n                result = prev_result + prev_sign * result;\n            }\n        }\n    }\n    result += sign * num;\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/225", "prompt": "Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (`push`, `top`, `pop`, and `empty`).\n\nImplement the `MyStack` class:\n\n*   `void push(int x)` Pushes element x to the top of the stack.\n*   `int pop()` Removes the element on the top of the stack and returns it.\n*   `int top()` Returns the element on the top of the stack.\n*   `boolean empty()` Returns `true` if the stack is empty, `false` otherwise.\n\n**Notes:**\n\n*   You must use **only** standard operations of a queue, which means that only `push to back`, `peek/pop from front`, `size` and `is empty` operations are valid.\n*   Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue's standard operations.\n\n**Example 1:**\n\n**Input**\n\\[ \"MyStack \",  \"push \",  \"push \",  \"top \",  \"pop \",  \"empty \"\\]\n\\[\\[\\], \\[1\\], \\[2\\], \\[\\], \\[\\], \\[\\]\\]\n**Output**\n\\[null, null, null, 2, 2, false\\]\n\n**Explanation**\nMyStack myStack = new MyStack();\nmyStack.push(1);\nmyStack.push(2);\nmyStack.top(); // return 2\nmyStack.pop(); // return 2\nmyStack.empty(); // return False\n\n**Constraints:**\n\n*   `1 <= x <= 9`\n*   At most `100` calls will be made to `push`, `pop`, `top`, and `empty`.\n*   All the calls to `pop` and `top` are valid.\n\n**Follow-up:** Can you implement the stack using only one queue?", "entry_point": "implement_stack_using_queues", "canonical_solutions": {"python": "from collections import deque\n\nclass MyStack:\n\n    def __init__(self):\n        self.q1 = deque()\n        self.q2 = deque()\n\n    def push(self, x: int) -> None:\n        self.q2.append(x)\n        while self.q1:\n            self.q2.append(self.q1.popleft())\n        self.q1, self.q2 = self.q2, self.q1\n\n    def pop(self) -> int:\n        return self.q1.popleft()\n\n    def top(self) -> int:\n        return self.q1[0]\n\n    def empty(self) -> bool:\n        return not self.q1", "java": "import java.util.*;\n\nclass MyStack {\n    Queue<Integer> q1 = new LinkedList<>();\n    Queue<Integer> q2 = new LinkedList<>();\n\n    public void push(int x) {\n        q2.add(x);\n        while (!q1.isEmpty()) {\n            q2.add(q1.remove());\n        }\n        Queue<Integer> temp = q1;\n        q1 = q2;\n        q2 = temp;\n    }\n\n    public int pop() {\n        return q1.remove();\n    }\n\n    public int top() {\n        return q1.peek();\n    }\n\n    public boolean empty() {\n        return q1.isEmpty();\n    }\n}", "cpp": "#include <queue>\n\nclass MyStack {\npublic:\n    std::queue<int> q1, q2;\n\n    void push(int x) {\n        q2.push(x);\n        while (!q1.empty()) {\n            q2.push(q1.front());\n            q1.pop();\n        }\n        std::swap(q1, q2);\n    }\n\n    int pop() {\n        int top = q1.front();\n        q1.pop();\n        return top;\n    }\n\n    int top() {\n        return q1.front();\n    }\n\n    bool empty() {\n        return q1.empty();\n    }\n};", "javascript": "class MyStack {\n    constructor() {\n        this.q1 = [];\n        this.q2 = [];\n    }\n\n    push(x) {\n        this.q2.push(x);\n        while (this.q1.length > 0) {\n            this.q2.push(this.q1.shift());\n        }\n        [this.q1, this.q2] = [this.q2, this.q1];\n    }\n\n    pop() {\n        return this.q1.shift();\n    }\n\n    top() {\n        return this.q1[0];\n    }\n\n    empty() {\n        return this.q1.length === 0;\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/226", "prompt": "Given the `root` of a binary tree, invert the tree, and return _its root_.\n\n**Example 1:**\n\n**Input:** root = \\[4,2,7,1,3,6,9\\]\n**Output:** \\[4,7,2,9,6,3,1\\]\n\n**Example 2:**\n\n**Input:** root = \\[2,1,3\\]\n**Output:** \\[2,3,1\\]\n\n**Example 3:**\n\n**Input:** root = \\[\\]\n**Output:** \\[\\]\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 100]`.\n*   `-100 <= Node.val <= 100`", "entry_point": "invert_binary_tree", "canonical_solutions": {"python": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef invert_tree(root):\n    if root is None:\n        return None\n    root.left, root.right = invert_tree(root.right), invert_tree(root.left)\n    return root", "java": "public class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic TreeNode invertTree(TreeNode root) {\n    if (root == null) {\n        return null;\n    }    \n    TreeNode temp = root.left;\n    root.left = invertTree(root.right);\n    root.right = invertTree(temp);\n    return root;\n}", "cpp": "struct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nTreeNode* invertTree(TreeNode* root) {\n    if (root == nullptr) {\n        return nullptr;\n    }    \n    TreeNode* temp = root->left;\n    root->left = invertTree(root->right);\n    root->right = invertTree(temp);\n    return root;\n}", "javascript": "class TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction invertTree(root) {\n    if (root === null) {\n        return null;\n    }\n    let temp = root.left;\n    root.left = invertTree(root.right);\n    root.right = invertTree(temp);\n    return root;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/227", "prompt": "Given a string `s` which represents an expression, _evaluate this expression and return its value_.\n\nThe integer division should truncate toward zero.\n\nYou may assume that the given expression is always valid. All intermediate results will be in the range of `[-231, 231 - 1]`.\n\n**Note:** You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as `eval()`.\n\n**Example 1:**\n\n**Input:** s = \"3+2\\*2\"\n**Output:** 7\n\n**Example 2:**\n\n**Input:** s = \" 3/2 \"\n**Output:** 1\n\n**Example 3:**\n\n**Input:** s = \" 3+5 / 2 \"\n**Output:** 5\n\n**Constraints:**\n\n*   `1 <= s.length <= 3 * 105`\n*   `s` consists of integers and operators `('+', '-', '*', '/')` separated by some number of spaces.\n*   `s` represents **a valid expression**.\n*   All the integers in the expression are non-negative integers in the range `[0, 231 - 1]`.\n*   The answer is **guaranteed** to fit in a **32-bit integer**.", "entry_point": "basic_calculator_ii", "canonical_solutions": {"python": "def calculate(s: str) -> int:\n    result, num, sign, stack = 0, 0, 1, []\n\n    for c in s:\n        if c.isdigit():\n            num = num * 10 + int(c)\n        elif c == '+':\n            result += sign * num\n            num = 0\n            sign = 1\n        elif c == '-':\n            result += sign * num\n            num = 0\n            sign = -1\n        elif c == '(':\n            stack.append(result)\n            stack.append(sign)\n            result = 0\n            sign = 1\n        elif c == ')':\n            result += sign * num\n            num = 0\n            result *= stack.pop()\n            result += stack.pop()\n    \n    if num:\n        result += sign * num\n        \n    return result", "java": "public int calculate(String s) {\n    int result = 0, num = 0, sign = 1;\n    Stack<Integer> stack = new Stack<>();\n\n    for (char c : s.toCharArray()) {\n        if (Character.isDigit(c)) {\n            num = num * 10 + (c - '0');\n        } else if (c == '+') {\n            result += sign * num;\n            num = 0;\n            sign = 1;\n        } else if (c == '-') {\n            result += sign * num;\n            num = 0;\n            sign = -1;\n        } else if (c == '(') {\n            stack.push(result);\n            stack.push(sign);\n            result = 0;\n            sign = 1;\n        } else if (c == ')') {\n            result += sign * num;\n            num = 0;\n            result *= stack.pop();\n            result += stack.pop();\n        }\n    }\n    if (num != 0) result += sign * num;\n    return result;\n}", "cpp": "int calculate(string s) {\n    int result = 0, num = 0, sign = 1;\n    stack<int> st;\n    \n    for (char c : s) {\n        if (isdigit(c)) {\n            num = num * 10 + (c - '0');\n        } else if (c == '+') {\n            result += sign * num;\n            num = 0;\n            sign = 1;\n        } else if (c == '-') {\n            result += sign * num;\n            num = 0;\n            sign = -1;\n        } else if (c == '(') {\n            st.push(result);\n            st.push(sign);\n            result = 0;\n            sign = 1;\n        } else if (c == ')') {\n            result += sign * num;\n            num = 0;\n            result *= st.top(); st.pop();\n            result += st.top(); st.pop();\n        }\n    }\n    if (num) result += sign * num;\n    return result;\n}", "javascript": "function calculate(s) {\n    let result = 0, num = 0, sign = 1;\n    const stack = [];\n\n    for (const c of s) {\n        if ('0' <= c && c <= '9') {\n            num = num * 10 + parseInt(c);\n        } else if (c === '+') {\n            result += sign * num;\n            num = 0;\n            sign = 1;\n        } else if (c === '-') {\n            result += sign * num;\n            num = 0;\n            sign = -1;\n        } else if (c === '(') {\n            stack.push(result);\n            stack.push(sign);\n            result = 0;\n            sign = 1;\n        } else if (c === ')') {\n            result += sign * num;\n            num = 0;\n            result *= stack.pop();\n            result += stack.pop();\n        }\n    }\n    if (num) result += sign * num;\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/228", "prompt": "You are given a **sorted unique** integer array `nums`.\n\nA **range** `[a,b]` is the set of all integers from `a` to `b` (inclusive).\n\nReturn _the **smallest sorted** list of ranges that **cover all the numbers in the array exactly**_. That is, each element of `nums` is covered by exactly one of the ranges, and there is no integer `x` such that `x` is in one of the ranges but not in `nums`.\n\nEach range `[a,b]` in the list should be output as:\n\n*   `\"a->b \"` if `a != b`\n*   `\"a \"` if `a == b`\n\n**Example 1:**\n\n**Input:** nums = \\[0,1,2,4,5,7\\]\n**Output:** \\[ \"0->2 \", \"4->5 \", \"7 \"\\]\n**Explanation:** The ranges are:\n\\[0,2\\] -->  \"0->2 \"\n\\[4,5\\] -->  \"4->5 \"\n\\[7,7\\] -->  \"7 \"\n\n**Example 2:**\n\n**Input:** nums = \\[0,2,3,4,6,8,9\\]\n**Output:** \\[ \"0 \", \"2->4 \", \"6 \", \"8->9 \"\\]\n**Explanation:** The ranges are:\n\\[0,0\\] -->  \"0 \"\n\\[2,4\\] -->  \"2->4 \"\n\\[6,6\\] -->  \"6 \"\n\\[8,9\\] -->  \"8->9 \"\n\n**Constraints:**\n\n*   `0 <= nums.length <= 20`\n*   `-231 <= nums[i] <= 231 - 1`\n*   All the values of `nums` are **unique**.\n*   `nums` is sorted in ascending order.", "entry_point": "summary_ranges", "canonical_solutions": {"python": "from typing import List\n\ndef find_ranges(nums: List[int]) -> List[str]:\n    result = []\n    n = len(nums)\n    if n == 0: \n        return result\n\n    start = nums[0]\n    for i in range(1, n):\n        if nums[i] > nums[i-1] + 1:\n            if start == nums[i-1]:\n                result.append(str(start))\n            else:\n                result.append(str(start) + \"->\" + str(nums[i-1]))\n            start = nums[i]\n\n    if start == nums[n-1]:\n        result.append(str(start))\n    else:\n        result.append(str(start) + \"->\" + str(nums[n-1]))\n\n    return result", "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> findRanges(int[] nums) {\n    List<String> result = new ArrayList<>();\n    int n = nums.length;\n    if (n == 0) return result;\n\n    int start = nums[0];\n    for (int i = 1; i < n; i++) {\n        if (nums[i] > nums[i-1] + 1) {\n            if (start == nums[i-1])\n                result.add(Integer.toString(start));\n            else\n                result.add(start + \"->\" + nums[i-1]);\n            start = nums[i];\n        }\n    }\n\n    if (start == nums[n-1])\n        result.add(Integer.toString(start));\n    else\n        result.add(start + \"->\" + nums[n-1]);\n\n    return result;\n}", "cpp": "#include <vector>\n#include <string>\n\nstd::vector<std::string> find_ranges(std::vector<int>& nums) {\n    std::vector<std::string> result;\n    int n = nums.size();\n    if (n == 0) return result;\n\n    int start = nums[0];\n    for (int i = 1; i < n; ++i) {\n        if (nums[i] > nums[i-1] + 1) {\n            if (start == nums[i-1])\n                result.push_back(std::to_string(start));\n            else\n                result.push_back(std::to_string(start) + \"->\" + std::to_string(nums[i-1]));\n            start = nums[i];\n        }\n    }\n\n    if (start == nums[n-1])\n        result.push_back(std::to_string(start));\n    else\n        result.push_back(std::to_string(start) + \"->\" + std::to_string(nums[n-1]));\n\n    return result;\n}", "javascript": "function findRanges(nums) {\n    const result = [];\n    const n = nums.length;\n    if (n === 0) return result;\n\n    let start = nums[0];\n    for (let i = 1; i < n; i++) {\n        if (nums[i] > nums[i - 1] + 1) {\n            if (start === nums[i - 1])\n                result.push(`${start}`);\n            else\n                result.push(`${start}->${nums[i - 1]}`);\n            start = nums[i];\n        }\n    }\n\n    if (start === nums[n - 1])\n        result.push(`${start}`);\n    else\n        result.push(`${start}->${nums[n - 1]}`);\n\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/229", "prompt": "Given an integer array of size `n`, find all elements that appear more than `\u230a n/3 \u230b` times.\n\n**Example 1:**\n\n**Input:** nums = \\[3,2,3\\]\n**Output:** \\[3\\]\n\n**Example 2:**\n\n**Input:** nums = \\[1\\]\n**Output:** \\[1\\]\n\n**Example 3:**\n\n**Input:** nums = \\[1,2\\]\n**Output:** \\[1,2\\]\n\n**Constraints:**\n\n*   `1 <= nums.length <= 5 * 104`\n*   `-109 <= nums[i] <= 109`\n\n**Follow up:** Could you solve the problem in linear time and in `O(1)` space?", "entry_point": "majority_element_ii", "canonical_solutions": {"python": "def majorityElement(nums):\n    n = len(nums)\n    count = {}\n    result = []\n\n    for num in nums:\n        if num not in count:\n            count[num] = 1\n        else:\n            count[num] += 1\n        if count[num] > n / 3 and num not in result:\n            result.append(num)\n\n    return result", "java": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\n\npublic List<Integer> majorityElement(int[] nums) {\n    int n = nums.length;\n    HashMap<Integer, Integer> count = new HashMap<>();\n    ArrayList<Integer> result = new ArrayList<>();\n\n    for (int num : nums) {\n        count.put(num, count.getOrDefault(num, 0) + 1);\n        if (count.get(num) > n / 3 && !result.contains(num)) {\n            result.add(num);\n        }\n    }\n    return result;\n}", "cpp": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nvector<int> majorityElement(vector<int>& nums) {\n    int n = nums.size();\n    unordered_map<int, int> count;\n    vector<int> result;\n\n    for (int num : nums) {\n        if (count.find(num) == count.end()) {\n            count[num] = 1;\n        } else {\n            count[num]++;\n        }\n        if (count[num] > n / 3 && find(result.begin(), result.end(), num) == result.end()) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}", "javascript": "function majorityElement(nums) {\n    const n = nums.length;\n    const count = {};\n    const result = [];\n\n    for (const num of nums) {\n        if (count.hasOwnProperty(num)) {\n            count[num]++;\n        } else {\n            count[num] = 1;\n        }\n        if (count[num] > n / 3 && !result.includes(num)) {\n            result.push(num);\n        }\n    }\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/230", "prompt": "Given the `root` of a binary search tree, and an integer `k`, return _the_ `kth` _smallest value (**1-indexed**) of all the values of the nodes in the tree_.\n\n**Example 1:**\n\n**Input:** root = \\[3,1,4,null,2\\], k = 1\n**Output:** 1\n\n**Example 2:**\n\n**Input:** root = \\[5,3,6,2,4,null,null,1\\], k = 3\n**Output:** 3\n\n**Constraints:**\n\n*   The number of nodes in the tree is `n`.\n*   `1 <= k <= n <= 104`\n*   `0 <= Node.val <= 104`\n\n**Follow up:** If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?", "entry_point": "kth_smallest_element_in_a_bst", "canonical_solutions": {"python": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef kthSmallest(root, k):\n    stk = []\n    curr = root\n    \n    while True:\n        while curr:\n            stk.append(curr)\n            curr = curr.left\n        \n        curr = stk.pop()\n        \n        k -= 1\n        if k == 0:\n            return curr.val\n        \n        curr = curr.right", "java": "public class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic int kthSmallest(TreeNode root, int k) {\n    Stack<TreeNode> stk = new Stack<>();\n    TreeNode curr = root;\n    \n    while (true) {\n        while (curr != null) {\n            stk.push(curr);\n            curr = curr.left;\n        }\n        \n        curr = stk.pop();\n        \n        if (--k == 0) return curr.val;\n        \n        curr = curr.right;\n    }\n}", "cpp": "class TreeNode {\npublic:\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nint kthSmallest(TreeNode* root, int k) {\n    stack<TreeNode*> stk;\n    TreeNode* curr = root;\n    \n    while (true) {\n        while (curr) {\n            stk.push(curr);\n            curr = curr->left;\n        }\n        \n        curr = stk.top();\n        stk.pop();\n        \n        if (--k == 0) return curr->val;\n        \n        curr = curr->right;\n    }\n}", "javascript": "class TreeNode {\n    constructor(val, left=null, right=null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction kthSmallest(root, k) {\n    let stk = [];\n    let curr = root;\n    \n    while (true) {\n        while (curr) {\n            stk.push(curr);\n            curr = curr.left;\n        }\n        \n        curr = stk.pop();\n        \n        k -= 1;\n        if (k === 0) return curr.val;\n        \n        curr = curr.right;\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/231", "prompt": "Given an integer `n`, return _`true` if it is a power of two. Otherwise, return `false`_.\n\nAn integer `n` is a power of two, if there exists an integer `x` such that `n == 2x`.\n\n**Example 1:**\n\n**Input:** n = 1\n**Output:** true\n**Explanation:** 20 = 1\n\n**Example 2:**\n\n**Input:** n = 16\n**Output:** true\n**Explanation:** 24 = 16\n\n**Example 3:**\n\n**Input:** n = 3\n**Output:** false\n\n**Constraints:**\n\n*   `-231 <= n <= 231 - 1`\n\n**Follow up:** Could you solve it without loops/recursion?", "entry_point": "power_of_two", "canonical_solutions": {"python": "def is_power_of_two(n):\n    if n <= 0:\n        return False\n    return (n & (n - 1)) == 0", "java": "boolean isPowerOfTwo(int n) {\n    if (n <= 0) {\n        return false;\n    }\n    return (n & (n - 1)) == 0;\n}", "cpp": "bool isPowerOfTwo(int n) {\n    if (n <= 0) {\n        return false;\n    }\n    return (n & (n - 1)) == 0;\n}", "javascript": "function isPowerOfTwo(n) {\n    if (n <= 0) {\n        return false;\n    }\n    return (n & (n - 1)) == 0;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/232", "prompt": "Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (`push`, `peek`, `pop`, and `empty`).\n\nImplement the `MyQueue` class:\n\n*   `void push(int x)` Pushes element x to the back of the queue.\n*   `int pop()` Removes the element from the front of the queue and returns it.\n*   `int peek()` Returns the element at the front of the queue.\n*   `boolean empty()` Returns `true` if the queue is empty, `false` otherwise.\n\n**Notes:**\n\n*   You must use **only** standard operations of a stack, which means only `push to top`, `peek/pop from top`, `size`, and `is empty` operations are valid.\n*   Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations.\n\n**Example 1:**\n\n**Input**\n\\[ \"MyQueue \",  \"push \",  \"push \",  \"peek \",  \"pop \",  \"empty \"\\]\n\\[\\[\\], \\[1\\], \\[2\\], \\[\\], \\[\\], \\[\\]\\]\n**Output**\n\\[null, null, null, 1, 1, false\\]\n\n**Explanation**\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: \\[1\\]\nmyQueue.push(2); // queue is: \\[1, 2\\] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is \\[2\\]\nmyQueue.empty(); // return false\n\n**Constraints:**\n\n*   `1 <= x <= 9`\n*   At most `100` calls will be made to `push`, `pop`, `peek`, and `empty`.\n*   All the calls to `pop` and `peek` are valid.\n\n**Follow-up:** Can you implement the queue such that each operation is **[amortized](https://en.wikipedia.org/wiki/Amortized_analysis)** `O(1)` time complexity? In other words, performing `n` operations will take overall `O(n)` time even if one of those operations may take longer.", "entry_point": "implement_queue_using_stacks", "canonical_solutions": {"python": "class MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n    def peek(self) -> int:\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]\n\n    def empty(self) -> bool:\n        return not self.stack1 and not self.stack2", "java": "import java.util.Stack;\n\nclass MyQueue {\n\n    private Stack<Integer> stack1;\n    private Stack<Integer> stack2;\n\n    public MyQueue() {\n        stack1 = new Stack<>();\n        stack2 = new Stack<>();\n    }\n\n    public void push(int x) {\n        stack1.push(x);\n    }\n\n    public int pop() {\n        if (stack2.isEmpty()) {\n            while (!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.pop();\n    }\n\n    public int peek() {\n        if (stack2.isEmpty()) {\n            while (!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.peek();\n    }\n\n    public boolean empty() {\n        return stack1.isEmpty() && stack2.isEmpty();\n    }\n}", "cpp": "class MyQueue {\npublic:\n    stack<int> stack1, stack2;\n\n    MyQueue() {\n    }\n\n    void push(int x) {\n        stack1.push(x);\n    }\n\n    int pop() {\n        if (stack2.empty()) {\n            while (!stack1.empty()) {\n                stack2.push(stack1.top());\n                stack1.pop();\n            }\n        }\n        int top_element = stack2.top();\n        stack2.pop();\n        return top_element;\n    }\n\n    int peek() {\n        if (stack2.empty()) {\n            while (!stack1.empty()) {\n                stack2.push(stack1.top());\n                stack1.pop();\n            }\n        }\n        return stack2.top();\n    }\n\n    bool empty() {\n        return stack1.empty() && stack2.empty();\n    }\n};", "javascript": "class MyQueue {\n    constructor() {\n        this.stack1 = [];\n        this.stack2 = [];\n    }\n\n    push(x) {\n        this.stack1.push(x);\n    }\n\n    pop() {\n        if (this.stack2.length === 0) {\n            while (this.stack1.length > 0) {\n                this.stack2.push(this.stack1.pop());\n            }\n        }\n        return this.stack2.pop();\n    }\n\n    peek() {\n        if (this.stack2.length === 0) {\n            while (this.stack1.length > 0) {\n                this.stack2.push(this.stack1.pop());\n            }\n        }\n        return this.stack2[this.stack2.length - 1];\n    }\n\n    empty() {\n        return this.stack1.length === 0 && this.stack2.length === 0;\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/233", "prompt": "Given an integer `n`, count _the total number of digit_ `1` _appearing in all non-negative integers less than or equal to_ `n`.\n\n**Example 1:**\n\n**Input:** n = 13\n**Output:** 6\n\n**Example 2:**\n\n**Input:** n = 0\n**Output:** 0\n\n**Constraints:**\n\n*   `0 <= n <= 109`", "entry_point": "number_of_digit_one", "canonical_solutions": {"python": "def countDigitOne(n):\n    count = 0\n    i = 1\n    while i <= n:\n        divider = i * 10\n        count += (n // divider) * i + min(max(n % divider - i + 1, 0), i)\n        i *= 10\n    return count", "java": "public int countDigitOne(int n) {\n    int count = 0;\n    for(long i = 1; i <= n; i *= 10){\n        long divider = i * 10;\n        count += (n / divider) * i + Math.min(Math.max(n % divider - i + 1, 0), i);\n    }\n    return count;\n}", "cpp": "int countDigitOne(int n) {\n    int count = 0;\n    for(long long i = 1; i <= n; i *= 10){\n        int divider = i * 10;\n        count += (n / divider) * i + min(max(n % divider - i + 1, 0LL), i);\n    }\n    return count;\n}", "javascript": "function countDigitOne(n) {\n    let count = 0;\n    for(let i = 1; i <= n; i *= 10){\n        let divider = i * 10;\n        count += Math.floor(n / divider) * i + Math.min(Math.max(n % divider - i + 1, 0), i);\n    }\n    return count;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/234", "prompt": "Given the `head` of a singly linked list, return `true` _if it is a_ _palindrome_ _or_ `false` _otherwise_.\n\n**Example 1:**\n\n**Input:** head = \\[1,2,2,1\\]\n**Output:** true\n\n**Example 2:**\n\n**Input:** head = \\[1,2\\]\n**Output:** false\n\n**Constraints:**\n\n*   The number of nodes in the list is in the range `[1, 105]`.\n*   `0 <= Node.val <= 9`\n\n**Follow up:** Could you do it in `O(n)` time and `O(1)` space?", "entry_point": "palindrome_linked_list", "canonical_solutions": {"python": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef isPalindrome(head):\n    if not head or not head.next:\n        return True\n\n    fast, slow, prev = head, head, None\n    while fast and fast.next:\n        fast = fast.next.next\n        temp = slow.next\n        slow.next = prev\n        prev = slow\n        slow = temp\n\n    if fast:\n        slow = slow.next\n\n    while prev and prev.val == slow.val:\n        prev = prev.next\n        slow = slow.next\n\n    return prev == None", "java": "class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) { val = x; }\n}\n\npublic boolean isPalindrome(ListNode head) {\n    if (head == null || head.next == null) return true;\n\n    ListNode fast = head, slow = head, prev = null;\n    while (fast != null && fast.next != null) {\n        fast = fast.next.next;\n        ListNode temp = slow.next;\n        slow.next = prev;\n        prev = slow;\n        slow = temp;\n    }\n    \n    if (fast != null) slow = slow.next;\n\n    while (prev != null && prev.val == slow.val) {\n        prev = prev.next;\n        slow = slow.next;\n    }\n\n    return prev == null;\n}", "cpp": "class ListNode {\npublic:\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nbool isPalindrome(ListNode* head) {\n    if (!head || !head->next) return true;\n\n    ListNode *fast = head, *slow = head, *prev = NULL;\n    while (fast && fast->next) {\n        fast = fast->next->next;\n        ListNode *temp = slow->next;\n        slow->next = prev;\n        prev = slow;\n        slow = temp;\n    }\n    \n    if (fast) slow = slow->next;\n\n    while (prev && prev->val == slow->val) {\n        prev = prev->next;\n        slow = slow->next;\n    }\n\n    return prev == NULL;\n}", "javascript": "class ListNode {\n    constructor(val, next) {\n        this.val = val === undefined ? 0 : val;\n        this.next = next === undefined ? null : next;\n    }\n}\n\nfunction isPalindrome(head) {\n    if (!head || !head.next) return true;\n\n    let fast = head, slow = head, prev = null;\n    while (fast && fast.next) {\n        fast = fast.next.next;\n        let temp = slow.next;\n        slow.next = prev;\n        prev = slow;\n        slow = temp;\n    }\n\n    if (fast) slow = slow.next;\n\n    while (prev && prev.val === slow.val) {\n        prev = prev.next;\n        slow = slow.next;\n    }\n\n    return prev === null;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/235", "prompt": "Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.\n\nAccording to the [definition of LCA on Wikipedia](https://en.wikipedia.org/wiki/Lowest_common_ancestor): \"The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where we allow **a node to be a descendant of itself**).\"\n\n**Example 1:**\n\n**Input:** root = \\[6,2,8,0,4,7,9,null,null,3,5\\], p = 2, q = 8\n**Output:** 6\n**Explanation:** The LCA of nodes 2 and 8 is 6.\n\n**Example 2:**\n\n**Input:** root = \\[6,2,8,0,4,7,9,null,null,3,5\\], p = 2, q = 4\n**Output:** 2\n**Explanation:** The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.\n\n**Example 3:**\n\n**Input:** root = \\[2,1\\], p = 2, q = 1\n**Output:** 2\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[2, 105]`.\n*   `-109 <= Node.val <= 109`\n*   All `Node.val` are **unique**.\n*   `p != q`\n*   `p` and `q` will exist in the BST.", "entry_point": "lowest_common_ancestor_of_a_binary_search_tree", "canonical_solutions": {"python": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef lowest_common_ancestor(root, p, q):\n    if root is None or root == p or root == q:\n        return root\n\n    left = lowest_common_ancestor(root.left, p, q)\n    right = lowest_common_ancestor(root.right, p, q)\n\n    if left is not None and right is not None:\n        return root\n    else:\n        return left if left is not None else right", "java": "public class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n}\n\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n    if (root == null || root == p || root == q) {\n        return root;\n    }\n\n    TreeNode left = lowestCommonAncestor(root.left, p, q);\n    TreeNode right = lowestCommonAncestor(root.right, p, q);\n\n    if (left != null && right != null) {\n        return root;\n    } else {\n        return left != null ? left : right;\n    }\n}", "cpp": "struct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n};\n\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n    if (root == nullptr || root == p || root == q) {\n        return root;\n    }\n\n    TreeNode* left = lowestCommonAncestor(root->left, p, q);\n    TreeNode* right = lowestCommonAncestor(root->right, p, q);\n\n    if (left != nullptr && right != nullptr) {\n        return root;\n    } else {\n        return left != nullptr ? left : right;\n    }\n}", "javascript": "class TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction lowestCommonAncestor(root, p, q) {\n    if (!root || root === p || root === q) {\n        return root;\n    }\n\n    const left = lowestCommonAncestor(root.left, p, q);\n    const right = lowestCommonAncestor(root.right, p, q);\n\n    if (left && right) {\n        return root;\n    } else {\n        return left !== null ? left : right;\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/236", "prompt": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\n\nAccording to the [definition of LCA on Wikipedia](https://en.wikipedia.org/wiki/Lowest_common_ancestor): \"The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where we allow **a node to be a descendant of itself**).\"\n\n**Example 1:**\n\n**Input:** root = \\[3,5,1,6,2,0,8,null,null,7,4\\], p = 5, q = 1\n**Output:** 3\n**Explanation:** The LCA of nodes 5 and 1 is 3.\n\n**Example 2:**\n\n**Input:** root = \\[3,5,1,6,2,0,8,null,null,7,4\\], p = 5, q = 4\n**Output:** 5\n**Explanation:** The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.\n\n**Example 3:**\n\n**Input:** root = \\[1,2\\], p = 1, q = 2\n**Output:** 1\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[2, 105]`.\n*   `-109 <= Node.val <= 109`\n*   All `Node.val` are **unique**.\n*   `p != q`\n*   `p` and `q` will exist in the tree.", "entry_point": "lowest_common_ancestor_of_a_binary_tree", "canonical_solutions": {"python": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef lowestCommonAncestor(root, p, q):\n    if not root or root == p or root == q:\n        return root\n    left = lowestCommonAncestor(root.left, p, q)\n    right = lowestCommonAncestor(root.right, p, q)\n    return right if left is None else (left if right is None else root)", "java": "public class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n    if (root == null || root == p || root == q) return root;\n    TreeNode left = lowestCommonAncestor(root.left, p, q);\n    TreeNode right = lowestCommonAncestor(root.right, p, q);\n    return left == null ? right : (right == null ? left : root);\n}", "cpp": "struct TreeNode {\n  int val;\n  TreeNode *left;\n  TreeNode *right;\n};\n\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n  if (!root || root == p || root == q) return root;\n  TreeNode *left = lowestCommonAncestor(root->left, p, q);\n  TreeNode *right = lowestCommonAncestor(root->right, p, q);\n  return !left ? right : (!right ? left : root);\n}", "javascript": "class TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction lowestCommonAncestor(root, p, q) {\n    if (!root || root === p || root === q) return root;\n    const left = lowestCommonAncestor(root.left, p, q);\n    const right = lowestCommonAncestor(root.right, p, q);\n    return left === null ? right : (right === null ? left : root);\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/237", "prompt": "There is a singly-linked list `head` and we want to delete a node `node` in it.\n\nYou are given the node to be deleted `node`. You will **not be given access** to the first node of `head`.\n\nAll the values of the linked list are **unique**, and it is guaranteed that the given node `node` is not the last node in the linked list.\n\nDelete the given node. Note that by deleting the node, we do not mean removing it from memory. We mean:\n\n*   The value of the given node should not exist in the linked list.\n*   The number of nodes in the linked list should decrease by one.\n*   All the values before `node` should be in the same order.\n*   All the values after `node` should be in the same order.\n\n**Custom testing:**\n\n*   For the input, you should provide the entire linked list `head` and the node to be given `node`. `node` should not be the last node of the list and should be an actual node in the list.\n*   We will build the linked list and pass the node to your function.\n*   The output will be the entire list after calling your function.\n\n**Example 1:**\n\n**Input:** head = \\[4,5,1,9\\], node = 5\n**Output:** \\[4,1,9\\]\n**Explanation:** You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function.\n\n**Example 2:**\n\n**Input:** head = \\[4,5,1,9\\], node = 1\n**Output:** \\[4,5,9\\]\n**Explanation:** You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function.\n\n**Constraints:**\n\n*   The number of the nodes in the given list is in the range `[2, 1000]`.\n*   `-1000 <= Node.val <= 1000`\n*   The value of each node in the list is **unique**.\n*   The `node` to be deleted is **in the list** and is **not a tail** node.", "entry_point": "delete_node_in_a_linked_list", "canonical_solutions": {"python": "def deleteNode(node):\n    next_node = node.next\n    node.val = next_node.val\n    node.next = next_node.next", "java": "public void deleteNode(ListNode node) {\n    ListNode nextNode = node.next;\n    node.val = nextNode.val;\n    node.next = nextNode.next;\n}", "cpp": "void deleteNode(ListNode* node) {\n    ListNode* nextNode = node->next;\n    *node = *nextNode;\n    delete nextNode;\n}", "javascript": "function deleteNode(node) {\n    const nextNode = node.next;\n    node.val = nextNode.val;\n    node.next = nextNode.next;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/238", "prompt": "Given an integer array `nums`, return _an array_ `answer` _such that_ `answer[i]` _is equal to the product of all the elements of_ `nums` _except_ `nums[i]`.\n\nThe product of any prefix or suffix of `nums` is **guaranteed** to fit in a **32-bit** integer.\n\nYou must write an algorithm that runs in `O(n)` time and without using the division operation.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** \\[24,12,8,6\\]\n\n**Example 2:**\n\n**Input:** nums = \\[-1,1,0,-3,3\\]\n**Output:** \\[0,0,9,0,0\\]\n\n**Constraints:**\n\n*   `2 <= nums.length <= 105`\n*   `-30 <= nums[i] <= 30`\n*   The product of any prefix or suffix of `nums` is **guaranteed** to fit in a **32-bit** integer.\n\n**Follow up:** Can you solve the problem in `O(1)` extra space complexity? (The output array **does not** count as extra space for space complexity analysis.)", "entry_point": "product_of_array_except_self", "canonical_solutions": {"python": "def productExceptSelf(nums):\n    n = len(nums)\n    answer = [1] * n\n    \n    left = 1\n    for i in range(n):\n        answer[i] *= left\n        left *= nums[i]\n    \n    right = 1\n    for i in range(n - 1, -1, -1):\n        answer[i] *= right\n        right *= nums[i]\n    \n    return answer", "java": "public int[] productExceptSelf(int[] nums) {\n    int n = nums.length;\n    int[] answer = new int[n];\n    \n    Arrays.fill(answer, 1);\n    \n    int left = 1;\n    for (int i = 0; i < n; i++) {\n        answer[i] *= left;\n        left *= nums[i];\n    }\n    \n    int right = 1;\n    for (int i = n - 1; i >= 0; i--) {\n        answer[i] *= right;\n        right *= nums[i];\n    }\n    \n    return answer;\n}", "cpp": "vector<int> productExceptSelf(vector<int>& nums) {\n    int n = nums.size();\n    vector<int> answer(n, 1);\n    \n    int left = 1;\n    for (int i = 0; i < n; i++) {\n        answer[i] *= left;\n        left *= nums[i];\n    }\n    \n    int right = 1;\n    for (int i = n - 1; i >= 0; i--) {\n        answer[i] *= right;\n        right *= nums[i];\n    }\n    \n    return answer;\n}", "javascript": "function productExceptSelf(nums) {\n    const n = nums.length;\n    const answer = new Array(n).fill(1);\n    \n    let left = 1;\n    for (let i = 0; i < n; i++) {\n        answer[i] *= left;\n        left *= nums[i];\n    }\n    \n    let right = 1;\n    for (let i = n - 1; i >= 0; i--) {\n        answer[i] *= right;\n        right *= nums[i];\n    }\n    \n    return answer;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/239", "prompt": "You are given an array of integers `nums`, there is a sliding window of size `k` which is moving from the very left of the array to the very right. You can only see the `k` numbers in the window. Each time the sliding window moves right by one position.\n\nReturn _the max sliding window_.\n\n**Example 1:**\n\n**Input:** nums = \\[1,3,-1,-3,5,3,6,7\\], k = 3\n**Output:** \\[3,3,5,5,6,7\\]\n**Explanation:** \nWindow position                Max\n---------------               -----\n\\[1  3  -1\\] -3  5  3  6  7       **3**\n 1 \\[3  -1  -3\\] 5  3  6  7       **3**\n 1  3 \\[-1  -3  5\\] 3  6  7      ** 5**\n 1  3  -1 \\[-3  5  3\\] 6  7       **5**\n 1  3  -1  -3 \\[5  3  6\\] 7       **6**\n 1  3  -1  -3  5 \\[3  6  7\\]      **7**\n\n**Example 2:**\n\n**Input:** nums = \\[1\\], k = 1\n**Output:** \\[1\\]\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-104 <= nums[i] <= 104`\n*   `1 <= k <= nums.length`", "entry_point": "sliding_window_maximum", "canonical_solutions": {"python": "from collections import deque\n\ndef maxSlidingWindow(nums, k):\n    dq = deque()\n    result = []\n\n    for i in range(len(nums)):\n        while dq and dq[0] < i - k + 1:\n            dq.popleft()\n\n        while dq and nums[dq[-1]] < nums[i]:\n            dq.pop()\n\n        dq.append(i)\n\n        if i >= k - 1:\n            result.append(nums[dq[0]])\n\n    return result", "java": "import java.util.LinkedList;\nimport java.util.Deque;\n\npublic int[] maxSlidingWindow(int[] nums, int k) {\n    if (nums == null || nums.length == 0) return new int[0];\n    int[] result = new int[nums.length - k + 1];\n    int idx = 0;\n    Deque<Integer> deque = new LinkedList<Integer>();\n    \n    for (int i = 0; i < nums.length; i++) {\n        if (!deque.isEmpty() && deque.peekFirst() == i - k) deque.poll();\n            \n        while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {\n            deque.removeLast();\n        }    \n            \n        deque.offer(i);\n        if (i >= k - 1) {\n            result[idx++] = nums[deque.peek()];\n        }\n    }\n    return result;\n}", "cpp": "#include <vector>\n#include <deque>\n\nstd::vector<int> maxSlidingWindow(std::vector<int>& nums, int k) {\n    std::vector<int> result;\n    std::deque<int> dq;\n\n    for (int i = 0; i < nums.size(); i++) {\n        while (!dq.empty() && dq.front() < i - k + 1) {\n            dq.pop_front();\n        }\n\n        while (!dq.empty() && nums[dq.back()] < nums[i]) {\n            dq.pop_back();\n        }\n\n        dq.push_back(i);\n\n        if (i >= k - 1) {\n            result.push_back(nums[dq.front()]);\n        }\n    }\n\n    return result;\n}", "javascript": "function maxSlidingWindow(nums, k) {\n  let result = [];\n  let dq = [];\n\n  for (let i = 0; i < nums.length; i++) {\n    while (dq.length && dq[0] < i - k + 1) {\n      dq.shift();\n    }\n\n    while (dq.length && nums[dq[dq.length - 1]] < nums[i]) {\n      dq.pop();\n    }\n\n    dq.push(i);\n\n    if (i >= k - 1) {\n      result.push(nums[dq[0]]);\n    }\n  }\n\n  return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/240", "prompt": "Write an efficient algorithm that searches for a value `target` in an `m x n` integer matrix `matrix`. This matrix has the following properties:\n\n*   Integers in each row are sorted in ascending from left to right.\n*   Integers in each column are sorted in ascending from top to bottom.\n\n**Example 1:**\n\n**Input:** matrix = \\[\\[1,4,7,11,15\\],\\[2,5,8,12,19\\],\\[3,6,9,16,22\\],\\[10,13,14,17,24\\],\\[18,21,23,26,30\\]\\], target = 5\n**Output:** true\n\n**Example 2:**\n\n**Input:** matrix = \\[\\[1,4,7,11,15\\],\\[2,5,8,12,19\\],\\[3,6,9,16,22\\],\\[10,13,14,17,24\\],\\[18,21,23,26,30\\]\\], target = 20\n**Output:** false\n\n**Constraints:**\n\n*   `m == matrix.length`\n*   `n == matrix[i].length`\n*   `1 <= n, m <= 300`\n*   `-109 <= matrix[i][j] <= 109`\n*   All the integers in each row are **sorted** in ascending order.\n*   All the integers in each column are **sorted** in ascending order.\n*   `-109 <= target <= 109`", "entry_point": "search_a_2d_matrix_ii", "canonical_solutions": {"python": "def searchMatrix(matrix, target):\n    row, col = len(matrix) - 1, 0\n    while row >= 0 and col < len(matrix[0]):\n        if matrix[row][col] > target:\n            row -= 1\n        elif matrix[row][col] < target:\n            col += 1\n        else:\n            return True\n    return False", "java": "public boolean searchMatrix(int[][] matrix, int target) {\n    int row = matrix.length - 1, col = 0;\n    while (row >= 0 && col < matrix[0].length) {\n        if (matrix[row][col] > target) {\n            row--;\n        } else if (matrix[row][col] < target) {\n            col++;\n        } else {\n            return true;\n        }\n    }\n    return false;\n}", "cpp": "bool searchMatrix(vector<vector<int>>& matrix, int target) {\n    int row = matrix.size() - 1, col = 0;\n    while (row >= 0 && col < matrix[0].size()) {\n        if (matrix[row][col] > target) {\n            row--;\n        } else if (matrix[row][col] < target) {\n            col++;\n        } else {\n            return true;\n        }\n    }\n    return false;\n}", "javascript": "function searchMatrix(matrix, target) {\n    let row = matrix.length - 1, col = 0;\n    while(row >= 0 && col < matrix[0].length) {\n        if(matrix[row][col] > target) {\n            row--;\n        } else if(matrix[row][col] < target) {\n            col++;\n        } else {\n            return true;\n        }\n    }\n    return false;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/241", "prompt": "Given a string `expression` of numbers and operators, return _all possible results from computing all the different possible ways to group numbers and operators_. You may return the answer in **any order**.\n\nThe test cases are generated such that the output values fit in a 32-bit integer and the number of different results does not exceed `104`.\n\n**Example 1:**\n\n**Input:** expression =  \"2-1-1 \"\n**Output:** \\[0,2\\]\n**Explanation:**\n((2-1)-1) = 0 \n(2-(1-1)) = 2\n\n**Example 2:**\n\n**Input:** expression =  \"2\\*3-4\\*5 \"\n**Output:** \\[-34,-14,-10,-10,10\\]\n**Explanation:**\n(2\\*(3-(4\\*5))) = -34 \n((2\\*3)-(4\\*5)) = -14 \n((2\\*(3-4))\\*5) = -10 \n(2\\*((3-4)\\*5)) = -10 \n(((2\\*3)-4)\\*5) = 10\n\n**Constraints:**\n\n*   `1 <= expression.length <= 20`\n*   `expression` consists of digits and the operator `'+'`, `'-'`, and `'*'`.\n*   All the integer values in the input expression are in the range `[0, 99]`.", "entry_point": "different_ways_to_add_parentheses", "canonical_solutions": {"python": "def diffWaysToCompute(input: str):\n    result = []\n    for i in range(len(input)):\n        c = input[i]\n        if c == '+' or c == '-' or c == '*':\n            left = diffWaysToCompute(input[:i])\n            right = diffWaysToCompute(input[i + 1:])\n            for l in left:\n                for r in right:\n                    if c == '+': result.append(l + r)\n                    elif c == '-': result.append(l - r)\n                    elif c == '*': result.append(l * r)\n    if not result:\n        result.append(int(input))\n    return result", "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> diffWaysToCompute(String input) {\n    List<Integer> result = new ArrayList<>();\n    for (int i = 0; i < input.length(); i++) {\n        char c = input.charAt(i);\n        if (c == '+' || c == '-' || c == '*') {\n            List<Integer> left = diffWaysToCompute(input.substring(0, i));\n            List<Integer> right = diffWaysToCompute(input.substring(i + 1));\n            for (int l : left) {\n                for (int r : right) {\n                    if (c == '+') result.add(l + r);\n                    else if (c == '-') result.add(l - r);\n                    else if (c == '*') result.add(l * r);\n                }\n            }\n        }\n    }\n    if (result.isEmpty()) result.add(Integer.parseInt(input));\n    return result;\n}", "cpp": "#include<vector>\n#include<string>\n\nusing namespace std;\n\nvector<int> diffWaysToCompute(string input) {\n    vector<int> result;\n    for (int i = 0; i < input.size(); i++) {\n        char c = input[i];\n        if (c == '+' || c == '-' || c == '*') {\n            auto left = diffWaysToCompute(input.substr(0, i));\n            auto right = diffWaysToCompute(input.substr(i + 1));\n            for (int l : left) {\n                for (int r : right) {\n                    if (c == '+') result.push_back(l + r);\n                    else if (c == '-') result.push_back(l - r);\n                    else if (c == '*') result.push_back(l * r);\n                }\n            }\n        }\n    }\n    if (result.empty()) result.push_back(stoi(input));\n    return result;\n}", "javascript": "function diffWaysToCompute(input) {\n    const result = [];\n    for (let i = 0; i < input.length; i++) {\n        const c = input[i];\n        if (c === '+' || c === '-' || c === '*') {\n            const left = diffWaysToCompute(input.slice(0, i));\n            const right = diffWaysToCompute(input.slice(i + 1));\n            for (const l of left) {\n                for (const r of right) {\n                    if (c === '+') result.push(l + r);\n                    else if (c === '-') result.push(l - r);\n                    else if (c === '*') result.push(l * r);\n                }\n            }\n        }\n    }\n    if (result.length === 0) result.push(parseInt(input));\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/242", "prompt": "Given two strings `s` and `t`, return `true` _if_ `t` _is an anagram of_ `s`_, and_ `false` _otherwise_.\n\nAn **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\n**Example 1:**\n\n**Input:** s = \"anagram\", t = \"nagaram\"\n**Output:** true\n\n**Example 2:**\n\n**Input:** s = \"rat\", t = \"car\"\n**Output:** false\n\n**Constraints:**\n\n*   `1 <= s.length, t.length <= 5 * 104`\n*   `s` and `t` consist of lowercase English letters.\n\n**Follow up:** What if the inputs contain Unicode characters? How would you adapt your solution to such a case?", "entry_point": "valid_anagram", "canonical_solutions": {"python": "def is_anagram(s, t):\n    if len(s) != len(t):\n        return False\n\n    counts = {}\n    for c in s:\n        if c in counts:\n            counts[c] += 1\n        else:\n            counts[c] = 1\n\n    for c in t:\n        if c not in counts or counts[c] == 0:\n            return False\n        counts[c] -= 1\n\n    return True", "java": "public boolean isAnagram(String s, String t) {\n    if(s.length() != t.length())\n        return false;\n\n    int[] counts = new int[26];\n    for(char c : s.toCharArray())\n        counts[c - 'a']++;\n\n    for(char c : t.toCharArray()) {\n        if(counts[c - 'a'] == 0)\n            return false;\n        counts[c - 'a']--;\n    }\n\n    return true;\n}", "cpp": "bool isAnagram(std::string s, std::string t) {\n    if(s.size() != t.size())\n        return false;\n    \n    std::unordered_map<char, int> counts;\n    for(char c : s)\n        counts[c]++;\n        \n    for(char c : t) {\n        if(counts[c] == 0)\n            return false;\n        counts[c]--;\n    }\n    \n    return true;\n}", "javascript": "function isAnagram(s, t) {\n    if (s.length !== t.length)\n        return false;\n\n    const counts = {};\n    for (let c of s)\n        counts[c] = (counts[c] || 0) + 1;\n\n    for (let c of t) {\n        if (counts[c] === 0 || !counts[c])\n            return false;\n        counts[c]--;\n    }\n\n    return true;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/243", "prompt": "Given an array of strings `wordsDict` and two different strings that already exist in the array `word1` and `word2`, return _the shortest distance between these two words in the list_.\n\n**Example 1:**\n\n**Input:** wordsDict = \\[ \"practice \",  \"makes \",  \"perfect \",  \"coding \",  \"makes \"\\], word1 =  \"coding \", word2 =  \"practice \"\n**Output:** 3\n\n**Example 2:**\n\n**Input:** wordsDict = \\[ \"practice \",  \"makes \",  \"perfect \",  \"coding \",  \"makes \"\\], word1 =  \"makes \", word2 =  \"coding \"\n**Output:** 1\n\n**Constraints:**\n\n*   `2 <= wordsDict.length <= 3 * 104`\n*   `1 <= wordsDict[i].length <= 10`\n*   `wordsDict[i]` consists of lowercase English letters.\n*   `word1` and `word2` are in `wordsDict`.\n*   `word1 != word2`", "entry_point": "shortest_word_distance", "canonical_solutions": {"python": "def shortestDistance(wordsDict, word1, word2):\n    idx1, idx2, minDistance = -1, -1, float('inf')\n    for i, word in enumerate(wordsDict):\n        if word == word1:\n            idx1 = i\n        if word == word2:\n            idx2 = i\n        if idx1 != -1 and idx2 != -1:\n            minDistance = min(minDistance, abs(idx1 - idx2))\n    return minDistance", "java": "public int shortestDistance(String[] wordsDict, String word1, String word2) {\n    int idx1 = -1, idx2 = -1, minDistance = Integer.MAX_VALUE;\n    for (int i = 0; i < wordsDict.length; i++) {\n        if (word1.equals(wordsDict[i])) idx1 = i;\n        if (word2.equals(wordsDict[i])) idx2 = i;\n        if (idx1 != -1 && idx2 != -1)\n            minDistance = Math.min(minDistance, Math.abs(idx1 - idx2));\n    }\n    return minDistance;\n}", "cpp": "#include <vector>\n#include <string>\n#include <climits>\n\nint shortestDistance(std::vector<std::string> wordsDict, std::string word1, std::string word2) {\n    int idx1 = -1, idx2 = -1, minDistance = INT_MAX;\n    for (int i = 0; i < wordsDict.size(); i++) {\n        if (wordsDict[i] == word1) idx1 = i;\n        if (wordsDict[i] == word2) idx2 = i;\n        if (idx1 != -1 && idx2 != -1)\n            minDistance = std::min(minDistance, std::abs(idx1 - idx2));\n    }\n    return minDistance;\n}", "javascript": "function shortestDistance(wordsDict, word1, word2) {\n    let idx1 = -1, idx2 = -1, minDistance = Number.MAX_VALUE;\n    for (let i = 0; i < wordsDict.length; i++) {\n        if (wordsDict[i] === word1) idx1 = i;\n        if (wordsDict[i] === word2) idx2 = i;\n        if (idx1 !== -1 && idx2 !== -1)\n            minDistance = Math.min(minDistance, Math.abs(idx1 - idx2));\n    }\n    return minDistance;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/244", "prompt": "Design a data structure that will be initialized with a string array, and then it should answer queries of the shortest distance between two different strings from the array.\n\nImplement the `WordDistance` class:\n\n*   `WordDistance(String[] wordsDict)` initializes the object with the strings array `wordsDict`.\n*   `int shortest(String word1, String word2)` returns the shortest distance between `word1` and `word2` in the array `wordsDict`.\n\n**Example 1:**\n\n**Input**\n\\[ \"WordDistance \",  \"shortest \",  \"shortest \"\\]\n\\[\\[\\[ \"practice \",  \"makes \",  \"perfect \",  \"coding \",  \"makes \"\\]\\], \\[ \"coding \",  \"practice \"\\], \\[ \"makes \",  \"coding \"\\]\\]\n**Output**\n\\[null, 3, 1\\]\n\n**Explanation**\nWordDistance wordDistance = new WordDistance(\\[ \"practice \",  \"makes \",  \"perfect \",  \"coding \",  \"makes \"\\]);\nwordDistance.shortest( \"coding \",  \"practice \"); // return 3\nwordDistance.shortest( \"makes \",  \"coding \");    // return 1\n\n**Constraints:**\n\n*   `1 <= wordsDict.length <= 3 * 104`\n*   `1 <= wordsDict[i].length <= 10`\n*   `wordsDict[i]` consists of lowercase English letters.\n*   `word1` and `word2` are in `wordsDict`.\n*   `word1 != word2`\n*   At most `5000` calls will be made to `shortest`.", "entry_point": "shortest_word_distance_ii", "canonical_solutions": {"python": "class WordDistance:\n\n    def __init__(self, wordsDict):\n        self.word_indexes = {}\n        for i, word in enumerate(wordsDict):\n            if word not in self.word_indexes:\n                self.word_indexes[word] = []\n            self.word_indexes[word].append(i)\n\n    def shortest(self, word1, word2):\n        indexes1 = self.word_indexes[word1]\n        indexes2 = self.word_indexes[word2]\n        i, j, min_dist = 0, 0, float('inf')\n\n        while i < len(indexes1) and j < len(indexes2):\n            min_dist = min(min_dist, abs(indexes1[i] - indexes2[j]))\n            if indexes1[i] < indexes2[j]:\n                i += 1\n            else:\n                j += 1\n\n        return min_dist", "java": "import java.util.HashMap;\nimport java.util.ArrayList;\n\nclass WordDistance {\n    HashMap<String, ArrayList<Integer>> wordIndexes;\n\n    public WordDistance(String[] wordsDict) {\n        wordIndexes = new HashMap<>();\n        for (int i = 0; i < wordsDict.length; ++i) {\n            if (!wordIndexes.containsKey(wordsDict[i])) {\n                wordIndexes.put(wordsDict[i], new ArrayList<>());\n            }\n            wordIndexes.get(wordsDict[i]).add(i);\n        }\n    }\n\n    public int shortest(String word1, String word2) {\n        ArrayList<Integer> indexes1 = wordIndexes.get(word1);\n        ArrayList<Integer> indexes2 = wordIndexes.get(word2);\n        int i = 0, j = 0, min_dist = Integer.MAX_VALUE;\n\n        while (i < indexes1.size() && j < indexes2.size()) {\n            min_dist = Math.min(min_dist, Math.abs(indexes1.get(i) - indexes2.get(j)));\n            if (indexes1.get(i) < indexes2.get(j)) {\n                ++i;\n            } else {\n                ++j;\n            }\n        }\n        return min_dist;\n    }\n}", "cpp": "#include <unordered_map>\n#include <vector>\n#include <string>\n\nclass WordDistance {\npublic:\n    WordDistance(std::vector<std::string>& wordsDict) {\n        for(int i = 0; i < wordsDict.size(); ++i) {\n            wordIndexes[wordsDict[i]].push_back(i);\n        }\n    }\n\n    int shortest(std::string word1, std::string word2) {\n        std::vector<int> indexes1 = wordIndexes[word1];\n        std::vector<int> indexes2 = wordIndexes[word2];\n        int i = 0, j = 0, min_dist = INT_MAX;\n\n        while(i < indexes1.size() && j < indexes2.size()) {\n            min_dist = std::min(min_dist, abs(indexes1[i] - indexes2[j]));\n            if(indexes1[i] < indexes2[j]) {\n                ++i;\n            }\n            else {\n                ++j;\n            }\n        }\n        return min_dist;\n    }\n\nprivate:\n    std::unordered_map<std::string, std::vector<int>> wordIndexes;\n};", "javascript": "class WordDistance {\n    constructor(wordsDict) {\n        this.wordIndexes = new Map();\n        for (let i = 0; i < wordsDict.length; ++i) {\n            if (!this.wordIndexes.has(wordsDict[i])) {\n                this.wordIndexes.set(wordsDict[i], []);\n            }\n            this.wordIndexes.get(wordsDict[i]).push(i);\n        }\n    }\n\n    shortest(word1, word2) {\n        const indexes1 = this.wordIndexes.get(word1);\n        const indexes2 = this.wordIndexes.get(word2);\n        let i = 0, j = 0, min_dist = Number.MAX_VALUE;\n\n        while (i < indexes1.length && j < indexes2.length) {\n            min_dist = Math.min(min_dist, Math.abs(indexes1[i] - indexes2[j]));\n            if (indexes1[i] < indexes2[j]) {\n                ++i;\n            } else {\n                ++j;\n            }\n        }\n        return min_dist;\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/245", "prompt": "Given an array of strings `wordsDict` and two strings that already exist in the array `word1` and `word2`, return _the shortest distance between the occurrence of these two words in the list_.\n\n**Note** that `word1` and `word2` may be the same. It is guaranteed that they represent **two individual words** in the list.\n\n**Example 1:**\n\n**Input:** wordsDict = \\[\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"\\], word1 = \"makes\", word2 = \"coding\"\n**Output:** 1\n\n**Example 2:**\n\n**Input:** wordsDict = \\[\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"\\], word1 = \"makes\", word2 = \"makes\"\n**Output:** 3\n\n**Constraints:**\n\n*   `1 <= wordsDict.length <= 105`\n*   `1 <= wordsDict[i].length <= 10`\n*   `wordsDict[i]` consists of lowercase English letters.\n*   `word1` and `word2` are in `wordsDict`.", "entry_point": "shortest_word_distance_iii", "canonical_solutions": {"python": "def shortest_distance(words_dict, word1, word2):\n    index1, index2, min_distance = -1, -1, float('inf')\n    for i, word in enumerate(words_dict):\n        if word == word1:\n            index1 = i\n        if word == word2:\n            index2 = i\n        if index1 != -1 and(index2 != -1):\n            min_distance = min(min_distance, abs(index1 - index2))\n    return min_distance", "java": "public int shortestDistance(String[] wordsDict, String word1, String word2) {\n    int index1 = -1, index2 = -1, minDistance = Integer.MAX_VALUE;\n    for (int i = 0; i < wordsDict.length; ++i) {\n        if (wordsDict[i].equals(word1)) { index1 = i; }\n        if (wordsDict[i].equals(word2)) { index2 = i; }\n        if (index1 != -1 && index2 != -1) {\n            minDistance = Math.min(minDistance, Math.abs(index1 - index2));\n        }\n    }\n    return minDistance;\n}", "cpp": "#include <vector>\n#include <string>\n#include <limits>\n\nint shortestDistance(std::vector<std::string>& wordsDict, std::string word1, std::string word2) {\n    int index1 = -1, index2 = -1, minDistance = std::numeric_limits<int>::max();\n    for (int i = 0; i < wordsDict.size(); ++i) {\n        if (wordsDict[i] == word1) { index1 = i; }\n        if (wordsDict[i] == word2) { index2 = i; }\n        if (index1 != -1 && index2 != -1) {\n            minDistance = std::min(minDistance, std::abs(index1 - index2));\n        }\n    }\n    return minDistance;\n}", "javascript": "function shortestDistance(wordsDict, word1, word2) {\n    let index1 = -1, index2 = -1, minDistance = Infinity;\n    for (let i = 0; i < wordsDict.length; ++i) {\n        if (wordsDict[i] === word1) { index1 = i; }\n        if (wordsDict[i] === word2) { index2 = i; }\n        if (index1 !== -1 && index2 !== -1) {\n            minDistance = Math.min(minDistance, Math.abs(index1 - index2));\n        }\n    }\n    return minDistance;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/246", "prompt": "Given a string `num` which represents an integer, return `true` _if_ `num` _is a **strobogrammatic number**_.\n\nA **strobogrammatic number** is a number that looks the same when rotated `180` degrees (looked at upside down).\n\n**Example 1:**\n\n**Input:** num =  \"69 \"\n**Output:** true\n\n**Example 2:**\n\n**Input:** num =  \"88 \"\n**Output:** true\n\n**Example 3:**\n\n**Input:** num =  \"962 \"\n**Output:** false\n\n**Constraints:**\n\n*   `1 <= num.length <= 50`\n*   `num` consists of only digits.\n*   `num` does not contain any leading zeros except for zero itself.", "entry_point": "strobogrammatic_number", "canonical_solutions": {"python": "def isStrobogrammatic(num: str) -> bool:\n    lookup = {'0': '0', '1': '1', '6': '9', '8': '8', '9': '6'}\n    left, right = 0, len(num) - 1\n    while left <= right:\n        if num[left] not in lookup or lookup[num[left]] != num[right]:\n            return False\n        left += 1\n        right -= 1\n    return True", "java": "public boolean isStrobogrammatic(String num) {\n    HashMap<Character, Character> lookup = new HashMap<Character, Character>() {{\n        put('0', '0');\n        put('1', '1');\n        put('6', '9');\n        put('8', '8');\n        put('9', '6');\n    }};\n    int left = 0, right = num.length() - 1;\n    while(left <= right) {\n        if(!lookup.containsKey(num.charAt(left)) || lookup.get(num.charAt(left)) != num.charAt(right)) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}", "cpp": "bool isStrobogrammatic(string num) {\n    unordered_map<char, char> lookup {{'0', '0'}, {'1', '1'}, {'6', '9'}, {'8', '8'}, {'9', '6'}};\n    int left = 0, right = num.size() - 1;\n    while(left <= right) {\n        if(lookup[num[left]] != num[right]) return false;\n        left++;\n        right--;\n    }\n    return true;\n}", "javascript": "function isStrobogrammatic(num) {\n    const lookup = {'0': '0', '1': '1', '6': '9', '8': '8', '9': '6'};\n    let left = 0, right = num.length - 1;\n    while(left <= right) {\n        if(!(num[left] in lookup) || lookup[num[left]] !== num[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/247", "prompt": "Given an integer `n`, return all the **strobogrammatic numbers** that are of length `n`. You may return the answer in **any order**.\n\nA **strobogrammatic number** is a number that looks the same when rotated `180` degrees (looked at upside down).\n\n**Example 1:**\n\n**Input:** n = 2\n**Output:** \\[\"11\",\"69\",\"88\",\"96\"\\]\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** \\[\"0\",\"1\",\"8\"\\]\n\n**Constraints:**\n\n*   `1 <= n <= 14`", "entry_point": "strobogrammatic_number_ii", "canonical_solutions": {"python": "def findStrobogrammatic(n):\n    def helper(n, m):\n        if n == 0:\n            return [\"\"]\n        if n == 1:\n            return [\"0\", \"1\", \"8\"]\n\n        list = helper(n - 2, m)\n        res = []\n\n        for s in list:\n            if n != m:\n                res.append(\"0\" + s + \"0\")\n\n            res.append(\"1\" + s + \"1\")\n            res.append(\"6\" + s + \"9\")\n            res.append(\"8\" + s + \"8\")\n            res.append(\"9\" + s + \"6\")\n\n        return res\n\n    return helper(n, n)", "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic List<String> findStrobogrammatic(int n) {\n    return helper(n, n);\n}\n\nprivate List<String> helper(int n, int m) {\n    if (n == 0) return new ArrayList<>(Arrays.asList(\"\"));\n    if (n == 1) return new ArrayList<>(Arrays.asList(\"0\", \"1\", \"8\"));\n    \n    List<String> list = helper(n - 2, m);\n    List<String> res = new ArrayList<>();\n\n    for (int i = 0; i < list.size(); i++) {\n        String s = list.get(i);\n        \n        if (n != m) res.add(\"0\" + s + \"0\");\n\n        res.add(\"1\" + s + \"1\");\n        res.add(\"6\" + s + \"9\");\n        res.add(\"8\" + s + \"8\");\n        res.add(\"9\" + s + \"6\");\n    }\n\n    return res;\n}", "cpp": "#include <vector>\n#include <string>\n\nstd::vector<std::string> findStrobogrammatic(int n) {\n    return helper(n, n);\n}\n\nstd::vector<std::string> helper(int n, int m) {\n    if (n == 0) return {\"\"};\n    if (n == 1) return {\"0\", \"1\", \"8\"};\n    \n    std::vector<std::string> list = helper(n - 2, m);\n    std::vector<std::string> res;\n\n    for (int i = 0; i < list.size(); i++) {\n        std::string s = list[i];\n        \n        if (n != m) res.push_back(\"0\" + s + \"0\");\n\n        res.push_back(\"1\" + s + \"1\");\n        res.push_back(\"6\" + s + \"9\");\n        res.push_back(\"8\" + s + \"8\");\n        res.push_back(\"9\" + s + \"6\");\n    }\n\n    return res;\n}", "javascript": "function findStrobogrammatic(n) {\n    return helper(n, n);\n}\n\nfunction helper(n, m) {\n    if (n === 0) return [\"\"];\n    if (n === 1) return [\"0\", \"1\", \"8\"];\n    \n    const list = helper(n - 2, m);\n    const res = [];\n\n    for (let i = 0; i < list.length; i++) {\n        const s = list[i];\n\n        if (n !== m) res.push(\"0\" + s + \"0\");\n\n        res.push(\"1\" + s + \"1\");\n        res.push(\"6\" + s + \"9\");\n        res.push(\"8\" + s + \"8\");\n        res.push(\"9\" + s + \"6\");\n    }\n\n    return res;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/248", "prompt": "Given two strings low and high that represent two integers `low` and `high` where `low <= high`, return _the number of **strobogrammatic numbers** in the range_ `[low, high]`.\n\nA **strobogrammatic number** is a number that looks the same when rotated `180` degrees (looked at upside down).\n\n**Example 1:**\n\n**Input:** low = \"50\", high = \"100\"\n**Output:** 3\n\n**Example 2:**\n\n**Input:** low = \"0\", high = \"0\"\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= low.length, high.length <= 15`\n*   `low` and `high` consist of only digits.\n*   `low <= high`\n*   `low` and `high` do not contain any leading zeros except for zero itself.", "entry_point": "strobogrammatic_number_iii", "canonical_solutions": {"python": "def strobogrammaticInRange(low, high):\n    count = 0\n    for len in range(len(low), len(high)+1):\n        count += 1 if low <= helper(len, len) <= high else 0\n    return count\n\ndef helper(m, n):\n    if m == 0:\n        return \"\"\n    if m == 1:\n        return \"0 1 8\"\n    if n == 0:\n        return \"11 69 88 96\"\n    res = \"\"\n    for a in helper(m-2, n).split():\n        if m != n:\n            res += a + \"0\" + a + \" \"\n        res += a + \"1\" + a + \" \"\n        res += a + \"6\" + a + \" \"\n        res += a + \"8\" + a + \" \"\n        res += a + \"9\" + a + \" \"\n    return res", "java": "public int strobogrammaticInRange(String low, String high) {\n    int count = 0;\n    for(int len = low.length(); len <= high.length(); ++len)\n        count += withinRange(helper(len, len), low, high) ? 1 : 0;\n    return count;\n}\n\nprivate String helper(int m, int n) {\n    if(m == 0) return \"\";\n    if(m == 1) return \"0 1 8\";\n    if(n == 0) return \"11 69 88 96\";\n    String res = \"\";\n    for(String a : helper(m - 2, n).split(\" \")) {\n        if(m != n) res += a + \"0\" + a + \" \";\n        res += a + \"1\" + a + \" \";\n        res += a + \"6\" + a + \" \";\n        res += a + \"8\" + a + \" \";\n        res += a + \"9\" + a + \" \";\n    }\n    return res;\n}\n\nprivate boolean withinRange(String num, String low, String high) {\n    if(num.length() > low.length()) return num.compareTo(high) <= 0;\n    if(num.length() < low.length()) return num.compareTo(low) >= 0;\n    return num.compareTo(low) >= 0 && num.compareTo(high) <= 0;\n}", "cpp": "int strobogrammaticInRange(string low, string high) {\n    int count = 0;\n    for(int len = low.size(); len <= high.size(); ++len)\n        count += helper(len, len) <= high ? helper(len, len) >= low ? 1 : 0 : 0;\n    return count;\n}\n\nstring helper(int m, int n) {\n    if(m == 0) return \"\";\n    if(m == 1) return \"0 1 8\";\n    if(n == 0) return \"11 69 88 96\";\n    string res = \"\";\n    for(auto a : helper(m - 2, n)) {\n        if(m != n) res += a + \"0\" + a;\n        res += a + \"1\" + a;\n        res += a + \"6\" + a;\n        res += a + \"8\" + a;\n        res += a + \"9\" + a;\n    }\n    return res;\n}", "javascript": "function strobogrammaticInRange(low, high) {\n    let count = 0;\n    for (let len = low.length; len <= high.length; ++len) {\n        const num = helper(len, len);\n        count += (num >= low && num <= high) ? 1 : 0;\n    }\n    return count;\n}\n\nfunction helper(m, n) {\n    if (m === 0) return \"\";\n    if (m === 1) return \"0 1 8\";\n    if (n === 0) return \"11 69 88 96\";\n    let res = \"\";\n    for (const a of helper(m - 2, n).split(\" \")) {\n        if (m !== n) res += a + \"0\" + a + \" \";\n        res += a + \"1\" + a + \" \";\n        res += a + \"6\" + a + \" \";\n        res += a + \"8\" + a + \" \";\n        res += a + \"9\" + a + \" \";\n    }\n    return res;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/249", "prompt": "We can shift a string by shifting each of its letters to its successive letter.\n\n*   For example, `\"abc \"` can be shifted to be `\"bcd \"`.\n\nWe can keep shifting the string to form a sequence.\n\n*   For example, we can keep shifting `\"abc \"` to form the sequence: `\"abc \" -> \"bcd \" -> ... -> \"xyz \"`.\n\nGiven an array of strings `strings`, group all `strings[i]` that belong to the same shifting sequence. You may return the answer in **any order**.\n\n**Example 1:**\n\n**Input:** strings = \\[\"abc\",\"bcd\",\"acef\",\"xyz\",\"az\",\"ba\",\"a\",\"z\"\\]\n**Output:** \\[\\[\"acef\"\\],\\[\"a\",\"z\"\\],\\[\"abc\",\"bcd\",\"xyz\"\\],\\[\"az\",\"ba\"\\]\\]\n\n**Example 2:**\n\n**Input:** strings = \\[\"a\"\\]\n**Output:** \\[\\[\"a\"\\]\\]\n\n**Constraints:**\n\n*   `1 <= strings.length <= 200`\n*   `1 <= strings[i].length <= 50`\n*   `strings[i]` consists of lowercase English letters.", "entry_point": "group_shifted_strings", "canonical_solutions": {"python": "from collections import defaultdict\n\ndef groupStrings(strings):\n    groups = defaultdict(list)\n\n    for s in strings:\n        key = tuple((ord(c) - ord(s[0])) % 26 for c in s)\n        groups[key].append(s)\n\n    return list(groups.values())", "java": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic List<List<String>> groupStrings(String[] strings) {\n    Map<String, List<String>> map = new HashMap<>();\n\n    for (String s : strings) {\n        StringBuilder key = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            key.append((c - s.charAt(0) + 26) % 26).append(\",\");\n        }\n        String keyStr = key.toString();\n        map.putIfAbsent(keyStr, new ArrayList<>());\n        map.get(keyStr).add(s);\n    }\n\n    return new ArrayList<>(map.values());\n}", "cpp": "#include <vector>\n#include <string>\n#include <unordered_map>\n\nstd::vector<std::vector<std::string>> groupStrings(std::vector<std::string>& strings) {\n    std::unordered_map<std::string, std::vector<std::string>> map;\n    \n    for (const auto& s : strings) {\n        std::string key;\n        for (char c : s) {\n            key += std::to_string((c - s[0] + 26) % 26) + \",\";\n        }\n        map[key].push_back(s);\n    }\n    \n    std::vector<std::vector<std::string>> result;\n    for (auto& kv : map) {\n        result.push_back(kv.second);\n    }\n    \n    return result;\n}", "javascript": "function groupStrings(strings) {\n    const map = new Map();\n\n    for (const s of strings) {\n        let key = '';\n        for (const c of s) {\n            key += `${(c.charCodeAt(0) - s.charCodeAt(0) + 26) % 26},`;\n        }\n        if (!map.has(key)) {\n            map.set(key, []);\n        }\n        map.get(key).push(s);\n    }\n\n    return Array.from(map.values());\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/250", "prompt": "Given the `root` of a binary tree, return _the number of **uni-value**_ _subtrees_.\n\nA **uni-value subtree** means all nodes of the subtree have the same value.\n\n**Example 1:**\n\n**Input:** root = \\[5,1,5,5,5,null,5\\]\n**Output:** 4\n\n**Example 2:**\n\n**Input:** root = \\[\\]\n**Output:** 0\n\n**Example 3:**\n\n**Input:** root = \\[5,5,5,5,5,null,5\\]\n**Output:** 6\n\n**Constraints:**\n\n*   The number of the node in the tree will be in the range `[0, 1000]`.\n*   `-1000 <= Node.val <= 1000`", "entry_point": "count_univalue_subtrees", "canonical_solutions": {"python": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def countUnivalSubtrees(self, root: TreeNode) -> int:\n        count = 0\n\n        def helper(node):\n            nonlocal count\n            if node is None:\n                return True\n\n            left = helper(node.left)\n            right = helper(node.right)\n\n            if left and right:\n                if node.left and node.val != node.left.val:\n                    return False\n                if node.right and node.val != node.right.val:\n                    return False\n                count += 1\n                return True\n\n            return False\n\n        helper(root)\n        return count", "java": "public class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nclass Solution {\n    public int countUnivalSubtrees(TreeNode root) {\n        return helper(root, new int[1]);\n    }\n    \n    private boolean helper(TreeNode node, int[] count) {\n        if (node == null) return true;\n        \n        boolean left = helper(node.left, count);\n        boolean right = helper(node.right, count);\n        \n        if (left && right) {\n            if (node.left != null && node.val != node.left.val) return false;\n            if (node.right != null && node.val != node.right.val) return false;\n            count[0]++;\n            return true;\n        }\n        \n        return false;\n    }\n}", "cpp": "struct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nclass Solution {\npublic:\n    int countUnivalSubtrees(TreeNode* root) {\n        int count = 0;\n        helper(root, count);\n        return count;\n    }\n    \n    bool helper(TreeNode* node, int& count) {\n        if (!node) return true;\n        \n        bool left = helper(node->left, count);\n        bool right = helper(node->right, count);\n        \n        if (left && right) {\n            if (node->left && node->val != node->left->val) return false;\n            if (node->right && node->val != node->right->val) return false;\n            count++;\n            return true;\n        }\n        \n        return false;\n    }\n};", "javascript": "class TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nconst countUnivalSubtrees = (root) => {\n    let count = 0;\n\n    const helper = (node) => {\n        if (node === null) return true;\n\n        const left = helper(node.left);\n        const right = helper(node.right);\n\n        if (left && right) {\n            if (node.left && node.val !== node.left.val) return false;\n            if (node.right && node.val !== node.right.val) return false;\n\n            count++;\n            return true;\n        }\n\n        return false;\n    };\n\n    helper(root);\n    return count;\n};"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/251", "prompt": "Design an iterator to flatten a 2D vector. It should support the `next` and `hasNext` operations.\n\nImplement the `Vector2D` class:\n\n*   `Vector2D(int[][] vec)` initializes the object with the 2D vector `vec`.\n*   `next()` returns the next element from the 2D vector and moves the pointer one step forward. You may assume that all the calls to `next` are valid.\n*   `hasNext()` returns `true` if there are still some elements in the vector, and `false` otherwise.\n\n**Example 1:**\n\n**Input**\n\\[ \"Vector2D \",  \"next \",  \"next \",  \"next \",  \"hasNext \",  \"hasNext \",  \"next \",  \"hasNext \"\\]\n\\[\\[\\[\\[1, 2\\], \\[3\\], \\[4\\]\\]\\], \\[\\], \\[\\], \\[\\], \\[\\], \\[\\], \\[\\], \\[\\]\\]\n**Output**\n\\[null, 1, 2, 3, true, true, 4, false\\]\n\n**Explanation**\nVector2D vector2D = new Vector2D(\\[\\[1, 2\\], \\[3\\], \\[4\\]\\]);\nvector2D.next();    // return 1\nvector2D.next();    // return 2\nvector2D.next();    // return 3\nvector2D.hasNext(); // return True\nvector2D.hasNext(); // return True\nvector2D.next();    // return 4\nvector2D.hasNext(); // return False\n\n**Constraints:**\n\n*   `0 <= vec.length <= 200`\n*   `0 <= vec[i].length <= 500`\n*   `-500 <= vec[i][j] <= 500`\n*   At most `105` calls will be made to `next` and `hasNext`.\n\n**Follow up:** As an added challenge, try to code it using only [iterators in C++](http://www.cplusplus.com/reference/iterator/iterator/) or [iterators in Java](http://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html).", "entry_point": "flatten_2d_vector", "canonical_solutions": {"python": "class Vector2D:\n    def __init__(self, vec):\n        self.vec = vec\n        self.row = 0\n        self.col = 0\n\n    def next(self):\n        val = self.vec[self.row][self.col]\n        self.col += 1\n        return val\n\n    def hasNext(self):\n        while self.row < len(self.vec):\n            if self.col < len(self.vec[self.row]):\n                return True\n            self.row += 1\n            self.col = 0\n        return False", "java": "import java.util.Iterator;\nimport java.util.List;\n\npublic class Vector2D implements Iterator<Integer> {\n    private Iterator<List<Integer>> i;\n    private Iterator<Integer> j;\n\n    public Vector2D(List<List<Integer>> vec) {\n        i = vec.iterator();\n        if (i.hasNext()) {\n            j = i.next().iterator();\n        }\n    }\n\n    @Override\n    public Integer next() {\n        if (!hasNext()) {\n            return null;\n        }\n        return j.next();\n    }\n\n    @Override\n    public boolean hasNext() {\n        if (j == null) {\n            return false;\n        }\n\n        while (!j.hasNext() && i.hasNext()) {\n            j = i.next().iterator();\n        }\n\n        return j.hasNext();\n    }\n}", "cpp": "class Vector2D {\npublic:\n    vector<vector<int>>::iterator i, i_end;\n    int j = 0;\n\n    Vector2D(vector<vector<int>>& vec) {\n        i = vec.begin();\n        i_end = vec.end();\n    }\n    \n    int next() {\n        hasNext();\n        return (*i)[j++];\n    }\n    \n    bool hasNext() {\n        while (i != i_end && j == (*i).size()) {\n            ++i;\n            j = 0;\n        }\n        return i != i_end;\n    }\n};", "javascript": "class Vector2D {\n    constructor(vec) {\n        this.vec = vec;\n        this.row = 0;\n        this.col = 0;\n    }\n\n    next() {\n        const val = this.vec[this.row][this.col];\n        this.col++;\n        return val;\n    }\n\n    hasNext() {\n        while (this.row < this.vec.length) {\n            if (this.col < this.vec[this.row].length) {\n                return true;\n            }\n            this.row++;\n            this.col = 0;\n        }\n        return false;\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/252", "prompt": "Given an array of meeting time `intervals` where `intervals[i] = [starti, endi]`, determine if a person could attend all meetings.\n\n**Example 1:**\n\n**Input:** intervals = \\[\\[0,30\\],\\[5,10\\],\\[15,20\\]\\]\n**Output:** false\n\n**Example 2:**\n\n**Input:** intervals = \\[\\[7,10\\],\\[2,4\\]\\]\n**Output:** true\n\n**Constraints:**\n\n*   `0 <= intervals.length <= 104`\n*   `intervals[i].length == 2`\n*   `0 <= starti < endi <= 106`", "entry_point": "meeting_rooms", "canonical_solutions": {"python": "def can_attend_meetings(intervals):\n    intervals.sort()\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] < intervals[i - 1][1]:\n            return False\n\n    return True", "java": "import java.util.Arrays;\n\npublic boolean canAttendMeetings(int[][] intervals) {\n    Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\n    \n    for (int i = 1; i < intervals.length; ++i) {\n        if (intervals[i][0] < intervals[i - 1][1])\n            return false;\n    }\n    \n    return true;\n}", "cpp": "#include <vector>\n#include <algorithm>\n\nbool canAttendMeetings(std::vector<std::vector<int>>& intervals) {\n    std::sort(intervals.begin(), intervals.end());\n    \n    for (int i = 1; i < intervals.size(); ++i) {\n        if (intervals[i][0] < intervals[i - 1][1])\n            return false;\n    }\n    \n    return true;\n}", "javascript": "function canAttendMeetings(intervals) {\n    intervals.sort((a, b) => a[0] - b[0]);\n    \n    for (let i = 1; i < intervals.length; ++i) {\n        if (intervals[i][0] < intervals[i - 1][1])\n            return false;\n    }\n    \n    return true;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/253", "prompt": "Given an array of meeting time intervals `intervals` where `intervals[i] = [starti, endi]`, return _the minimum number of conference rooms required_.\n\n**Example 1:**\n\n**Input:** intervals = \\[\\[0,30\\],\\[5,10\\],\\[15,20\\]\\]\n**Output:** 2\n\n**Example 2:**\n\n**Input:** intervals = \\[\\[7,10\\],\\[2,4\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= intervals.length <= 104`\n*   `0 <= starti < endi <= 106`", "entry_point": "meeting_rooms_ii", "canonical_solutions": {"python": "import heapq\n\ndef minMeetingRooms(intervals):\n    if not intervals:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n\n    min_heap = [intervals[0][1]]\n    for start, end in intervals[1:]:\n        if start >= min_heap[0]:\n            heapq.heappop(min_heap)\n        heapq.heappush(min_heap, end)\n\n    return len(min_heap)", "java": "import java.util.Arrays;\nimport java.util.PriorityQueue;\n\npublic int minMeetingRooms(int[][] intervals) {\n    if (intervals == null || intervals.length == 0) return 0;\n    \n    Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>();\n    \n    minHeap.add(intervals[0][1]);\n    for (int i = 1; i < intervals.length; i++) {\n        if (intervals[i][0] >= minHeap.peek()) {\n            minHeap.poll();\n        }\n        minHeap.add(intervals[i][1]);\n    }\n    \n    return minHeap.size();\n}", "cpp": "#include <vector>\n#include <queue>\n#include <algorithm>\n\nint minMeetingRooms(std::vector<std::vector<int>>& intervals) {\n    if (intervals.empty()) return 0;\n\n    std::sort(intervals.begin(), intervals.end(),\n              [](const std::vector<int>& a, const std::vector<int>& b) { return a[0] < b[0]; });\n\n    std::priority_queue<int, std::vector<int>, std::greater<int>> min_heap;\n    min_heap.push(intervals[0][1]);\n\n    for (int i = 1; i < intervals.size(); i++) {\n        if (intervals[i][0] >= min_heap.top()) {\n            min_heap.pop();\n        }\n        min_heap.push(intervals[i][1]);\n    }\n\n    return min_heap.size();\n}", "javascript": "function minMeetingRooms(intervals) {\n    if (intervals.length === 0) return 0;\n\n    intervals.sort((a, b) => a[0] - b[0]);\n    const minHeap = [intervals[0][1]];\n\n    for (let i = 1; i < intervals.length; i++) {\n        if (intervals[i][0] >= minHeap[0]) {\n            minHeap.shift();\n        }\n        minHeap.push(intervals[i][1]);\n        minHeap.sort((a, b) => a - b);\n    }\n\n    return minHeap.length;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/254", "prompt": "Numbers can be regarded as the product of their factors.\n\n*   For example, `8 = 2 x 2 x 2 = 2 x 4`.\n\nGiven an integer `n`, return _all possible combinations of its factors_. You may return the answer in **any order**.\n\n**Note** that the factors should be in the range `[2, n - 1]`.\n\n**Example 1:**\n\n**Input:** n = 1\n**Output:** \\[\\]\n\n**Example 2:**\n\n**Input:** n = 12\n**Output:** \\[\\[2,6\\],\\[3,4\\],\\[2,2,3\\]\\]\n\n**Example 3:**\n\n**Input:** n = 37\n**Output:** \\[\\]\n\n**Constraints:**\n\n*   `1 <= n <= 107`", "entry_point": "factor_combinations", "canonical_solutions": {"python": "def getFactors(n):\n    def helper(n, start, path, result):\n        if n == 1:\n            if len(path) > 1:\n                result.append(path[:])\n            return\n\n        for i in range(start, n + 1):\n            if n % i == 0:\n                path.append(i)\n                helper(n // i, i, path, result)\n                path.pop()\n\n    result = []\n    helper(n, 2, [], result)\n    return result", "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> getFactors(int n) {\n    List<List<Integer>> result = new ArrayList<>();\n    helper(n, 2, new ArrayList<Integer>(), result);\n    return result;\n}\n\nprivate void helper(int n, int start, List<Integer> path, List<List<Integer>> result) {\n    if (n == 1) {\n        if (path.size() > 1) {\n            result.add(new ArrayList<>(path));\n        }\n        return;\n    }\n\n    for (int i = start; i <= n; i++) {\n        if (n % i == 0) {\n            path.add(i);\n            helper(n / i, i, path, result);\n            path.remove(path.size() - 1);\n        }\n    }\n}", "cpp": "#include <vector>\n\nvoid helper(int n, int start, std::vector<int>& path, std::vector<std::vector<int>>& result) {\n    if (n == 1) {\n        if (path.size() > 1) {\n            result.push_back(path);\n        }\n        return;\n    }\n\n    for (int i = start; i <= n; ++i) {\n        if (n % i == 0) {\n            path.push_back(i);\n            helper(n / i, i, path, result);\n            path.pop_back();\n        }\n    }\n}\n\nstd::vector<std::vector<int>> getFactors(int n) {\n    std::vector<std::vector<int>> result;\n    std::vector<int> path;\n    helper(n, 2, path, result);\n    return result;\n}", "javascript": "function getFactors(n) {\n    const result = [];\n    const helper = (n, start, path) => {\n        if (n === 1) {\n            if (path.length > 1) {\n                result.push([...path]);\n            }\n            return;\n        }\n\n        for (let i = start; i <= n; i++) {\n            if (n % i === 0) {\n                path.push(i);\n                helper(n / i, i, path);\n                path.pop();\n            }\n        }\n    };\n\n    helper(n, 2, []);\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/255", "prompt": "Given an array of **unique** integers `preorder`, return `true` _if it is the correct preorder traversal sequence of a binary search tree_.\n\n**Example 1:**\n\n**Input:** preorder = \\[5,2,1,3,6\\]\n**Output:** true\n\n**Example 2:**\n\n**Input:** preorder = \\[5,2,6,1,3\\]\n**Output:** false\n\n**Constraints:**\n\n*   `1 <= preorder.length <= 104`\n*   `1 <= preorder[i] <= 104`\n*   All the elements of `preorder` are **unique**.\n\n**Follow up:** Could you do it using only constant space complexity?", "entry_point": "verify_preorder_sequence_in_binary_search_tree", "canonical_solutions": {"python": "def isValidPreorder(preorder: List[int]) -> bool:\n    stack = []\n    lower_bound = float('-inf')\n    for num in preorder:\n        if num < lower_bound:\n            return False\n        while stack and num > stack[-1]:\n            lower_bound = stack.pop()\n        stack.append(num)\n    return True", "java": "public boolean isValidPreorder(int[] preorder) {\n    Stack<Integer> stack = new Stack<>();\n    int lowerBound = Integer.MIN_VALUE;\n    for (int num : preorder) {\n        if (num < lowerBound) return false;\n        while (!stack.isEmpty() && num > stack.peek()) {\n            lowerBound = stack.pop();\n        }\n        stack.push(num);\n    }\n    return true;\n}", "cpp": "bool isValidPreorder(vector<int>& preorder) {\n    stack<int> stk;\n    int lower_bound = INT_MIN;\n    for (int num : preorder) {\n        if (num < lower_bound) return false;\n        while (!stk.empty() && num > stk.top()) {\n            lower_bound = stk.top();\n            stk.pop();\n        }\n        stk.push(num);\n    }\n    return true;\n}", "javascript": "var isValidPreorder = function(preorder) {\n    let stack = [];\n    let lowerBound = Number.MIN_SAFE_INTEGER;\n    for (let num of preorder) {\n        if (num < lowerBound) return false;\n        while (stack.length > 0 && num > stack[stack.length - 1]) {\n            lowerBound = stack.pop();\n        }\n        stack.push(num);\n    }\n    return true;\n};"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/256", "prompt": "There is a row of `n` houses, where each house can be painted one of three colors: red, blue, or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.\n\nThe cost of painting each house with a certain color is represented by an `n x 3` cost matrix `costs`.\n\n*   For example, `costs[0][0]` is the cost of painting house `0` with the color red; `costs[1][2]` is the cost of painting house 1 with color green, and so on...\n\nReturn _the minimum cost to paint all houses_.\n\n**Example 1:**\n\n**Input:** costs = \\[\\[17,2,17\\],\\[16,16,5\\],\\[14,3,19\\]\\]\n**Output:** 10\n**Explanation:** Paint house 0 into blue, paint house 1 into green, paint house 2 into blue.\nMinimum cost: 2 + 5 + 3 = 10.\n\n**Example 2:**\n\n**Input:** costs = \\[\\[7,6,2\\]\\]\n**Output:** 2\n\n**Constraints:**\n\n*   `costs.length == n`\n*   `costs[i].length == 3`\n*   `1 <= n <= 100`\n*   `1 <= costs[i][j] <= 20`", "entry_point": "paint_house", "canonical_solutions": {"python": "def minCost(costs: List[List[int]]) -> int:\n    if not costs:\n        return 0\n    for i in range(1, len(costs)):\n        costs[i][0] += min(costs[i - 1][1], costs[i - 1][2])\n        costs[i][1] += min(costs[i - 1][0], costs[i - 1][2])\n        costs[i][2] += min(costs[i - 1][0], costs[i - 1][1])\n    return min(costs[-1][0], costs[-1][1], costs[-1][2])", "java": "public int minCost(int[][] costs) {\n    if (costs.length == 0) return 0;\n    for (int i = 1; i < costs.length; i++) {\n        costs[i][0] += Math.min(costs[i - 1][1], costs[i - 1][2]);\n        costs[i][1] += Math.min(costs[i - 1][0], costs[i - 1][2]);\n        costs[i][2] += Math.min(costs[i - 1][0], costs[i - 1][1]);\n    }\n    return Math.min(costs[costs.length - 1][0], Math.min(costs[costs.length - 1][1], costs[costs.length - 1][2]));\n}", "cpp": "int minCost(vector<vector<int>>& costs) {\n    if (costs.empty()) return 0;\n    for (int i = 1; i < costs.size(); ++i) {\n        costs[i][0] += min(costs[i - 1][1], costs[i - 1][2]);\n        costs[i][1] += min(costs[i - 1][0], costs[i - 1][2]);\n        costs[i][2] += min(costs[i - 1][0], costs[i - 1][1]);\n    }\n    return min(costs.back()[0], min(costs.back()[1], costs.back()[2]));\n}", "javascript": "function minCost(costs) {\n    if (costs.length === 0) return 0;\n    for (let i = 1; i < costs.length; i++) {\n        costs[i][0] += Math.min(costs[i - 1][1], costs[i - 1][2]);\n        costs[i][1] += Math.min(costs[i - 1][0], costs[i - 1][2]);\n        costs[i][2] += Math.min(costs[i - 1][0], costs[i - 1][1]);\n    }\n    return Math.min(costs[costs.length - 1][0], costs[costs.length - 1][1], costs[costs.length - 1][2]);\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/257", "prompt": "Given the `root` of a binary tree, return _all root-to-leaf paths in **any order**_.\n\nA **leaf** is a node with no children.\n\n**Example 1:**\n\n**Input:** root = \\[1,2,3,null,5\\]\n**Output:** \\[ \"1->2->5 \", \"1->3 \"\\]\n\n**Example 2:**\n\n**Input:** root = \\[1\\]\n**Output:** \\[ \"1 \"\\]\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 100]`.\n*   `-100 <= Node.val <= 100`", "entry_point": "binary_tree_paths", "canonical_solutions": {"python": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef binary_tree_paths(root: TreeNode):\n    if not root:\n        return []\n    if not root.left and not root.right:\n        return [str(root.val)]\n    paths = []\n    for path in binary_tree_paths(root.left):\n        paths.append(str(root.val) + \"->\" + path)\n    for path in binary_tree_paths(root.right):\n        paths.append(str(root.val) + \"->\" + path)\n    return paths", "java": "import java.util.List;\nimport java.util.ArrayList;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\npublic List<String> binaryTreePaths(TreeNode root) {\n    List<String> paths = new ArrayList<>();\n    if (root == null) {\n        return paths;\n    }\n    if (root.left == null && root.right == null) {\n        paths.add(Integer.toString(root.val));\n        return paths;\n    }\n    for (String path : binaryTreePaths(root.left)) {\n      paths.add(root.val + \"->\" + path);\n    }\n    for (String path : binaryTreePaths(root.right)) {\n      paths.add(root.val + \"->\" + path);\n    }\n    return paths;\n}", "cpp": "#include <vector>\n#include <string>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nstd::vector<std::string> binaryTreePaths(TreeNode* root) {\n    std::vector<std::string> paths;\n    if (!root)\n        return paths;\n    if (!root->left && !root->right) {\n        paths.push_back(std::to_string(root->val));\n        return paths;\n    }\n    for (const std::string &path : binaryTreePaths(root->left)) {\n      paths.push_back(std::to_string(root->val) + \"->\" + path);\n    }\n    for (const std::string &path : binaryTreePaths(root->right)) {\n      paths.push_back(std::to_string(root->val) + \"->\" + path);\n    }\n    return paths;\n}", "javascript": "class TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction binaryTreePaths(root) {\n    if (!root) {\n        return [];\n    }\n    if (!root.left && !root.right) {\n        return [`${root.val}`];\n    }\n    let paths = [];\n    for (let path of binaryTreePaths(root.left)) {\n        paths.push(`${root.val}->${path}`);\n    }\n    for (let path of binaryTreePaths(root.right)) {\n        paths.push(`${root.val}->${path}`);\n    }\n    return paths;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/258", "prompt": "Given an integer `num`, repeatedly add all its digits until the result has only one digit, and return it.\n\n**Example 1:**\n\n**Input:** num = 38\n**Output:** 2\n**Explanation:** The process is\n38 --> 3 + 8 --> 11\n11 --> 1 + 1 --> 2 \nSince 2 has only one digit, return it.\n\n**Example 2:**\n\n**Input:** num = 0\n**Output:** 0\n\n**Constraints:**\n\n*   `0 <= num <= 231 - 1`\n\n**Follow up:** Could you do it without any loop/recursion in `O(1)` runtime?", "entry_point": "add_digits", "canonical_solutions": {"python": "def addDigits(num: int) -> int:\n    return 1 + (num - 1) % 9", "java": "public int addDigits(int num) {\n    return 1 + (num - 1) % 9;\n}", "cpp": "int addDigits(int num) {\n    return 1 + (num - 1) % 9;\n}", "javascript": "function addDigits(num) {\n    return 1 + (num - 1) % 9;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/259", "prompt": "Given an array of `n` integers `nums` and an integer `target`, find the number of index triplets `i`, `j`, `k` with `0 <= i < j < k < n` that satisfy the condition `nums[i] + nums[j] + nums[k] < target`.\n\n**Example 1:**\n\n**Input:** nums = \\[-2,0,1,3\\], target = 2\n**Output:** 2\n**Explanation:** Because there are two triplets which sums are less than 2:\n\\[-2,0,1\\]\n\\[-2,0,3\\]\n\n**Example 2:**\n\n**Input:** nums = \\[\\], target = 0\n**Output:** 0\n\n**Example 3:**\n\n**Input:** nums = \\[0\\], target = 0\n**Output:** 0\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `0 <= n <= 3500`\n*   `-100 <= nums[i] <= 100`\n*   `-100 <= target <= 100`", "entry_point": "3sum_smaller", "canonical_solutions": {"python": "def threeSumSmaller(nums, target):\n    count = 0\n    nums.sort()\n    for i in range(len(nums)):\n        j, k = i + 1, len(nums) - 1\n        while j < k:\n            if nums[i] + nums[j] + nums[k] < target:\n                count += k - j\n                j += 1\n            else:\n                k -= 1\n    return count", "java": "public int threeSumSmaller(int[] nums, int target) {\n    int count = 0;\n    Arrays.sort(nums);\n    for (int i = 0; i < nums.length; ++i) {\n        int j = i + 1, k = nums.length - 1;\n        while (j < k) {\n            if (nums[i] + nums[j] + nums[k] < target) {\n                count += k - j;\n                ++j;\n            } else {\n                --k;\n            }\n        }\n    }\n    return count;\n}", "cpp": "int threeSumSmaller(vector<int>& nums, int target) {\n    int count = 0;\n    sort(nums.begin(), nums.end());\n    for (int i = 0; i < nums.size(); ++i) {\n        int j = i + 1, k = nums.size() - 1;\n        while (j < k) {\n            if (nums[i] + nums[j] + nums[k] < target) {\n                count += k - j;\n                ++j;\n            } else {\n                --k;\n            }\n        }\n    }\n    return count;\n}", "javascript": "function threeSumSmaller(nums, target) {\n    let count = 0;\n    nums.sort((a, b) => a - b);\n    for (let i = 0; i < nums.length; ++i) {\n        let j = i + 1, k = nums.length - 1;\n        while (j < k) {\n            if (nums[i] + nums[j] + nums[k] < target) {\n                count += k - j;\n                ++j;\n            } else {\n                --k;\n            }\n        }\n    }\n    return count;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/260", "prompt": "Given an integer array `nums`, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in **any order**.\n\nYou must write an algorithm that runs in linear runtime complexity and uses only constant extra space.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,1,3,2,5\\]\n**Output:** \\[3,5\\]\n**Explanation: ** \\[5, 3\\] is also a valid answer.\n\n**Example 2:**\n\n**Input:** nums = \\[-1,0\\]\n**Output:** \\[-1,0\\]\n\n**Example 3:**\n\n**Input:** nums = \\[0,1\\]\n**Output:** \\[1,0\\]\n\n**Constraints:**\n\n*   `2 <= nums.length <= 3 * 104`\n*   `-231 <= nums[i] <= 231 - 1`\n*   Each integer in `nums` will appear twice, only two integers will appear once.", "entry_point": "single_number_iii", "canonical_solutions": {"python": "def singleNumber(nums):\n    xor_all = 0\n    for num in nums:\n        xor_all ^= num\n\n    bit = xor_all & -xor_all\n    n1 = 0\n    n2 = 0\n    for num in nums:\n        if num & bit:\n            n1 ^= num\n        else:\n            n2 ^= num\n\n    return n1, n2", "java": "public int[] singleNumber(int[] nums) {\n    int xor_all = 0;\n    for (int num : nums) {\n        xor_all ^= num;\n    }\n\n    int bit = xor_all & -xor_all;\n    int n1 = 0;\n    int n2 = 0;\n    for (int num : nums) {\n        if ((num & bit) != 0) {\n            n1 ^= num;\n        } else {\n            n2 ^= num;\n        }\n    }\n\n    return new int[]{n1, n2};\n}", "cpp": "#include <vector>\nusing namespace std;\n\nvector<int> singleNumber(vector<int>& nums) {\n    int xor_all = 0;\n    for (int num : nums) {\n        xor_all ^= num;\n    }\n\n    int bit = xor_all & (-xor_all);\n    int n1 = 0;\n    int n2 = 0;\n    for (int num : nums) {\n        if (num & bit) {\n            n1 ^= num;\n        } else {\n            n2 ^= num;\n        }\n    }\n\n    return vector<int>{n1, n2};\n}", "javascript": "function singleNumber(nums) {\n    let xor_all = 0;\n    for (const num of nums) {\n        xor_all ^= num;\n    }\n\n    const bit = xor_all & -xor_all;\n    let n1 = 0;\n    let n2 = 0;\n    for (const num of nums) {\n        if (num & bit) {\n            n1 ^= num;\n        } else {\n            n2 ^= num;\n        }\n    }\n\n    return [n1, n2];\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/261", "prompt": "You have a graph of `n` nodes labeled from `0` to `n - 1`. You are given an integer n and a list of `edges` where `edges[i] = [ai, bi]` indicates that there is an undirected edge between nodes `ai` and `bi` in the graph.\n\nReturn `true` _if the edges of the given graph make up a valid tree, and_ `false` _otherwise_.\n\n**Example 1:**\n\n**Input:** n = 5, edges = \\[\\[0,1\\],\\[0,2\\],\\[0,3\\],\\[1,4\\]\\]\n**Output:** true\n\n**Example 2:**\n\n**Input:** n = 5, edges = \\[\\[0,1\\],\\[1,2\\],\\[2,3\\],\\[1,3\\],\\[1,4\\]\\]\n**Output:** false\n\n**Constraints:**\n\n*   `1 <= n <= 2000`\n*   `0 <= edges.length <= 5000`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   There are no self-loops or repeated edges.", "entry_point": "graph_valid_tree", "canonical_solutions": {"python": "from typing import List\n\ndef isTree(n: int, edges: List[List[int]]) -> bool:\n    neighbors = [[] for _ in range(n)]\n    for edge in edges:\n        neighbors[edge[0]].append(edge[1])\n        neighbors[edge[1]].append(edge[0])\n    visited = [False] * n\n    if hasCycle(neighbors, visited, -1, 0): return False\n    return all(visited)\n\ndef hasCycle(neighbors: List[List[int]], visited: List[bool], parent: int, node: int) -> bool:\n    visited[node] = True\n    for neighbor in neighbors[node]:\n        if (neighbor != parent and visited[neighbor]) or (not visited[neighbor] and hasCycle(neighbors, visited, node, neighbor)): return True\n    return False", "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic boolean isTree(int n, int[][] edges) {\n    List<List<Integer>> neighbors = new ArrayList<>(n);\n    for (int i = 0; i < n; i++) neighbors.add(new ArrayList<>());\n    for (int[] edge : edges) {\n        neighbors.get(edge[0]).add(edge[1]);\n        neighbors.get(edge[1]).add(edge[0]);\n    }\n    boolean[] visited = new boolean[n];\n    if(hasCycle(neighbors, visited, -1, 0)) return false;\n    for (boolean visit : visited)\n        if (!visit) return false;\n    return true;\n}\n\nprivate boolean hasCycle(List<List<Integer>> neighbors, boolean[] visited, int parent, int node) {\n    visited[node] = true;\n    for (int neighbor : neighbors.get(node))\n        if ((neighbor != parent && visited[neighbor]) || (!visited[neighbor] && hasCycle(neighbors, visited, node, neighbor))) return true;\n    return false;\n}", "cpp": "#include <vector>\n\nbool isTree(int n, std::vector<std::vector<int>>& edges) {\n    std::vector<std::vector<int>> neighbors(n);\n    for (const auto& edge : edges) {\n        neighbors[edge[0]].push_back(edge[1]);\n        neighbors[edge[1]].push_back(edge[0]);\n    }\n    std::vector<bool> visited(n, false);\n    if(hasCycle(neighbors, visited, -1, 0)) return false;\n    for (const auto& visit : visited)\n        if (!visit) return false;\n    return true;\n}\n\nbool hasCycle(const std::vector<std::vector<int>>& neighbors, std::vector<bool>& visited, int parent, int node) {\n    visited[node] = true;\n    for (const auto& neighbor : neighbors[node])\n        if ((neighbor != parent && visited[neighbor]) || (!visited[neighbor] && hasCycle(neighbors, visited, node, neighbor))) return true;\n    return false;\n}", "javascript": "function isTree(n, edges) {\n    const neighbors = Array.from({length: n}, () => []);\n    for (const edge of edges) {\n        neighbors[edge[0]].push(edge[1]);\n        neighbors[edge[1]].push(edge[0]);\n    }\n    const visited = Array(n).fill(false);\n    if(hasCycle(neighbors, visited, -1, 0)) return false;\n    for (const visit of visited)\n        if (!visit) return false;\n    return true;\n}\n\nfunction hasCycle(neighbors, visited, parent, node) {\n    visited[node] = true;\n    for (const neighbour of neighbors[node])\n        if ((neighbour !== parent && visited[neighbour]) || (!visited[neighbour] && hasCycle(neighbors, visited, node, neighbour))) return true;\n    return false;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/263", "prompt": "An **ugly number** is a positive integer whose prime factors are limited to `2`, `3`, and `5`.\n\nGiven an integer `n`, return `true` _if_ `n` _is an **ugly number**_.\n\n**Example 1:**\n\n**Input:** n = 6\n**Output:** true\n**Explanation:** 6 = 2 \\* 3\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** true\n**Explanation:** 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.\n\n**Example 3:**\n\n**Input:** n = 14\n**Output:** false\n**Explanation:** 14 is not ugly since it includes the prime factor 7.\n\n**Constraints:**\n\n*   `-231 <= n <= 231 - 1`", "entry_point": "ugly_number", "canonical_solutions": {"python": "def is_ugly(n: int) -> bool:\n    if n <= 0:\n        return False\n    for factor in [2, 3, 5]:\n        while n % factor == 0:\n            n //= factor\n    return n == 1", "java": "public boolean isUgly(int n) {\n    if (n <= 0) return false;\n    while (n % 2 == 0) n /= 2;\n    while (n % 3 == 0) n /= 3;\n    while (n % 5 == 0) n /= 5;\n    return n == 1;\n}", "cpp": "bool isUgly(int n) {\n    if (n <= 0) return false;\n    while (n % 2 == 0) n /= 2;\n    while (n % 3 == 0) n /= 3;\n    while (n % 5 == 0) n /= 5;\n    return n == 1;\n}", "javascript": "function isUgly(n) {\n    if (n <= 0) return false;\n    while (n % 2 === 0) n /= 2;\n    while (n % 3 === 0) n /= 3;\n    while (n % 5 === 0) n /= 5;\n    return n === 1;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/264", "prompt": "An **ugly number** is a positive integer whose prime factors are limited to `2`, `3`, and `5`.\n\nGiven an integer `n`, return _the_ `nth` _**ugly number**_.\n\n**Example 1:**\n\n**Input:** n = 10\n**Output:** 12\n**Explanation:** \\[1, 2, 3, 4, 5, 6, 8, 9, 10, 12\\] is the sequence of the first 10 ugly numbers.\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** 1\n**Explanation:** 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.\n\n**Constraints:**\n\n*   `1 <= n <= 1690`", "entry_point": "ugly_number_ii", "canonical_solutions": {"python": "def nthUglyNumber(n: int) -> int:\n    ugly_numbers = [0] * n\n    ugly_numbers[0] = 1\n    i2, i3, i5 = 0, 0, 0\n\n    for i in range(1, n):\n        ugly_numbers[i] = min(ugly_numbers[i2] * 2, ugly_numbers[i3] * 3, ugly_numbers[i5] * 5)\n        if ugly_numbers[i] == ugly_numbers[i2] * 2: i2 += 1\n        if ugly_numbers[i] == ugly_numbers[i3] * 3: i3 += 1\n        if ugly_numbers[i] == ugly_numbers[i5] * 5: i5 += 1\n\n    return ugly_numbers[n - 1]", "java": "public int nthUglyNumber(int n) {\n    int[] uglyNumbers = new int[n];\n    uglyNumbers[0] = 1;\n    int i2 = 0, i3 = 0, i5 = 0;\n\n    for (int i = 1; i < n; i++) {\n        uglyNumbers[i] = Math.min(Math.min(uglyNumbers[i2] * 2, uglyNumbers[i3] * 3), uglyNumbers[i5] * 5);\n        if (uglyNumbers[i] == uglyNumbers[i2] * 2) i2++;\n        if (uglyNumbers[i] == uglyNumbers[i3] * 3) i3++;\n        if (uglyNumbers[i] == uglyNumbers[i5] * 5) i5++;\n    }\n\n    return uglyNumbers[n - 1];\n}", "cpp": "int nthUglyNumber(int n) {\n    vector<int> uglyNumbers(n);\n    uglyNumbers[0] = 1;\n    int i2 = 0, i3 = 0, i5 = 0;\n\n    for (int i = 1; i < n; i++) {\n        uglyNumbers[i] = min({uglyNumbers[i2] * 2, uglyNumbers[i3] * 3, uglyNumbers[i5] * 5});\n        if (uglyNumbers[i] == uglyNumbers[i2] * 2) i2++;\n        if (uglyNumbers[i] == uglyNumbers[i3] * 3) i3++;\n        if (uglyNumbers[i] == uglyNumbers[i5] * 5) i5++;\n    }\n\n    return uglyNumbers[n - 1];\n}", "javascript": "function nthUglyNumber(n) {\n    let uglyNumbers = new Array(n);\n    uglyNumbers[0] = 1;\n    let i2 = 0, i3 = 0, i5 = 0;\n\n    for (let i = 1; i < n; i++) {\n        uglyNumbers[i] = Math.min(Math.min(uglyNumbers[i2] * 2, uglyNumbers[i3] * 3), uglyNumbers[i5] * 5);\n        if (uglyNumbers[i] === uglyNumbers[i2] * 2) i2++;\n        if (uglyNumbers[i] === uglyNumbers[i3] * 3) i3++;\n        if (uglyNumbers[i] === uglyNumbers[i5] * 5) i5++;\n    }\n\n    return uglyNumbers[n - 1];\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/265", "prompt": "There are a row of `n` houses, each house can be painted with one of the `k` colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.\n\nThe cost of painting each house with a certain color is represented by an `n x k` cost matrix costs.\n\n*   For example, `costs[0][0]` is the cost of painting house `0` with color `0`; `costs[1][2]` is the cost of painting house `1` with color `2`, and so on...\n\nReturn _the minimum cost to paint all houses_.\n\n**Example 1:**\n\n**Input:** costs = \\[\\[1,5,3\\],\\[2,9,4\\]\\]\n**Output:** 5\n**Explanation:**\nPaint house 0 into color 0, paint house 1 into color 2. Minimum cost: 1 + 4 = 5; \nOr paint house 0 into color 2, paint house 1 into color 0. Minimum cost: 3 + 2 = 5.\n\n**Example 2:**\n\n**Input:** costs = \\[\\[1,3\\],\\[2,4\\]\\]\n**Output:** 5\n\n**Constraints:**\n\n*   `costs.length == n`\n*   `costs[i].length == k`\n*   `1 <= n <= 100`\n*   `2 <= k <= 20`\n*   `1 <= costs[i][j] <= 20`\n\n**Follow up:** Could you solve it in `O(nk)` runtime?", "entry_point": "paint_house_ii", "canonical_solutions": {"python": "def min_cost(costs: List[List[int]]) -> int:\n    if not costs:\n        return 0\n\n    n, k = len(costs), len(costs[0])\n\n    for i in range(1, n):\n        for j in range(k):\n            min_cost = float(\"inf\")\n            for l in range(k):\n                if l == j:\n                    continue\n                min_cost = min(min_cost, costs[i - 1][l])\n            costs[i][j] += min_cost\n\n    return min(costs[n - 1])", "java": "public int minCost(int[][] costs) {\n    if (costs == null || costs.length == 0) return 0;\n\n    int n = costs.length;\n    int k = costs[0].length;\n\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < k; j++) {\n            int minCost = Integer.MAX_VALUE;\n            for (int l = 0; l < k; l++) {\n                if (l == j) continue;\n                minCost = Math.min(minCost, costs[i - 1][l]);\n            }\n            costs[i][j] += minCost;\n        }\n    }\n    return Arrays.stream(costs[n - 1]).min().getAsInt();\n}", "cpp": "int minCost(vector<vector<int>>& costs) {\n    if (costs.empty()) return 0;\n\n    int n = costs.size();\n    int k = costs[0].size();\n\n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < k; ++j) {\n            int minCost = INT_MAX;\n            for (int l = 0; l < k; ++l) {\n                if (l == j) continue;\n                minCost = min(minCost, costs[i - 1][l]);\n            }\n            costs[i][j] += minCost;\n        }\n    }\n    return *min_element(costs[n - 1].begin(), costs[n - 1].end());\n}", "javascript": "function minCost(costs) {\n    if (!costs || costs.length === 0) return 0;\n\n    const n = costs.length;\n    const k = costs[0].length;\n\n    for (let i = 1; i < n; i++) {\n        for (let j = 0; j < k; j++) {\n            let minCost = Number.MAX_VALUE;\n            for (let l = 0; l < k; l++) {\n                if (l === j) continue;\n                minCost = Math.min(minCost, costs[i - 1][l]);\n            }\n            costs[i][j] += minCost;\n        }\n    }\n    return Math.min(...costs[n - 1]);\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/266", "prompt": "Given a string `s`, return `true` _if a permutation of the string could form a_ _**palindrome**_ _and_ `false` _otherwise_.\n\n**Example 1:**\n\n**Input:** s =  \"code \"\n**Output:** false\n\n**Example 2:**\n\n**Input:** s =  \"aab \"\n**Output:** true\n\n**Example 3:**\n\n**Input:** s =  \"carerac \"\n**Output:** true\n\n**Constraints:**\n\n*   `1 <= s.length <= 5000`\n*   `s` consists of only lowercase English letters.", "entry_point": "palindrome_permutation", "canonical_solutions": {"python": "def canPermutePalindrome(s: str) -> bool:\n    count = {}\n    for c in s:\n        if c in count:\n            count[c] += 1\n        else:\n            count[c] = 1\n    odd_count = 0\n    for value in count.values():\n        if value % 2:\n            odd_count += 1\n    return odd_count <= 1", "java": "public boolean canPermutePalindrome(String s) {\n    HashMap<Character, Integer> count = new HashMap<>();\n    for(char c : s.toCharArray()) {\n        count.put(c, count.getOrDefault(c, 0) + 1);\n    }\n    int odd_count = 0;\n    for(int value : count.values()) {\n        if (value % 2 != 0) {\n            odd_count++;\n        }\n    }\n    return odd_count <= 1;\n}", "cpp": "bool canPermutePalindrome(string s) {\n    unordered_map<char, int> count;\n    for (char c : s) {\n        count[c]++;\n    }\n    int odd_count = 0;\n    for (auto it = count.begin(); it != count.end(); ++it) {\n        if (it->second % 2) {\n            odd_count++;\n        }\n    }\n    return odd_count <= 1;\n}", "javascript": "function canPermutePalindrome(s) {\n    const count = {}\n    for (const c of s) {\n        if (c in count) {\n            count[c]++;\n        } else {\n            count[c] = 1;\n        }\n    }\n    let odd_count = 0;\n    for (const value of Object.values(count)) {\n        if (value % 2) {\n            odd_count++;\n        }\n    }\n    return odd_count <= 1;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/267", "prompt": "Given a string s, return _all the palindromic permutations (without duplicates) of it_.\n\nYou may return the answer in **any order**. If `s` has no palindromic permutation, return an empty list.\n\n**Example 1:**\n\n**Input:** s = \"aabb\"\n**Output:** \\[\"abba\",\"baab\"\\]\n\n**Example 2:**\n\n**Input:** s = \"abc\"\n**Output:** \\[\\]\n\n**Constraints:**\n\n*   `1 <= s.length <= 16`\n*   `s` consists of only lowercase English letters.", "entry_point": "palindrome_permutation_ii", "canonical_solutions": {"python": "from collections import Counter\nfrom itertools import permutations\n\ndef generatePalindromes(s):\n    result = []\n    char_count = Counter(s)\n\n    mid_char = \"\"\n    half_str = []\n    num_ocurrences = 0\n\n    for char, count in char_count.items():\n        if count % 2 == 1:\n            num_ocurrences += 1\n            mid_char = char\n        half_str.extend([char] * (count // 2))\n\n        if num_ocurrences > 1:\n            return result\n\n    for perm in set(permutations(half_str)):\n        palindrome = \"\".join(perm) + mid_char + \"\".join(reversed(perm))\n        result.append(palindrome)\n\n    return result", "java": "import java.util.*;\n\npublic class Solution {\n    public List<String> generatePalindromes(String s) {\n        List<String> result = new ArrayList<>();\n        Map<Character, Integer> charCount = new HashMap<>();\n        for (char c : s.toCharArray()) {\n            charCount.put(c, charCount.getOrDefault(c, 0) + 1);\n        }\n\n        String midChar = \"\";\n        List<Character> halfChars = new ArrayList<>();\n        int numOdds = 0;\n        for (Map.Entry<Character, Integer> entry : charCount.entrySet()) {\n            if (entry.getValue() % 2 == 1) {\n                numOdds++;\n                midChar = String.valueOf(entry.getKey());\n            }\n            for (int i = 0; i < entry.getValue() / 2; i++) {\n                halfChars.add(entry.getKey());\n            }\n\n            if (numOdds > 1) {\n                return result;\n            }\n        }\n\n        permute(0, halfChars, midChar, new ArrayList<>(), result);\n        return result;\n    }\n\n    private void permute(int idx, List<Character> halfChars, String midChar, List<Character> current, List<String> result) {\n        if (idx == halfChars.size()) {\n            String firstHalf = \"\".valueOf(current.toArray(new Character[0]));\n            result.add(firstHalf + midChar + new StringBuilder(firstHalf).reverse());\n            return;\n        }\n\n        for (int i = 0; i < halfChars.size(); i++) {\n            if (i > 0 && halfChars.get(i) == halfChars.get(i - 1)) {\n                continue;\n            }\n            Character c = halfChars.remove(i);\n            current.add(c);\n            permute(idx + 1, halfChars, midChar, current, result);\n            current.remove(current.size() - 1);\n            halfChars.add(i, c);\n        }\n    }\n}", "cpp": "#include <vector>\n#include <string>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<string> generatePalindromes(string s) {\n    unordered_map<char, int> charCount;\n    for (const char &c : s) {\n        charCount[c]++;\n    }\n    \n    int numOdds = 0;\n    string halfStr = \"\", midChar = \"\";\n    for (const auto &entry : charCount) {\n        if (entry.second % 2 == 1) {\n            numOdds++;\n            midChar = entry.first;\n        }\n        halfStr += string(entry.second / 2, entry.first);\n        \n        if (numOdds > 1) {\n            return {};\n        }\n    }\n    \n    vector<string> result;\n    sort(halfStr.begin(), halfStr.end());\n    do {\n        string palindrome = halfStr + midChar + string(halfStr.rbegin(), halfStr.rend());\n        result.push_back(palindrome);\n    } while (next_permutation(halfStr.begin(), halfStr.end()));\n    \n    return result;\n}", "javascript": "function generatePalindromes(s) {\n    let result = [];\n    let charCount = new Map();\n    for (const c of s) {\n        charCount.set(c, (charCount.get(c) || 0) + 1);\n    }\n\n    let midChar = \"\";\n    let halfChars = [];\n    let numOdds = 0;\n    charCount.forEach((count, char) => {\n        if (count % 2 === 1) {\n            numOdds++;\n            midChar = char;\n        }\n        for (let i = 0; i < Math.floor(count / 2); i++) {\n            halfChars.push(char);\n        }\n\n        if (numOdds > 1) {\n            return [];\n        }\n    });\n\n    function btPerm(idx, current) {\n        if (idx === halfChars.length) {\n            const firstHalf = current.join('');\n            result.push(firstHalf + midChar + firstHalf.split('').reverse().join(''));\n            return;\n        }\n\n        for (let i = 0; i < halfChars.length; i++) {\n            if (i > 0 && halfChars[i] === halfChars[i - 1]) {\n                continue;\n            }\n            const char = halfChars.splice(i, 1)[0];\n            current.push(char);\n            btPerm(idx + 1, current);\n            current.pop();\n            halfChars.splice(i, 0, char);\n        }\n    }\n\n    halfChars.sort();\n    btPerm(0, []);\n\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/268", "prompt": "Given an array `nums` containing `n` distinct numbers in the range `[0, n]`, return _the only number in the range that is missing from the array._\n\n**Example 1:**\n\n**Input:** nums = \\[3,0,1\\]\n**Output:** 2\n**Explanation:** n = 3 since there are 3 numbers, so all numbers are in the range \\[0,3\\]. 2 is the missing number in the range since it does not appear in nums.\n\n**Example 2:**\n\n**Input:** nums = \\[0,1\\]\n**Output:** 2\n**Explanation:** n = 2 since there are 2 numbers, so all numbers are in the range \\[0,2\\]. 2 is the missing number in the range since it does not appear in nums.\n\n**Example 3:**\n\n**Input:** nums = \\[9,6,4,2,3,5,7,0,1\\]\n**Output:** 8\n**Explanation:** n = 9 since there are 9 numbers, so all numbers are in the range \\[0,9\\]. 8 is the missing number in the range since it does not appear in nums.\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 104`\n*   `0 <= nums[i] <= n`\n*   All the numbers of `nums` are **unique**.\n\n**Follow up:** Could you implement a solution using only `O(1)` extra space complexity and `O(n)` runtime complexity?", "entry_point": "missing_number", "canonical_solutions": {"python": "def missingNumber(nums):\n    n = len(nums)\n    expected_sum = (n * (n + 1)) // 2\n    actual_sum = sum(nums)\n    return expected_sum - actual_sum", "java": "public int missingNumber(int[] nums) {\n    int n = nums.length;\n    int expectedSum = (n * (n + 1)) / 2;\n    int actualSum = 0;\n    for (int num : nums) {\n        actualSum += num;\n    }\n    return expectedSum - actualSum;\n}", "cpp": "int missingNumber(vector<int>& nums) {\n    int n = nums.size();\n    int expected_sum = (n * (n + 1)) / 2;\n    int actual_sum = 0;\n    for (int num : nums) {\n        actual_sum += num;\n    }\n    return expected_sum - actual_sum;\n}", "javascript": "function missingNumber(nums) {\n    const n = nums.length;\n    const expectedSum = (n * (n + 1)) / 2;\n    const actualSum = nums.reduce((acc, num) => acc + num, 0);\n    return expectedSum - actualSum;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/269", "prompt": "There is a new alien language that uses the English alphabet. However, the order among the letters is unknown to you.\n\nYou are given a list of strings `words` from the alien language's dictionary, where the strings in `words` are **sorted lexicographically** by the rules of this new language.\n\nReturn _a string of the unique letters in the new alien language sorted in **lexicographically increasing order** by the new language's rules._ If there is no solution, return `\" \"`_._ If there are multiple solutions, return _**any of them**_.\n\n**Example 1:**\n\n**Input:** words = \\[ \"wrt \", \"wrf \", \"er \", \"ett \", \"rftt \"\\]\n**Output:**  \"wertf \"\n\n**Example 2:**\n\n**Input:** words = \\[ \"z \", \"x \"\\]\n**Output:**  \"zx \"\n\n**Example 3:**\n\n**Input:** words = \\[ \"z \", \"x \", \"z \"\\]\n**Output:**  \" \"\n**Explanation:** The order is invalid, so return ` \" \"`.\n\n**Constraints:**\n\n*   `1 <= words.length <= 100`\n*   `1 <= words[i].length <= 100`\n*   `words[i]` consists of only lowercase English letters.", "entry_point": "alien_dictionary", "canonical_solutions": {"python": "from collections import deque, defaultdict, Counter\n\ndef alienOrder(words):\n    graph = defaultdict(set)\n    in_degree = Counter({c: 0 for word in words for c in word})\n    \n    for word1, word2 in zip(words, words[1:]):\n        found = False\n        for c1, c2 in zip(word1, word2):\n            if c1 != c2:\n                if c2 not in graph[c1]:\n                    graph[c1].add(c2)\n                    in_degree[c2] += 1\n                found = True\n                break\n        if not found and len(word1) > len(word2):\n            return \"\"\n    \n    q = deque([c for c in in_degree if in_degree[c] == 0])\n    result = []\n    while q:\n        c = q.popleft()\n        result.append(c)\n        \n        for neigh in graph[c]:\n            in_degree[neigh] -= 1\n            if in_degree[neigh] == 0:\n                q.append(neigh)\n                 \n    if len(result) < len(in_degree):\n        return \"\"\n    \n    return \"\".join(result)", "java": "import java.util.*;\n\npublic String alienOrder(String[] words) {\n    Map<Character, Set<Character>> graph = new HashMap<>();\n    Map<Character, Integer> inDegree = new HashMap<>();\n    \n    for (String word : words) {\n        for (char c : word.toCharArray())\n            inDegree.put(c, 0);\n    }\n    \n    for (int i = 0; i < words.length - 1; i++) {\n        String word1 = words[i], word2 = words[i + 1];\n        \n        boolean found = false;\n        for (int j = 0; j < Math.min(word1.length(), word2.length()); j++) {\n            char c1 = word1.charAt(j), c2 = word2.charAt(j);\n            if (c1 != c2) {\n                graph.putIfAbsent(c1, new HashSet<>());\n                if (!graph.get(c1).contains(c2)) {\n                    graph.get(c1).add(c2);\n                    inDegree.put(c2, inDegree.get(c2) + 1);\n                }\n                found = true;\n                break;\n            }\n        }\n        \n        if (!found && word1.length() > word2.length())\n            return \"\";\n    }\n\n    Queue<Character> q = new LinkedList<>();\n    for (Map.Entry<Character, Integer> entry : inDegree.entrySet())\n        if (entry.getValue() == 0)\n            q.offer(entry.getKey());\n    \n    StringBuilder result = new StringBuilder();\n    while (!q.isEmpty()) {\n        char c = q.poll();\n        result.append(c);\n        \n        if (graph.containsKey(c)) {\n            for (char neigh : graph.get(c)) {\n                inDegree.put(neigh, inDegree.get(neigh) - 1);\n                if (inDegree.get(neigh) == 0)\n                    q.offer(neigh);\n            }\n        }\n    }\n    \n    if (result.length() < inDegree.size())\n        return \"\";\n    \n    return result.toString();\n}", "cpp": "#include <vector>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n\nstd::string alienOrder(std::vector<std::string> &words) {\n    std::unordered_map<char, std::unordered_set<char>> graph;\n    std::unordered_map<char, int> inDegree;\n    \n    for (const std::string &word : words)\n        for (char c : word)\n            inDegree[c] = 0;\n    \n    for (int i = 0; i < words.size() - 1; i++) {\n        std::string word1 = words[i], word2 = words[i + 1];\n        \n        bool found = false;\n        for (int j = 0; j < std::min(word1.size(), word2.size()); j++) {\n            char c1 = word1[j], c2 = word2[j];\n            if (c1 != c2) {\n                if (!graph[c1].count(c2)) {\n                    graph[c1].insert(c2);\n                    inDegree[c2]++;\n                }\n                found = true;\n                break;\n            }\n        }\n        \n        if (!found && word1.size() > word2.size())\n            return \"\";\n    }\n\n    std::queue<char> q;\n    for (auto &[c, deg] : inDegree)\n        if (deg == 0)\n            q.push(c);\n    \n    std::string result;\n    while (!q.empty()) {\n        char c = q.front();\n        q.pop();\n        result += c;\n        \n        for (char neigh : graph[c]) {\n            inDegree[neigh]--;\n            if (inDegree[neigh] == 0)\n                q.push(neigh);\n        }\n    }\n    \n    if (result.size() < inDegree.size())\n        return \"\";\n    \n    return result;\n}", "javascript": "function alienOrder(words) {\n    const graph = new Map();\n    const inDegree = new Map();\n    \n    for (const word of words)\n        for (const c of word)\n            inDegree.set(c, 0);\n    \n    for (let i = 0; i < words.length - 1; i++) {\n        const word1 = words[i], word2 = words[i + 1];\n        \n        let found = false;\n        for (let j = 0; j < Math.min(word1.length, word2.length); j++) {\n            const c1 = word1[j], c2 = word2[j];\n            if (c1 !== c2) {\n                if (!graph.has(c1)) graph.set(c1, new Set());\n                if (!graph.get(c1).has(c2)) {\n                    graph.get(c1).add(c2);\n                    inDegree.set(c2, inDegree.get(c2) + 1);\n                }\n                found = true;\n                break;\n            }\n        }\n        \n        if (!found && word1.length > word2.length)\n            return \"\";\n    }\n\n    const q = [];\n    for (const [c, deg] of inDegree.entries())\n        if (deg === 0)\n            q.push(c);\n    \n    let result = \"\";\n    while (q.length) {\n        const c = q.shift();\n        result += c;\n        \n        if (graph.has(c)) {\n            for (const neigh of graph.get(c)) {\n                inDegree.set(neigh, inDegree.get(neigh) - 1);\n                if (inDegree.get(neigh) === 0)\n                    q.push(neigh);\n            }\n        }\n    }\n    \n    if (result.length < inDegree.size)\n        return \"\";\n    \n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/270", "prompt": "Given the `root` of a binary search tree and a `target` value, return _the value in the BST that is closest to the_ `target`. If there are multiple answers, print the smallest.\n\n**Example 1:**\n\n**Input:** root = \\[4,2,5,1,3\\], target = 3.714286\n**Output:** 4\n\n**Example 2:**\n\n**Input:** root = \\[1\\], target = 4.428571\n**Output:** 1\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `0 <= Node.val <= 109`\n*   `-109 <= target <= 109`", "entry_point": "closest_binary_search_tree_value", "canonical_solutions": {"python": "class Solution:\n    def closestValue(self, root: TreeNode, target: float) -> int:\n        closest = root.val\n        while root:\n            if abs(target - closest) > abs(target - root.val):\n                closest = root.val\n            root = root.left if target < root.val else root.right\n        return closest", "java": "class Solution {\n    public int closestValue(TreeNode root, double target) {\n        int closest = root.val;\n        while (root != null) {\n            if (Math.abs(target - closest) > Math.abs(target - root.val)) {\n                closest = root.val;\n            }\n            root = target < root.val ? root.left : root.right;\n        }\n        return closest;\n    }\n}", "cpp": "class Solution {\npublic:\n    int closestValue(TreeNode* root, double target) {\n        int closest = root->val;\n        while (root != nullptr) {\n            if (abs(target - closest) > abs(target - root->val)) {\n                closest = root->val;\n            }\n            root = target < root->val ? root->left : root->right;\n        }\n        return closest;\n    }\n};", "javascript": "var closestValue = function(root, target) {\n    let closest = root.val;\n    while (root !== null) {\n        if (Math.abs(target - closest) > Math.abs(target - root.val)) {\n            closest = root.val;\n        }\n        root = target < root.val ? root.left : root.right;\n    }\n    return closest;\n};"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/271", "prompt": "Design an algorithm to encode **a list of strings** to **a string**. The encoded string is then sent over the network and is decoded back to the original list of strings.\n\nMachine 1 (sender) has the function:\n\nstring encode(vector strs) {\n  // ... your code\n  return encoded\\_string;\n}\n\nMachine 2 (receiver) has the function:\n\nvector decode(string s) {\n  //... your code\n  return strs;\n}\n\nSo Machine 1 does:\n\nstring encoded\\_string = encode(strs);\n\nand Machine 2 does:\n\nvector strs2 = decode(encoded\\_string);\n\n`strs2` in Machine 2 should be the same as `strs` in Machine 1.\n\nImplement the `encode` and `decode` methods.\n\nYou are not allowed to solve the problem using any serialize methods (such as `eval`).\n\n**Example 1:**\n\n**Input:** dummy\\_input = \\[ \"Hello \", \"World \"\\]\n**Output:** \\[ \"Hello \", \"World \"\\]\n**Explanation:**\nMachine 1:\nCodec encoder = new Codec();\nString msg = encoder.encode(strs);\nMachine 1 ---msg---> Machine 2\n\nMachine 2:\nCodec decoder = new Codec();\nString\\[\\] strs = decoder.decode(msg);\n\n**Example 2:**\n\n**Input:** dummy\\_input = \\[ \" \"\\]\n**Output:** \\[ \" \"\\]\n\n**Constraints:**\n\n*   `1 <= strs.length <= 200`\n*   `0 <= strs[i].length <= 200`\n*   `strs[i]` contains any possible characters out of `256` valid ASCII characters.\n\n**Follow up:** Could you write a generalized algorithm to work on any possible set of characters?", "entry_point": "encode_and_decode_strings", "canonical_solutions": {"python": "def encode(strs):\n    encoded_string = \"\"\n    for s in strs:\n        encoded_string += str(len(s)) + \"#\" + s\n    return encoded_string\n\ndef decode(s):\n    strs = []\n    i = 0\n    while i < len(s):\n        delimiter_pos = s.find('#', i)\n        length = int(s[i:delimiter_pos])\n        strs.append(s[delimiter_pos + 1:delimiter_pos + 1 + length])\n        i = delimiter_pos + 1 + length\n    return strs", "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic String encode(List<String> strs) {\n    StringBuilder encodedString = new StringBuilder();\n    for (String s : strs) {\n        encodedString.append(s.length()).append('#').append(s);\n    }\n    return encodedString.toString();\n}\n\npublic List<String> decode(String s) {\n    List<String> strs = new ArrayList<>();\n    int i = 0;\n    while (i < s.length()) {\n        int delimiterPos = s.indexOf('#', i);\n        int length = Integer.parseInt(s.substring(i, delimiterPos));\n        strs.add(s.substring(delimiterPos + 1, delimiterPos + 1 + length));\n        i = delimiterPos + 1 + length;\n    }\n    return strs;\n}", "cpp": "#include <vector>\n#include <string>\n\nstd::string encode(const std::vector<std::string>& strs) {\n    std::string encoded_string;\n    for (const auto& s : strs) {\n        encoded_string += std::to_string(s.length()) + \"#\" + s;\n    }\n    return encoded_string;\n}\n\nstd::vector<std::string> decode(const std::string& s) {\n    std::vector<std::string> strs;\n    int i = 0;\n    while (i < s.length()) {\n        int delimiter_pos = s.find('#', i);\n        int length = std::stoi(s.substr(i, delimiter_pos - i));\n        strs.push_back(s.substr(delimiter_pos + 1, length));\n        i = delimiter_pos + length + 1;\n    }\n    return strs;\n}", "javascript": "function encode(strs) {\n    let encodedString = \"\";\n    for (const s of strs) {\n        encodedString += s.length + \"#\" + s;\n    }\n    return encodedString;\n}\n\nfunction decode(s) {\n    let strs = [];\n    let i = 0;\n    while (i < s.length) {\n        const delimiterPos = s.indexOf('#', i);\n        const length = parseInt(s.slice(i, delimiterPos));\n        strs.push(s.slice(delimiterPos + 1, delimiterPos + 1 + length));\n        i = delimiterPos + 1 + length;\n    }\n    return strs;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/272", "prompt": "Given the `root` of a binary search tree, a `target` value, and an integer `k`, return _the_ `k` _values in the BST that are closest to the_ `target`. You may return the answer in **any order**.\n\nYou are **guaranteed** to have only one unique set of `k` values in the BST that are closest to the `target`.\n\n**Example 1:**\n\n**Input:** root = \\[4,2,5,1,3\\], target = 3.714286, k = 2\n**Output:** \\[4,3\\]\n\n**Example 2:**\n\n**Input:** root = \\[1\\], target = 0.000000, k = 1\n**Output:** \\[1\\]\n\n**Constraints:**\n\n*   The number of nodes in the tree is `n`.\n*   `1 <= k <= n <= 104`.\n*   `0 <= Node.val <= 109`\n*   `-109 <= target <= 109`\n\n**Follow up:** Assume that the BST is balanced. Could you solve it in less than `O(n)` runtime (where `n = total nodes`)?", "entry_point": "closest_binary_search_tree_value_ii", "canonical_solutions": {"python": "from heapq import heappush, heappop\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef closestKValues(root, target, k):\n    values = []\n    max_heap = []\n\n    def inorder_traverse(node):\n        if not node:\n            return\n        inorder_traverse(node.left)\n        heappush(max_heap, (-abs(node.val - target), node.val))\n        if len(max_heap) > k:\n            heappop(max_heap)\n        inorder_traverse(node.right)\n\n    inorder_traverse(root)\n    while max_heap:\n        _, val = heappop(max_heap)\n        values.append(val)\n    return values", "java": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.PriorityQueue;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n}\n\npublic List<Integer> closestKValues(TreeNode root, double target, int k) {\n    PriorityQueue<int[]> maxHeap = new PriorityQueue<>((a, b) -> Double.compare(b[1], a[1]));\n    List<Integer> values = new ArrayList<>();\n\n    inorderTraversal(root, target, k, maxHeap);\n\n    while (!maxHeap.isEmpty()) {\n        values.add(maxHeap.poll()[0]);\n    }\n    return values;\n}\n\nvoid inorderTraversal(TreeNode node, double target, int k, PriorityQueue<int[]> maxHeap) {\n    if (node == null) return;\n\n    inorderTraversal(node.left, target, k, maxHeap);\n    maxHeap.offer(new int[]{node.val, Math.abs(node.val - target)});\n    if (maxHeap.size() > k) maxHeap.poll();\n    inorderTraversal(node.right, target, k, maxHeap);\n}", "cpp": "#include <vector>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n};\n\nvector<int> closestKValues(TreeNode* root, double target, int k) {\n    vector<int> values;\n    priority_queue<pair<double, int>> maxHeap;\n\n    function<void(TreeNode*)> inorderTraverse = [&](TreeNode* node) {\n        if (!node) return;\n        inorderTraverse(node->left);\n        maxHeap.push(make_pair(fabs(node->val - target), node->val));\n        if (maxHeap.size() > k) maxHeap.pop();\n        inorderTraverse(node->right);\n    };\n\n    inorderTraverse(root);\n    while (!maxHeap.empty()) {\n        values.push_back(maxHeap.top().second);\n        maxHeap.pop();\n    }\n    return values;\n}", "javascript": "class TreeNode {\n    constructor(val, left=null, right=null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction closestKValues(root, target, k) {\n    const values = [];\n    const maxHeap = [];\n\n    function inorderTraversal(node) {\n        if (!node) return;\n        inorderTraversal(node.left);\n        maxHeap.push({diff: Math.abs(node.val - target), val: node.val});\n        maxHeap.sort((a, b) => b.diff - a.diff);\n        if (maxHeap.length > k) maxHeap.pop();\n        inorderTraversal(node.right);\n    }\n\n    inorderTraversal(root);\n    for (let item of maxHeap) {\n        values.push(item.val);\n    }\n    return values;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/273", "prompt": "Convert a non-negative integer `num` to its English words representation.\n\n**Example 1:**\n\n**Input:** num = 123\n**Output:**  \"One Hundred Twenty Three \"\n\n**Example 2:**\n\n**Input:** num = 12345\n**Output:**  \"Twelve Thousand Three Hundred Forty Five \"\n\n**Example 3:**\n\n**Input:** num = 1234567\n**Output:**  \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven \"\n\n**Constraints:**\n\n*   `0 <= num <= 231 - 1`", "entry_point": "integer_to_english_words", "canonical_solutions": {"python": "class Solution:\n    def numberToWords(self, num: int) -> str:\n        if num == 0:\n            return \"Zero\"\n        LESS_THAN_20 = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        TENS = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        THOUSANDS = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n\n        def helper(num):\n            if num == 0:\n                return \"\"\n            elif num < 20:\n                return LESS_THAN_20[num] + \" \"\n            elif num < 100:\n                return TENS[num // 10] + \" \" + helper(num % 10)\n            else:\n                return LESS_THAN_20[num // 100] + \" Hundred \" + helper(num % 100)\n\n        result = \"\"\n        i = 0\n        while num > 0:\n            if num % 1000 != 0:\n                result = helper(num % 1000) + THOUSANDS[i] + \" \" + result\n            num //= 1000\n            i += 1\n        return result.strip()", "java": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n    private final String[] LESS_THAN_20 = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\n    private final String[] TENS = {\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\n    private final String[] THOUSANDS = {\"\", \"Thousand\", \"Million\", \"Billion\"};\n\n    public String numberToWords(int num) {\n        if (num == 0) return \"Zero\";\n        StringBuilder result = new StringBuilder();\n        int i = 0;\n        while (num > 0) {\n            if (num % 1000 != 0) {\n                result.insert(0, helper(num % 1000) + THOUSANDS[i] + \" \");\n            }\n            num /= 1000;\n            i++;\n        }\n        return result.toString().trim();\n    }\n\n    private String helper(int num) {\n        if (num == 0) {\n            return \"\";\n        } else if (num < 20) {\n            return LESS_THAN_20[num] + \" \";\n        } else if (num < 100) {\n            return TENS[num / 10] + \" \" + helper(num % 10);\n        } else {\n            return LESS_THAN_20[num / 100] + \" Hundred \" + helper(num % 100);\n        }\n    }\n}", "cpp": "#include <string>\n#include <vector>\n\nclass Solution {\npublic:\n    std::string numberToWords(int num) {\n        if (num == 0) return \"Zero\";\n        std::string result;\n        int i = 0;\n        while (num > 0) {\n            if (num % 1000 != 0) {\n                result = helper(num % 1000) + THOUSANDS[i] + \" \" + result;\n            }\n            num /= 1000;\n            i++;\n        }\n        return trim(result);\n    }\n\nprivate:\n    std::vector<std::string> LESS_THAN_20 = {\n        \"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"\n    };\n    std::vector<std::string> TENS = {\n        \"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"\n    };\n    std::vector<std::string> THOUSANDS = {\n        \"\", \"Thousand\", \"Million\", \"Billion\"\n    };\n\n    std::string helper(int num) {\n        if (num == 0) {\n            return \"\";\n        } else if (num < 20) {\n            return LESS_THAN_20[num] + \" \";\n        } else if (num < 100) {\n            return TENS[num / 10] + \" \" + helper(num % 10);\n        } else {\n            return LESS_THAN_20[num / 100] + \" Hundred \" + helper(num % 100);\n        }\n    }\n\n    std::string trim(const std::string& str) {\n        return str.substr(0, str.find_last_not_of(' ') + 1);\n    }\n};", "javascript": "class Solution {\n    numberToWords(num) {\n        if (num === 0) return \"Zero\";\n\n        const LESS_THAN_20 = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"];\n        const TENS = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"];\n        const THOUSANDS = [\"\", \"Thousand\", \"Million\", \"Billion\"];\n\n        function helper(num) {\n            if (num === 0) {\n                return \"\";\n            } else if (num < 20) {\n                return LESS_THAN_20[num] + \" \";\n            } else if (num < 100) {\n                return TENS[Math.floor(num / 10)] + \" \" + helper(num % 10);\n            } else {\n                return LESS_THAN_20[Math.floor(num / 100)] + \" Hundred \" + helper(num % 100);\n            }\n        }\n\n        let result = \"\";\n        let i = 0;\n        while (num > 0) {\n            if (num % 1000 !== 0) {\n                result = helper(num % 1000) + THOUSANDS[i] + \" \" + result;\n            }\n            num = Math.floor(num / 1000);\n            i++;\n        }\n        return result.trim();\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/274", "prompt": "Given an array of integers `citations` where `citations[i]` is the number of citations a researcher received for their `ith` paper, return _the researcher's h-index_.\n\nAccording to the [definition of h-index on Wikipedia](https://en.wikipedia.org/wiki/H-index): The h-index is defined as the maximum value of `h` such that the given researcher has published at least `h` papers that have each been cited at least `h` times.\n\n**Example 1:**\n\n**Input:** citations = \\[3,0,6,1,5\\]\n**Output:** 3\n**Explanation:** \\[3,0,6,1,5\\] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively.\nSince the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.\n\n**Example 2:**\n\n**Input:** citations = \\[1,3,1\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `n == citations.length`\n*   `1 <= n <= 5000`\n*   `0 <= citations[i] <= 1000`", "entry_point": "h_index", "canonical_solutions": {"python": "def hIndex(citations: List[int]) -> int:\n    citations.sort(reverse=True)\n    h = 0\n    for i, citation in enumerate(citations):\n        if citation >= i + 1:\n            h = i + 1\n        else:\n            break\n    return h", "java": "public int hIndex(int[] citations) {\n    Arrays.sort(citations);\n    int h = 0;\n    for (int i = citations.length - 1; i >= 0; i--) {\n        int rank = citations.length - i;\n        if (citations[i] >= rank) {\n            h = rank;\n        } else {\n            break;\n        }\n    }\n    return h;\n}", "cpp": "int hIndex(vector<int>& citations) {\n    sort(citations.begin(), citations.end(), greater<int>());\n    int h = 0;\n    for (int i = 0; i < citations.size(); ++i) {\n        if (citations[i] >= i + 1) {\n            h = i + 1;\n        } else {\n            break;\n        }\n    }\n    return h;\n}", "javascript": "function hIndex(citations) {\n    citations.sort((a, b) => b - a);\n    let h = 0;\n    for (let i = 0; i < citations.length; i++) {\n        if (citations[i] >= i + 1) {\n            h = i + 1;\n        } else {\n            break;\n        }\n    }\n    return h;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/275", "prompt": "Given an array of integers `citations` where `citations[i]` is the number of citations a researcher received for their `ith` paper and `citations` is sorted in **ascending order**, return _the researcher's h-index_.\n\nAccording to the [definition of h-index on Wikipedia](https://en.wikipedia.org/wiki/H-index): The h-index is defined as the maximum value of `h` such that the given researcher has published at least `h` papers that have each been cited at least `h` times.\n\nYou must write an algorithm that runs in logarithmic time.\n\n**Example 1:**\n\n**Input:** citations = \\[0,1,3,5,6\\]\n**Output:** 3\n**Explanation:** \\[0,1,3,5,6\\] means the researcher has 5 papers in total and each of them had received 0, 1, 3, 5, 6 citations respectively.\nSince the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.\n\n**Example 2:**\n\n**Input:** citations = \\[1,2,100\\]\n**Output:** 2\n\n**Constraints:**\n\n*   `n == citations.length`\n*   `1 <= n <= 105`\n*   `0 <= citations[i] <= 1000`\n*   `citations` is sorted in **ascending order**.", "entry_point": "h_index_ii", "canonical_solutions": {"python": "def hIndex(citations: List[int]) -> int:\n    n = len(citations)\n    left, right = 0, n - 1\n\n    while left <= right:\n        mid = left + (right - left) // 2\n        if citations[mid] == n - mid:\n            return n - mid\n        elif citations[mid] < n - mid:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return n - left", "java": "public int hIndex(int[] citations) {\n    int n = citations.length;\n    int left = 0, right = n - 1;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (citations[mid] == n - mid) {\n            return n - mid;\n        } else if (citations[mid] < n - mid) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return n - left;\n}", "cpp": "int hIndex(vector<int>& citations) {\n    int n = citations.size();\n    int left = 0, right = n - 1;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (citations[mid] == n - mid) {\n            return n - mid;\n        } else if (citations[mid] < n - mid) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return n - left;\n}", "javascript": "function hIndex(citations) {\n    const n = citations.length;\n    let left = 0, right = n - 1;\n\n    while (left <= right) {\n        const mid = left + Math.floor((right - left) / 2);\n        if (citations[mid] === n - mid) {\n            return n - mid;\n        } else if (citations[mid] < n - mid) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return n - left;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/276", "prompt": "You are painting a fence of `n` posts with `k` different colors. You must paint the posts following these rules:\n\n*   Every post must be painted **exactly one** color.\n*   There **cannot** be three or more **consecutive** posts with the same color.\n\nGiven the two integers `n` and `k`, return _the **number of ways** you can paint the fence_.\n\n**Example 1:**\n\n**Input:** n = 3, k = 2\n**Output:** 6\n**Explanation:** All the possibilities are shown.\nNote that painting all the posts red or all the posts green is invalid because there cannot be three posts in a row with the same color.\n\n**Example 2:**\n\n**Input:** n = 1, k = 1\n**Output:** 1\n\n**Example 3:**\n\n**Input:** n = 7, k = 2\n**Output:** 42\n\n**Constraints:**\n\n*   `1 <= n <= 50`\n*   `1 <= k <= 105`\n*   The testcases are generated such that the answer is in the range `[0, 231 - 1]` for the given `n` and `k`.", "entry_point": "paint_fence", "canonical_solutions": {"python": "def numWays(n, k):\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n    same = k\n    different = k * (k - 1)\n    for i in range(2, n):\n        temp = different\n        different = (same + different) * (k - 1)\n        same = temp\n    return same + different", "java": "public int numWays(int n, int k) {\n    if (n == 0) return 0;\n    if (n == 1) return k;\n    int same = k;\n    int different = k * (k - 1);\n    for (int i = 2; i < n; ++i) {\n        int temp = different;\n        different = (same + different) * (k - 1);\n        same = temp;\n    }\n    return same + different;\n}", "cpp": "int numWays(int n, int k) {\n    if (n == 0) return 0;\n    if (n == 1) return k;\n    int same = k;\n    int different = k * (k - 1);\n    for (int i = 2; i < n; ++i) {\n        int temp = different;\n        different = (same + different) * (k - 1);\n        same = temp;\n    }\n    return same + different;\n}", "javascript": "function numWays(n, k) {\n    if (n === 0) return 0;\n    if (n === 1) return k;\n\n    let same = k;\n    let different = k * (k - 1);\n    for (let i = 2; i < n; ++i) {\n        const temp = different;\n        different = (same + different) * (k - 1);\n        same = temp;\n    }\n    return same + different;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/277", "prompt": "Suppose you are at a party with `n` people labeled from `0` to `n - 1` and among them, there may exist one celebrity. The definition of a celebrity is that all the other `n - 1` people know the celebrity, but the celebrity does not know any of them.\n\nNow you want to find out who the celebrity is or verify that there is not one. You are only allowed to ask questions like: \"Hi, A. Do you know B? \" to get information about whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).\n\nYou are given a helper function `bool knows(a, b)` that tells you whether `a` knows `b`. Implement a function `int findCelebrity(n)`. There will be exactly one celebrity if they are at the party.\n\nReturn _the celebrity's label if there is a celebrity at the party_. If there is no celebrity, return `-1`.\n\n**Example 1:**\n\n**Input:** graph = \\[\\[1,1,0\\],\\[0,1,0\\],\\[1,1,1\\]\\]\n**Output:** 1\n**Explanation:** There are three persons labeled with 0, 1 and 2. graph\\[i\\]\\[j\\] = 1 means person i knows person j, otherwise graph\\[i\\]\\[j\\] = 0 means person i does not know person j. The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.\n\n**Example 2:**\n\n**Input:** graph = \\[\\[1,0,1\\],\\[1,1,0\\],\\[0,1,1\\]\\]\n**Output:** -1\n**Explanation:** There is no celebrity.\n\n**Constraints:**\n\n*   `n == graph.length == graph[i].length`\n*   `2 <= n <= 100`\n*   `graph[i][j]` is `0` or `1`.\n*   `graph[i][i] == 1`\n\n**Follow up:** If the maximum number of allowed calls to the API `knows` is `3 * n`, could you find a solution without exceeding the maximum number of calls?", "entry_point": "find_the_celebrity", "canonical_solutions": {"python": "def knows(a: int, b:int) -> bool:\n    pass\n\ndef findCelebrity(n: int) -> int:\n    candidate = 0\n    for i in range(1, n):\n        if knows(candidate, i):\n            candidate = i\n    \n    for i in range(n):\n        if i != candidate and (knows(candidate, i) or not knows(i, candidate)):\n            return -1\n    return candidate", "java": "public boolean knows(int a, int b);\n\npublic int findCelebrity(int n) {\n    int candidate = 0;\n    for (int i = 1; i < n; i++) {\n        if (knows(candidate, i)) {\n            candidate = i;\n        }\n    }\n    \n    for (int i = 0; i < n; i++) {\n        if (i != candidate && (knows(candidate, i) || !knows(i, candidate))) {\n            return -1;\n        }\n    }\n    return candidate;\n}", "cpp": "bool knows(int a, int b);\n\nint findCelebrity(int n) {\n    int candidate = 0;\n    for (int i = 1; i < n; i++) {\n        if (knows(candidate, i)) {\n            candidate = i;\n        }\n    }\n    \n    for (int i = 0; i < n; i++) {\n        if (i != candidate && (knows(candidate, i) || !knows(i, candidate))) {\n            return -1;\n        }\n    }\n    return candidate;\n}", "javascript": "function knows(a, b) {\n    // Implementation not shown\n}\n\nfunction findCelebrity(n) {\n    let candidate = 0;\n    for (let i = 1; i < n; i++) {\n        if (knows(candidate, i)) {\n            candidate = i;\n        }\n    }\n\n    for (let i = 0; i < n; i++) {\n        if (i !== candidate && (knows(candidate, i) || !knows(i, candidate))) {\n            return -1;\n        }\n    }\n    return candidate;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/278", "prompt": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\n\nSuppose you have `n` versions `[1, 2, ..., n]` and you want to find out the first bad one, which causes all the following ones to be bad.\n\nYou are given an API `bool isBadVersion(version)` which returns whether `version` is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\n\n**Example 1:**\n\n**Input:** n = 5, bad = 4\n**Output:** 4\n**Explanation:**\ncall isBadVersion(3) -> false\ncall isBadVersion(5) -> true\ncall isBadVersion(4) -> true\nThen 4 is the first bad version.\n\n**Example 2:**\n\n**Input:** n = 1, bad = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= bad <= n <= 231 - 1`", "entry_point": "first_bad_version", "canonical_solutions": {"python": "def first_bad_version(n):\n    left, right = 1, n\n    while left < right:\n        mid = left + (right - left) // 2\n        if is_bad_version(mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left", "java": "public int firstBadVersion(int n) {\n    int left = 1;\n    int right = n;\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (isBadVersion(mid)) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return left;\n}", "cpp": "int firstBadVersion(int n) {\n    int left = 1;\n    int right = n;\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (isBadVersion(mid)) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return left;\n}", "javascript": "function firstBadVersion(n) {\n    let left = 1;\n    let right = n;\n    while (left < right) {\n        let mid = Math.floor(left + (right - left) / 2);\n        if (isBadVersion(mid)) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return left;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/279", "prompt": "Given an integer `n`, return _the least number of perfect square numbers that sum to_ `n`.\n\nA **perfect square** is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, `1`, `4`, `9`, and `16` are perfect squares while `3` and `11` are not.\n\n**Example 1:**\n\n**Input:** n = 12\n**Output:** 3\n**Explanation:** 12 = 4 + 4 + 4.\n\n**Example 2:**\n\n**Input:** n = 13\n**Output:** 2\n**Explanation:** 13 = 4 + 9.\n\n**Constraints:**\n\n*   `1 <= n <= 104`", "entry_point": "perfect_squares", "canonical_solutions": {"python": "def numSquares(n):\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    \n    for i in range(1, n + 1):\n        j = 1\n        while j * j <= i:\n            dp[i] = min(dp[i], dp[i - j * j] + 1)\n            j += 1\n            \n    return dp[n]", "java": "public int numSquares(int n) {\n    int[] dp = new int[n + 1];\n    Arrays.fill(dp, Integer.MAX_VALUE);\n    dp[0] = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j * j <= i; j++) {\n            dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n        }\n    }\n    \n    return dp[n];\n}", "cpp": "#include <vector>\n#include <limits>\n#include <cmath>\n\nint numSquares(int n) {\n    std::vector<int> dp(n + 1, std::numeric_limits<int>::max());\n    dp[0] = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j * j <= i; j++) {\n            dp[i] = std::min(dp[i], dp[i - j * j] + 1);\n        }\n    }\n    \n    return dp[n];\n}", "javascript": "function numSquares(n) {\n    const dp = new Array(n + 1).fill(Infinity);\n    dp[0] = 0;\n\n    for (let i = 1; i <= n; i++) {\n        for (let j = 1; j * j <= i; j++) {\n            dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n        }\n    }\n\n    return dp[n];\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/280", "prompt": "Given an integer array `nums`, reorder it such that `nums[0] <= nums[1] >= nums[2] <= nums[3]...`.\n\nYou may assume the input array always has a valid answer.\n\n**Example 1:**\n\n**Input:** nums = \\[3,5,2,1,6,4\\]\n**Output:** \\[3,5,1,6,2,4\\]\n**Explanation:** \\[1,6,2,5,3,4\\] is also accepted.\n\n**Example 2:**\n\n**Input:** nums = \\[6,6,5,6,3,8\\]\n**Output:** \\[6,6,5,6,3,8\\]\n\n**Constraints:**\n\n*   `1 <= nums.length <= 5 * 104`\n*   `0 <= nums[i] <= 104`\n*   It is guaranteed that there will be an answer for the given input `nums`.\n\n**Follow up:** Could you solve the problem in `O(n)` time complexity?", "entry_point": "wiggle_sort", "canonical_solutions": {"python": "def wiggleSort(nums):\n    for i in range(1, len(nums)):\n        if (i % 2 == 0 and nums[i] > nums[i-1]) or (i % 2 == 1 and nums[i] < nums[i-1]):\n            nums[i], nums[i-1] = nums[i-1], nums[i]", "java": "public void wiggleSort(int[] nums) {\n    for (int i = 1; i < nums.length; i++) {\n        if (i % 2 == 0 && nums[i] > nums[i-1] || i % 2 == 1 && nums[i] < nums[i-1]) {\n            int temp = nums[i];\n            nums[i] = nums[i-1];\n            nums[i-1] = temp;\n        }\n    }\n}", "cpp": "void wiggleSort(vector<int>& nums) {\n    for (int i = 1; i < nums.size(); i++) {\n        if (i%2 == 0 && nums[i] > nums[i-1] || i%2 == 1 && nums[i] < nums[i-1]) {\n            swap(nums[i], nums[i-1]);\n        }\n    }\n}", "javascript": "function wiggleSort(nums) {\n    for (let i = 1; i < nums.length; i++) {\n        if (i % 2 === 0 && nums[i] > nums[i-1] || i % 2 === 1 && nums[i] < nums[i-1]) {\n            [nums[i], nums[i-1]] = [nums[i-1], nums[i]];\n        }\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/281", "prompt": "Given two vectors of integers `v1` and `v2`, implement an iterator to return their elements alternately.\n\nImplement the `ZigzagIterator` class:\n\n*   `ZigzagIterator(List v1, List v2)` initializes the object with the two vectors `v1` and `v2`.\n*   `boolean hasNext()` returns `true` if the iterator still has elements, and `false` otherwise.\n*   `int next()` returns the current element of the iterator and moves the iterator to the next element.\n\n**Example 1:**\n\n**Input:** v1 = \\[1,2\\], v2 = \\[3,4,5,6\\]\n**Output:** \\[1,3,2,4,5,6\\]\n**Explanation:** By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: \\[1,3,2,4,5,6\\].\n\n**Example 2:**\n\n**Input:** v1 = \\[1\\], v2 = \\[\\]\n**Output:** \\[1\\]\n\n**Example 3:**\n\n**Input:** v1 = \\[\\], v2 = \\[1\\]\n**Output:** \\[1\\]\n\n**Constraints:**\n\n*   `0 <= v1.length, v2.length <= 1000`\n*   `1 <= v1.length + v2.length <= 2000`\n*   `-231 <= v1[i], v2[i] <= 231 - 1`\n\n**Follow up:** What if you are given `k` vectors? How well can your code be extended to such cases?\n\n**Clarification for the follow-up question:**\n\nThe \"Zigzag \" order is not clearly defined and is ambiguous for `k > 2` cases. If \"Zigzag \" does not look right to you, replace \"Zigzag \" with \"Cyclic \".\n\n**Follow-up Example:**\n\n**Input:** v1 = \\[1,2,3\\], v2 = \\[4,5,6,7\\], v3 = \\[8,9\\]\n**Output:** \\[1,4,8,2,5,9,3,6,7\\]", "entry_point": "zigzag_iterator", "canonical_solutions": {"python": "class ZigzagIterator:\n\n    def __init__(self, v1: List[int], v2: List[int]):\n        self.v1, self.v2 = v1, v2\n        self.index1, self.index2 = 0, 0\n\n    def next(self) -> int:\n        if self.index1 < len(self.v1) and (self.index1 <= self.index2 or self.index2 == len(self.v2)):\n            result = self.v1[self.index1]\n            self.index1 += 1\n            return result\n        if self.index2 < len(self.v2) and (self.index2 < self.index1 or self.index1 == len(self.v1)):\n            result = self.v2[self.index2]\n            self.index2 += 1\n            return result\n\n    def hasNext(self) -> bool:\n        return self.index1 < len(self.v1) or self.index2 < len(self.v2)", "java": "import java.util.List;\nimport java.util.ArrayList;\n\npublic class ZigzagIterator {\n    private List<Integer> list1;\n    private List<Integer> list2;\n    private boolean isList1;\n    private int index1, index2;\n\n    public ZigzagIterator(List<Integer> v1, List<Integer> v2) {\n        list1 = v1;\n        list2 = v2;\n        isList1 = list1.size() > 0;\n        index1 = 0;\n        index2 = 0;\n    }\n\n    public int next() {\n        if (isList1 && index1 < list1.size()) {\n            isList1 = !isList1;\n            return list1.get(index1++);\n        } else {\n            isList1 = !isList1;\n            return list2.get(index2++);\n        }\n    }\n\n    public boolean hasNext() {\n        return index1 < list1.size() || index2 < list2.size();\n    }\n}", "cpp": "class ZigzagIterator {\npublic:\n    ZigzagIterator(vector<int>& v1, vector<int>& v2): curr_v(NULL), index1(0), index2(0) {\n        if (!v1.empty()) {\n            curr_v = &v1;\n            other_v = &v2;\n        } else if (!v2.empty()) {\n            curr_v = &v2;\n            other_v = &v1;\n        }\n    }\n\n    int next() {\n        int result = (*curr_v)[index1++];\n        if (index2 < other_v->size()) {\n            swap(curr_v, other_v);\n            swap(index1, index2);\n        }\n        return result;\n    }\n\n    bool hasNext() {\n        return curr_v && index1 < curr_v->size();\n    }\n\nprivate:\n    vector<int> *curr_v;\n    vector<int> *other_v;\n    int index1;\n    int index2;\n};", "javascript": "class ZigzagIterator {\n    constructor(v1, v2) {\n        this.v1 = v1;\n        this.v2 = v2;\n        this.index1 = 0;\n        this.index2 = 0;\n    }\n    \n    next() {\n        if (this.index1 < this.v1.length && (this.index1 <= this.index2 || this.index2 == this.v2.length)) {\n            return this.v1[this.index1++];\n        }\n        if (this.index2 < this.v2.length && (this.index2 < this.index1 || this.index1 == this.v1.length)) {\n            return this.v2[this.index2++];\n        }\n    }\n\n    hasNext() {\n        return this.index1 < this.v1.length || this.index2 < this.v2.length;\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/282", "prompt": "Given a string `num` that contains only digits and an integer `target`, return _**all possibilities** to insert the binary operators_ `'+'`_,_ `'-'`_, and/or_ `'*'` _between the digits of_ `num` _so that the resultant expression evaluates to the_ `target` _value_.\n\nNote that operands in the returned expressions **should not** contain leading zeros.\n\n**Example 1:**\n\n**Input:** num =  \"123 \", target = 6\n**Output:** \\[ \"1\\*2\\*3 \", \"1+2+3 \"\\]\n**Explanation:** Both  \"1\\*2\\*3 \" and  \"1+2+3 \" evaluate to 6.\n\n**Example 2:**\n\n**Input:** num =  \"232 \", target = 8\n**Output:** \\[ \"2\\*3+2 \", \"2+3\\*2 \"\\]\n**Explanation:** Both  \"2\\*3+2 \" and  \"2+3\\*2 \" evaluate to 8.\n\n**Example 3:**\n\n**Input:** num =  \"3456237490 \", target = 9191\n**Output:** \\[\\]\n**Explanation:** There are no expressions that can be created from  \"3456237490 \" to evaluate to 9191.\n\n**Constraints:**\n\n*   `1 <= num.length <= 10`\n*   `num` consists of only digits.\n*   `-231 <= target <= 231 - 1`", "entry_point": "expression_add_operators", "canonical_solutions": {"python": "from typing import List\n\ndef addOperators(num: str, target: int) -> List[str]:\n    def helper(num, target, pos, currVal, prevVal, currExpr):\n        if pos == len(num):\n            if currVal == target:\n                res.append(currExpr)\n            return\n\n        for i in range(pos, len(num)):\n            if i != pos and num[pos] == '0':\n                break\n\n            val = int(num[pos:i + 1])\n            if pos == 0:\n                helper(num, target, i + 1, val, val, currExpr + num[pos:i + 1])\n            else:\n                helper(num, target, i + 1, currVal + val, val, currExpr + \"+\" + num[pos:i + 1])\n                helper(num, target, i + 1, currVal - val, -val, currExpr + \"-\" + num[pos:i + 1])\n                helper(num, target, i + 1, currVal - prevVal + prevVal * val, prevVal * val, currExpr + \"*\" + num[pos:i + 1])\n\n    res = []\n    helper(num, target, 0, 0, 0, \"\")\n    return res", "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> addOperators(String num, int target) {\n    List<String> res = new ArrayList<>();\n    helper(num, target, 0, 0, 0, \"\", res);\n    return res;\n}\n\nprivate void helper(String num, int target, int pos, long currVal, long prevVal, String currExpr, List<String> res) {\n    if (pos == num.length()) {\n        if (currVal == target) {\n            res.add(currExpr);\n        }\n        return;\n    }\n\n    for (int i = pos; i < num.length(); ++i) {\n        if (i != pos && num.charAt(pos) == '0') break;\n        long val = Long.parseLong(num.substring(pos, i + 1));\n        if (pos == 0) {\n            helper(num, target, i + 1, val, val, currExpr + num.substring(pos, i + 1), res);\n        } else {\n            helper(num, target, i + 1, currVal + val, val, currExpr + \"+\" + num.substring(pos, i + 1), res);\n            helper(num, target, i + 1, currVal - val, -val, currExpr + \"-\" + num.substring(pos, i + 1), res);\n            helper(num, target, i + 1, currVal - prevVal + prevVal * val, prevVal * val, currExpr + \"*\" + num.substring(pos, i + 1), res);\n        }\n    }\n}", "cpp": "#include <string>\n#include <vector>\n\nvoid helper(const std::string &num, int target, int pos, long long currVal, long long prevVal, std::string currExpr, std::vector<std::string> &res) {\n    if (pos == num.size()) {\n        if (currVal == target) {\n            res.push_back(currExpr);\n        }\n        return;\n    }\n\n    for (int i = pos; i < num.size(); ++i) {\n        if (i != pos && num[pos] == '0') break;\n        long long val = std::stoll(num.substr(pos, i - pos + 1));\n        if (pos == 0) {\n            helper(num, target, i + 1, val, val, currExpr + num.substr(pos, i - pos + 1), res);\n        } else {\n            helper(num, target, i + 1, currVal + val, val, currExpr + \"+\" + num.substr(pos, i - pos + 1), res);\n            helper(num, target, i + 1, currVal - val, -val, currExpr + \"-\" + num.substr(pos, i - pos + 1), res);\n            helper(num, target, i + 1, currVal - prevVal + prevVal * val, prevVal * val, currExpr + \"*\" + num.substr(pos, i - pos + 1), res);\n        }\n    }\n}\n\nstd::vector<std::string> addOperators(std::string num, int target) {\n    std::vector<std::string> res;\n    helper(num, target, 0, 0, 0, \"\", res);\n    return res;\n}", "javascript": "var addOperators = function(num, target) {\n    const res = [];\n    const helper = (num, target, pos, currVal, prevVal, currExpr) => {\n        if (pos === num.length) {\n            if (currVal === target) {\n                res.push(currExpr);\n            }\n            return;\n        }\n\n        for (let i = pos; i < num.length; ++i) {\n            if (i !== pos && num[pos] === '0') break;\n\n            const val = parseInt(num.substring(pos, i + 1));\n            if (pos === 0) {\n                helper(num, target, i + 1, val, val, currExpr + num.substring(pos, i + 1));\n            } else {\n                helper(num, target, i + 1, currVal + val, val, currExpr + \"+\" + num.substring(pos, i + 1));\n                helper(num, target, i + 1, currVal - val, -val, currExpr + \"-\" + num.substring(pos, i + 1));\n                helper(num, target, i + 1, currVal - prevVal + prevVal * val, prevVal * val, currExpr + \"*\" + num.substring(pos, i + 1));\n            }\n        }\n    }\n\n    helper(num, target, 0, 0, 0, \"\");\n    return res;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/283", "prompt": "Given an integer array `nums`, move all `0`'s to the end of it while maintaining the relative order of the non-zero elements.\n\n**Note** that you must do this in-place without making a copy of the array.\n\n**Example 1:**\n\n**Input:** nums = \\[0,1,0,3,12\\]\n**Output:** \\[1,3,12,0,0\\]\n\n**Example 2:**\n\n**Input:** nums = \\[0\\]\n**Output:** \\[0\\]\n\n**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-231 <= nums[i] <= 231 - 1`\n\n**Follow up:** Could you minimize the total number of operations done?", "entry_point": "move_zeroes", "canonical_solutions": {"python": "def moveZeroes(nums):\n    index = 0\n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[index] = nums[i]\n            index += 1\n    for i in range(index, len(nums)):\n        nums[i] = 0", "java": "public void moveZeroes(int[] nums) {\n    int index = 0;\n    for (int i = 0; i < nums.length; i++) {\n        if (nums[i] != 0) {\n            nums[index++] = nums[i];\n        }\n    }\n    for (int i = index; i < nums.length; i++) {\n        nums[i] = 0;\n    }\n}", "cpp": "void moveZeroes(vector<int>& nums) {\n    int index = 0;\n    for (int i = 0; i < nums.size(); i++) {\n        if (nums[i] != 0) {\n            nums[index++] = nums[i];\n        }\n    }\n    for (int i = index; i < nums.size(); i++) {\n        nums[i] = 0;\n    }\n}", "javascript": "function moveZeroes(nums) {\n    let index = 0;\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] !== 0) {\n            nums[index++] = nums[i];\n        }\n    }\n    for (let i = index; i < nums.length; i++) {\n        nums[i] = 0;\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/284", "prompt": "Design an iterator that supports the `peek` operation on an existing iterator in addition to the `hasNext` and the `next` operations.\n\nImplement the `PeekingIterator` class:\n\n*   `PeekingIterator(Iterator nums)` Initializes the object with the given integer iterator `iterator`.\n*   `int next()` Returns the next element in the array and moves the pointer to the next element.\n*   `boolean hasNext()` Returns `true` if there are still elements in the array.\n*   `int peek()` Returns the next element in the array **without** moving the pointer.\n\n**Note:** Each language may have a different implementation of the constructor and `Iterator`, but they all support the `int next()` and `boolean hasNext()` functions.\n\n**Example 1:**\n\n**Input**\n\\[ \"PeekingIterator \",  \"next \",  \"peek \",  \"next \",  \"next \",  \"hasNext \"\\]\n\\[\\[\\[1, 2, 3\\]\\], \\[\\], \\[\\], \\[\\], \\[\\], \\[\\]\\]\n**Output**\n\\[null, 1, 2, 2, 3, false\\]\n\n**Explanation**\nPeekingIterator peekingIterator = new PeekingIterator(\\[1, 2, 3\\]); // \\[**1**,2,3\\]\npeekingIterator.next();    // return 1, the pointer moves to the next element \\[1,**2**,3\\].\npeekingIterator.peek();    // return 2, the pointer does not move \\[1,**2**,3\\].\npeekingIterator.next();    // return 2, the pointer moves to the next element \\[1,2,**3**\\]\npeekingIterator.next();    // return 3, the pointer moves to the next element \\[1,2,3\\]\npeekingIterator.hasNext(); // return False\n\n**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `1 <= nums[i] <= 1000`\n*   All the calls to `next` and `peek` are valid.\n*   At most `1000` calls will be made to `next`, `hasNext`, and `peek`.\n\n**Follow up:** How would you extend your design to be generic and work with all types, not just integer?", "entry_point": "peeking_iterator", "canonical_solutions": {"python": "class PeekingIterator:\n    def __init__(self, iterator):\n        self.iterator = iterator\n        self.next_val = next(self.iterator, None)\n\n    def peek(self):\n        return self.next_val\n\n    def next(self):\n        current_val = self.next_val\n        self.next_val = next(self.iterator, None)\n        return current_val\n\n    def hasNext(self):\n        return self.next_val is not None", "java": "import java.util.Iterator;\n\nclass PeekingIterator implements Iterator<Integer> {\n    private Iterator<Integer> iterator;\n    private Integer next;\n\n    public PeekingIterator(Iterator<Integer> iterator) {\n        this.iterator = iterator;\n        if (iterator.hasNext()) {\n            next = iterator.next();\n        }\n    }\n\n    public Integer peek() {\n        return next;\n    }\n\n    @Override\n    public Integer next() {\n        Integer current = next;\n        next = iterator.hasNext() ? iterator.next() : null;\n        return current;\n    }\n\n    @Override\n    public boolean hasNext() {\n        return next != null;\n    }\n}", "cpp": "#include <iterator>\n\nclass PeekingIterator : public std::iterator<std::input_iterator_tag, int> {\npublic:\n    PeekingIterator(std::vector<int>::iterator it, std::vector<int>::iterator end) : iterator_(it), end_(end) {\n        if (iterator_ != end_) {\n            next_val_ = *iterator_;\n            ++iterator_;\n        }\n    }\n\n    int peek() {\n        return next_val_;\n    }\n\n    int next() {\n        int current_val = next_val_;\n        if (iterator_ != end_) {\n            next_val_ = *iterator_;\n            ++iterator_;\n        }\n        return current_val;\n    }\n\n    bool hasNext() const {\n        return iterator_ != end_;\n    }\n\nprivate:\n    std::vector<int>::iterator iterator_;\n    std::vector<int>::iterator end_;\n    int next_val_;\n};", "javascript": "class PeekingIterator {\n    constructor(iterator) {\n        this.iterator = iterator[Symbol.iterator]();\n        this.nextValue = this.iterator.next();\n    }\n\n    peek() {\n        return this.nextValue.value;\n    }\n\n    next() {\n        const currentValue = this.nextValue.value;\n        this.nextValue = this.iterator.next();\n        return currentValue;\n    }\n\n    hasNext() {\n        return !this.nextValue.done;\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/285", "prompt": "Given the `root` of a binary search tree and a node `p` in it, return _the in-order successor of that node in the BST_. If the given node has no in-order successor in the tree, return `null`.\n\nThe successor of a node `p` is the node with the smallest key greater than `p.val`.\n\n**Example 1:**\n\n**Input:** root = \\[2,1,3\\], p = 1\n**Output:** 2\n**Explanation:** 1's in-order successor node is 2. Note that both p and the return value is of TreeNode type.\n\n**Example 2:**\n\n**Input:** root = \\[5,3,6,2,4,null,null,1\\], p = 6\n**Output:** null\n**Explanation:** There is no in-order successor of the current node, so the answer is `null`.\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-105 <= Node.val <= 105`\n*   All Nodes will have unique values.", "entry_point": "inorder_successor_in_bst", "canonical_solutions": {"python": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef inorder_successor(root: TreeNode, p: TreeNode) -> TreeNode:\n    successor = None\n    while root:\n        if root.val > p.val:\n            successor = root\n            root = root.left\n        else:\n            root = root.right\n    return successor", "java": "public class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n}\n\npublic TreeNode inorderSuccessor(TreeNode root, TreeNode p) {\n    TreeNode successor = null;\n    while (root != null) {\n        if (root.val > p.val) {\n            successor = root;\n            root = root.left;\n        } else {\n            root = root.right;\n        }\n    }\n    return successor;\n}", "cpp": "struct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n};\n\nTreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {\n    TreeNode* successor = nullptr;\n    while (root != nullptr) {\n        if (root->val > p->val) {\n            successor = root;\n            root = root->left;\n        } else {\n            root = root->right;\n        }\n    }\n    return successor;\n}", "javascript": "class TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction inorderSuccessor(root, p) {\n    let successor = null;\n    while (root !== null) {\n        if (root.val > p.val) {\n            successor = root;\n            root = root.left;\n        } else {\n            root = root.right;\n        }\n    }\n    return successor;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/286", "prompt": "You are given an `m x n` grid `rooms` initialized with these three possible values.\n\n*   `-1` A wall or an obstacle.\n*   `0` A gate.\n*   `INF` Infinity means an empty room. We use the value `231 - 1 = 2147483647` to represent `INF` as you may assume that the distance to a gate is less than `2147483647`.\n\nFill each empty room with the distance to _its nearest gate_. If it is impossible to reach a gate, it should be filled with `INF`.\n\n**Example 1:**\n\n**Input:** rooms = \\[\\[2147483647,-1,0,2147483647\\],\\[2147483647,2147483647,2147483647,-1\\],\\[2147483647,-1,2147483647,-1\\],\\[0,-1,2147483647,2147483647\\]\\]\n**Output:** \\[\\[3,-1,0,1\\],\\[2,2,1,-1\\],\\[1,-1,2,-1\\],\\[0,-1,3,4\\]\\]\n\n**Example 2:**\n\n**Input:** rooms = \\[\\[-1\\]\\]\n**Output:** \\[\\[-1\\]\\]\n\n**Constraints:**\n\n*   `m == rooms.length`\n*   `n == rooms[i].length`\n*   `1 <= m, n <= 250`\n*   `rooms[i][j]` is `-1`, `0`, or `231 - 1`.", "entry_point": "walls_and_gates", "canonical_solutions": {"python": "from collections import deque\n\ndef wallsAndGates(rooms):\n    m, n = len(rooms), len(rooms[0])\n    q = deque()\n    INF = 2147483647\n\n    for i in range(m):\n        for j in range(n):\n            if rooms[i][j] == 0:\n                q.append((i, j))\n\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    while q:\n        i, j = q.popleft()\n\n        for d in directions:\n            ni, nj = i + d[0], j + d[1]\n\n            if 0 <= ni < m and 0 <= nj < n and rooms[ni][nj] == INF:\n                rooms[ni][nj] = rooms[i][j] + 1\n                q.append((ni, nj))", "java": "import java.util.Queue;\nimport java.util.LinkedList;\n\npublic void wallsAndGates(int[][] rooms) {\n    int m = rooms.length;\n    int n = rooms[0].length;\n    Queue<int[]> q = new LinkedList<>();\n    int INF = 2147483647;\n\n    for(int i = 0; i < m; i++) {\n        for(int j = 0; j < n; j++) {\n            if(rooms[i][j] == 0) {\n                q.offer(new int[]{i, j});\n            }\n        }\n    }\n    \n    int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    while(!q.isEmpty()) {\n        int[] cur = q.poll();\n        int i = cur[0];\n        int j = cur[1];\n\n        for(int[] d : directions) {\n            int ni = i + d[0];\n            int nj = j + d[1];\n\n            if(ni >= 0 && ni < m && nj >= 0 && nj < n && rooms[ni][nj] == INF) {\n                rooms[ni][nj] = rooms[i][j] + 1;\n                q.offer(new int[]{ni, nj});\n            }\n        }\n    }\n}", "cpp": "#include <vector>\n#include <queue>\nusing namespace std;\n\nvoid wallsAndGates(vector<vector<int>>& rooms) {\n    const int INF = 2147483647;\n    int m = rooms.size();\n    int n = rooms[0].size();\n    queue<pair<int, int>> q;\n\n    for(int i = 0; i < m; i++) {\n        for(int j = 0; j < n; j++) {\n            if(rooms[i][j] == 0) {\n                q.push(make_pair(i, j));\n            }\n        }\n    }\n\n    int directions[][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    while(!q.empty()) {\n        int i = q.front().first;\n        int j = q.front().second;\n        q.pop();\n\n        for(auto d : directions) {\n            int ni = i + d[0];\n            int nj = j + d[1];\n\n            if(ni >= 0 && ni < m && nj >= 0 && nj < n && rooms[ni][nj] == INF) {\n                rooms[ni][nj] = rooms[i][j] + 1;\n                q.push(make_pair(ni, nj));\n            }\n        }\n    }\n}", "javascript": "function wallsAndGates(rooms) {\n    const m = rooms.length;\n    const n = rooms[0].length;\n    const q = [];\n    const INF = 2147483647;\n    \n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (rooms[i][j] === 0) {\n                q.push([i, j]);\n            }\n        }\n    }\n\n    const directions = [\n        [0, 1],\n        [0, -1],\n        [1, 0],\n        [-1, 0]\n    ];\n\n    while (q.length) {\n        const [i, j] = q.shift();\n\n        directions.forEach(([di, dj]) => {\n            const ni = i + di;\n            const nj = j + dj;\n\n            if (ni >= 0 && ni < m && nj >= 0 && nj < n && rooms[ni][nj] === INF) {\n                rooms[ni][nj] = rooms[i][j] + 1;\n                q.push([ni, nj]);\n            }\n        });\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/287", "prompt": "Given an array of integers `nums` containing `n + 1` integers where each integer is in the range `[1, n]` inclusive.\n\nThere is only **one repeated number** in `nums`, return _this repeated number_.\n\nYou must solve the problem **without** modifying the array `nums` and uses only constant extra space.\n\n**Example 1:**\n\n**Input:** nums = \\[1,3,4,2,2\\]\n**Output:** 2\n\n**Example 2:**\n\n**Input:** nums = \\[3,1,3,4,2\\]\n**Output:** 3\n\n**Constraints:**\n\n*   `1 <= n <= 105`\n*   `nums.length == n + 1`\n*   `1 <= nums[i] <= n`\n*   All the integers in `nums` appear only **once** except for **precisely one integer** which appears **two or more** times.\n\n**Follow up:**\n\n*   How can we prove that at least one duplicate number must exist in `nums`?\n*   Can you solve the problem in linear runtime complexity?", "entry_point": "find_the_duplicate_number", "canonical_solutions": {"python": "def findDuplicate(nums):\n    slow = nums[0]\n    fast = nums[0]\n\n    while True:\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n        if slow == fast:\n            break\n\n    slow = nums[0]\n\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n\n    return slow", "java": "public int findDuplicate(int[] nums) {\n    int slow = nums[0];\n    int fast = nums[0];\n\n    do {\n        slow = nums[slow];\n        fast = nums[nums[fast]];\n    } while (slow != fast);\n\n    slow = nums[0];\n\n    while (slow != fast) {\n        slow = nums[slow];\n        fast = nums[fast];\n    }\n\n    return slow;\n}", "cpp": "int findDuplicate(vector<int>& nums) {\n    int slow = nums[0];\n    int fast = nums[0];\n\n    do {\n        slow = nums[slow];\n        fast = nums[nums[fast]];\n    } while (slow != fast);\n\n    slow = nums[0];\n\n    while (slow != fast) {\n        slow = nums[slow];\n        fast = nums[fast];\n    }\n\n    return slow;\n}", "javascript": "function findDuplicate(nums) {\n    let slow = nums[0];\n    let fast = nums[0];\n\n    do {\n        slow = nums[slow];\n        fast = nums[nums[fast]];\n    } while (slow !== fast);\n\n    slow = nums[0];\n\n    while (slow !== fast) {\n        slow = nums[slow];\n        fast = nums[fast];\n    }\n\n    return slow;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/288", "prompt": "The **abbreviation** of a word is a concatenation of its first letter, the number of characters between the first and last letter, and its last letter. If a word has only two characters, then it is an **abbreviation** of itself.\n\nFor example:\n\n*   `dog --> d1g` because there is one letter between the first letter `'d'` and the last letter `'g'`.\n*   `internationalization --> i18n` because there are 18 letters between the first letter `'i'` and the last letter `'n'`.\n*   `it --> it` because any word with only two characters is an **abbreviation** of itself.\n\nImplement the `ValidWordAbbr` class:\n\n*   `ValidWordAbbr(String[] dictionary)` Initializes the object with a `dictionary` of words.\n*   `boolean isUnique(string word)` Returns `true` if **either** of the following conditions are met (otherwise returns `false`):\n    *   There is no word in `dictionary` whose **abbreviation** is equal to `word`'s **abbreviation**.\n    *   For any word in `dictionary` whose **abbreviation** is equal to `word`'s **abbreviation**, that word and `word` are **the same**.\n\n**Example 1:**\n\n**Input**\n\\[ \"ValidWordAbbr \",  \"isUnique \",  \"isUnique \",  \"isUnique \",  \"isUnique \",  \"isUnique \"\\]\n\\[\\[\\[ \"deer \",  \"door \",  \"cake \",  \"card \"\\]\\], \\[ \"dear \"\\], \\[ \"cart \"\\], \\[ \"cane \"\\], \\[ \"make \"\\], \\[ \"cake \"\\]\\]\n**Output**\n\\[null, false, true, false, true, true\\]\n\n**Explanation**\nValidWordAbbr validWordAbbr = new ValidWordAbbr(\\[ \"deer \",  \"door \",  \"cake \",  \"card \"\\]);\nvalidWordAbbr.isUnique( \"dear \"); // return false, dictionary word  \"deer \" and word  \"dear \" have the same abbreviation  \"d2r \" but are not the same.\nvalidWordAbbr.isUnique( \"cart \"); // return true, no words in the dictionary have the abbreviation  \"c2t \".\nvalidWordAbbr.isUnique( \"cane \"); // return false, dictionary word  \"cake \" and word  \"cane \" have the same abbreviation   \"c2e \" but are not the same.\nvalidWordAbbr.isUnique( \"make \"); // return true, no words in the dictionary have the abbreviation  \"m2e \".\nvalidWordAbbr.isUnique( \"cake \"); // return true, because  \"cake \" is already in the dictionary and no other word in the dictionary has  \"c2e \" abbreviation.\n\n**Constraints:**\n\n*   `1 <= dictionary.length <= 3 * 104`\n*   `1 <= dictionary[i].length <= 20`\n*   `dictionary[i]` consists of lowercase English letters.\n*   `1 <= word.length <= 20`\n*   `word` consists of lowercase English letters.\n*   At most `5000` calls will be made to `isUnique`.", "entry_point": "unique_word_abbreviation", "canonical_solutions": {"python": "class ValidWordAbbr:\n\n    def __init__(self, dictionary):\n        self.word_map = {}\n        for word in dictionary:\n            abbr = self.get_abbreviation(word)\n            if abbr not in self.word_map:\n                self.word_map[abbr] = {word}\n            else:\n                self.word_map[abbr].add(word)\n\n    def isUnique(self, word):\n        abbr = self.get_abbreviation(word)\n        abbr_group = self.word_map.get(abbr, set())\n        return len(abbr_group) == 0 or (len(abbr_group) == 1 and word in abbr_group)\n\n    def get_abbreviation(self, word):\n        n = len(word)\n        return word if n <= 2 else word[0] + str(n - 2) + word[-1]", "java": "import java.util.*;\n\nclass ValidWordAbbr {\n    private Map<String, Set<String>> wordMap;\n\n    public ValidWordAbbr(String[] dictionary) {\n        wordMap = new HashMap<>();\n        for (String word : dictionary) {\n            String abbr = getAbbreviation(word);\n            wordMap.putIfAbsent(abbr, new HashSet<>());\n            wordMap.get(abbr).add(word);\n        }\n    }\n\n    public boolean isUnique(String word) {\n        String abbr = getAbbreviation(word);\n        Set<String> abbrGroup = wordMap.get(abbr);\n        return abbrGroup == null || (abbrGroup.size() == 1 && abbrGroup.contains(word));\n    }\n\n    private String getAbbreviation(String word) {\n        int n = word.length();\n        return n <= 2 ? word : word.charAt(0) + Integer.toString(n - 2) + word.charAt(n - 1);\n    }\n}", "cpp": "#include <string>\n#include <unordered_map>\n\nclass ValidWordAbbr {\npublic:\n    ValidWordAbbr(vector<string>& dictionary) {\n        for (auto& word : dictionary) {\n            string abbr = get_abbreviation(word);\n            word_map[abbr].insert(word);\n        }\n    }\n    \n    bool isUnique(string word) {\n        string abbr = get_abbreviation(word);\n        auto abbr_group = word_map.find(abbr);\n        return abbr_group == word_map.end() || (abbr_group->second.size() == 1 && abbr_group->second.count(word));\n    }\n    \nprivate:\n    unordered_map<string, unordered_set<string>> word_map;\n\n    string get_abbreviation(const string& word) {\n        int n = word.size();\n        return n <= 2 ? word : word.front() + to_string(n - 2) + word.back();\n    }\n};", "javascript": "class ValidWordAbbr {\n    constructor(dictionary) {\n        this.wordMap = new Map();\n        for (let word of dictionary) {\n            let abbr = this.getAbbreviation(word);\n            if (!this.wordMap.has(abbr)) {\n                this.wordMap.set(abbr, new Set([word]));\n            } else {\n                this.wordMap.get(abbr).add(word);\n            }\n        }\n    }\n\n    isUnique(word) {\n        let abbr = this.getAbbreviation(word);\n        let abbrGroup = this.wordMap.get(abbr) || new Set();\n        return abbrGroup.size === 0 || (abbrGroup.size === 1 && abbrGroup.has(word));\n    }\n\n    getAbbreviation(word) {\n        let n = word.length;\n        return n <= 2 ? word : word[0] + (n - 2) + word[n - 1];\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/289", "prompt": "According to [Wikipedia's article](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life): \"The **Game of Life**, also known simply as **Life**, is a cellular automaton devised by the British mathematician John Horton Conway in 1970. \"\n\nThe board is made up of an `m x n` grid of cells, where each cell has an initial state: **live** (represented by a `1`) or **dead** (represented by a `0`). Each cell interacts with its [eight neighbors](https://en.wikipedia.org/wiki/Moore_neighborhood) (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):\n\n1.  Any live cell with fewer than two live neighbors dies as if caused by under-population.\n2.  Any live cell with two or three live neighbors lives on to the next generation.\n3.  Any live cell with more than three live neighbors dies, as if by over-population.\n4.  Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n\nThe next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the `m x n` grid `board`, return _the next state_.\n\n**Example 1:**\n\n**Input:** board = \\[\\[0,1,0\\],\\[0,0,1\\],\\[1,1,1\\],\\[0,0,0\\]\\]\n**Output:** \\[\\[0,0,0\\],\\[1,0,1\\],\\[0,1,1\\],\\[0,1,0\\]\\]\n\n**Example 2:**\n\n**Input:** board = \\[\\[1,1\\],\\[1,0\\]\\]\n**Output:** \\[\\[1,1\\],\\[1,1\\]\\]\n\n**Constraints:**\n\n*   `m == board.length`\n*   `n == board[i].length`\n*   `1 <= m, n <= 25`\n*   `board[i][j]` is `0` or `1`.\n\n**Follow up:**\n\n*   Could you solve it in-place? Remember that the board needs to be updated simultaneously: You cannot update some cells first and then use their updated values to update other cells.\n*   In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches upon the border of the array (i.e., live cells reach the border). How would you address these problems?", "entry_point": "game_of_life", "canonical_solutions": {"python": "def gameOfLife(board):\n    m, n = len(board), len(board[0])\n    result = [[0] * n for _ in range(m)]\n    dirs = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]\n    \n    for i in range(m):\n        for j in range(n):\n            liveNeighbors = 0\n            \n            for dir in dirs:\n                newRow = i + dir[0]\n                newCol = j + dir[1]\n                \n                if newRow >= 0 and newRow < m and newCol >= 0 and newCol < n and board[newRow][newCol] == 1:\n                    liveNeighbors += 1\n            \n            if board[i][j] == 1 and (liveNeighbors == 2 or liveNeighbors == 3):\n                result[i][j] = 1\n            elif board[i][j] == 0 and liveNeighbors == 3:\n                result[i][j] = 1\n                \n    return result", "java": "public int[][] gameOfLife(int[][] board) {\n    int m = board.length;\n    int n = board[0].length;\n    int[][] result = new int[m][n];\n    int[][] dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\n    \n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            int liveNeighbors = 0;\n            \n            for (int[] dir : dirs) {\n                int newRow = i + dir[0];\n                int newCol = j + dir[1];\n                \n                if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && board[newRow][newCol] == 1) {\n                    liveNeighbors++;\n                }\n            }\n            \n            if (board[i][j] == 1 && (liveNeighbors == 2 || liveNeighbors == 3)) {\n                result[i][j] = 1;\n            } else if (board[i][j] == 0 && liveNeighbors == 3) {\n                result[i][j] = 1;\n            }\n        }\n    }\n    \n    return result;\n}", "cpp": "#include <vector>\n\nstd::vector<std::vector<int>> gameOfLife(std::vector<std::vector<int>>& board) {\n    int m = board.size();\n    int n = board[0].size();\n    std::vector<std::vector<int>> result(m, std::vector<int>(n, 0));\n    \n    std::vector<std::vector<int>> dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\n    \n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            int liveNeighbors = 0;\n            \n            for (std::vector<int> dir : dirs) {\n                int newRow = i + dir[0];\n                int newCol = j + dir[1];\n                \n                if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && board[newRow][newCol] == 1) {\n                    liveNeighbors++;\n                }\n            }\n            \n            if (board[i][j] == 1 && (liveNeighbors == 2 || liveNeighbors == 3)) {\n                result[i][j] = 1;\n            } else if (board[i][j] == 0 && liveNeighbors == 3) {\n                result[i][j] = 1;\n            }\n        }\n    }\n    \n    return result;\n}", "javascript": "function gameOfLife(board) {\n    let m = board.length;\n    let n = board[0].length;\n    let result = new Array(m).fill(0).map(() => new Array(n).fill(0));\n    let dirs = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];\n\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            let liveNeighbors = 0;\n\n            for (let dir of dirs) {\n                let newRow = i + dir[0];\n                let newCol = j + dir[1];\n\n                if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && board[newRow][newCol] === 1) {\n                    liveNeighbors++;\n                }\n            }\n\n            if (board[i][j] === 1 && (liveNeighbors === 2 || liveNeighbors === 3)) {\n                result[i][j] = 1;\n            } else if (board[i][j] === 0 && liveNeighbors === 3) {\n                result[i][j] = 1;\n            }\n        }\n    }\n\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/290", "prompt": "Given a `pattern` and a string `s`, find if `s` follows the same pattern.\n\nHere **follow** means a full match, such that there is a bijection between a letter in `pattern` and a **non-empty** word in `s`.\n\n**Example 1:**\n\n**Input:** pattern =  \"abba \", s =  \"dog cat cat dog \"\n**Output:** true\n\n**Example 2:**\n\n**Input:** pattern =  \"abba \", s =  \"dog cat cat fish \"\n**Output:** false\n\n**Example 3:**\n\n**Input:** pattern =  \"aaaa \", s =  \"dog cat cat dog \"\n**Output:** false\n\n**Constraints:**\n\n*   `1 <= pattern.length <= 300`\n*   `pattern` contains only lower-case English letters.\n*   `1 <= s.length <= 3000`\n*   `s` contains only lowercase English letters and spaces `' '`.\n*   `s` **does not contain** any leading or trailing spaces.\n*   All the words in `s` are separated by a **single space**.", "entry_point": "word_pattern", "canonical_solutions": {"python": "def word_pattern(pattern, s):\n    words = s.split()\n    if len(pattern) != len(words):\n        return False\n\n    char_map, word_map = {}, {}\n    for c, word in zip(pattern, words):\n        if c not in char_map and word not in word_map:\n            char_map[c] = word\n            word_map[word] = c\n        else:\n            if char_map.get(c) != word or word_map.get(word) != c:\n                return False\n\n    return True", "java": "import java.util.HashMap;\nimport java.util.Map;\n\npublic boolean wordPattern(String pattern, String s) {\n    String[] words = s.split(\" \");\n    if (pattern.length() != words.length) return false;\n\n    Map<Character, String> charMap = new HashMap<>();\n    Map<String, Character> wordMap = new HashMap<>();\n\n    for (int i = 0; i < pattern.length(); i++) {\n        char c = pattern.charAt(i);\n        String word = words[i];\n        if (!charMap.containsKey(c) && !wordMap.containsKey(word)) {\n            charMap.put(c, word);\n            wordMap.put(word, c);\n        } else {\n            if (!word.equals(charMap.get(c)) || c != wordMap.get(word)) return false;\n        }\n    }\n\n    return true;\n}", "cpp": "#include <string>\n#include <unordered_map>\n#include <sstream>\nusing namespace std;\n\nbool wordPattern(string pattern, string s) {\n    unordered_map<char, string> char_map;\n    unordered_map<string, char> word_map;\n    stringstream ss(s);\n\n    int i = 0;\n    for (string word; ss >> word; ++i) {\n        if (i == pattern.size()) return false;\n        char c = pattern[i];\n        if (char_map.count(c) == 0 && word_map.count(word) == 0) {\n            char_map[c] = word;\n            word_map[word] = c;\n        } else {\n            if (char_map[c] != word || word_map[word] != c) return false;\n        }\n    }\n\n    return i == pattern.size();\n}", "javascript": "function wordPattern(pattern, s) {\n    const words = s.split(' ');\n    if (pattern.length !== words.length) return false;\n\n    const charMap = new Map();\n    const wordMap = new Map();\n\n    for (let i = 0; i < pattern.length; i++) {\n        const c = pattern[i];\n        const word = words[i];\n        if (!charMap.has(c) && !wordMap.has(word)) {\n            charMap.set(c, word);\n            wordMap.set(word, c);\n        } else {\n            if (charMap.get(c) !== word || wordMap.get(word) !== c) return false;\n        }\n    }\n\n    return true;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/291", "prompt": "Given a `pattern` and a string `s`, return `true` _if_ `s` _**matches** the_ `pattern`_._\n\nA string `s` **matches** a `pattern` if there is some **bijective mapping** of single characters to strings such that if each character in `pattern` is replaced by the string it maps to, then the resulting string is `s`. A **bijective mapping** means that no two characters map to the same string, and no character maps to two different strings.\n\n**Example 1:**\n\n**Input:** pattern =  \"abab \", s =  \"redblueredblue \"\n**Output:** true\n**Explanation:** One possible mapping is as follows:\n'a' ->  \"red \"\n'b' ->  \"blue \"\n\n**Example 2:**\n\n**Input:** pattern =  \"aaaa \", s =  \"asdasdasdasd \"\n**Output:** true\n**Explanation:** One possible mapping is as follows:\n'a' ->  \"asd \"\n\n**Example 3:**\n\n**Input:** pattern =  \"aabb \", s =  \"xyzabcxzyabc \"\n**Output:** false\n\n**Constraints:**\n\n*   `1 <= pattern.length, s.length <= 20`\n*   `pattern` and `s` consist of only lowercase English letters.", "entry_point": "word_pattern_ii", "canonical_solutions": {"python": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(p_index, s_index, pattern_map, words):\n        if p_index == len(pattern) and s_index == len(s):\n            return True\n        if p_index == len(pattern) or s_index == len(s):\n            return False\n\n        p = pattern[p_index]\n        if p in pattern_map:\n            word = pattern_map[p]\n            if not s.startswith(word, s_index):\n                return False\n            return backtrack(p_index + 1, s_index + len(word), pattern_map, words)\n        else:\n            for length in range(1, len(s) - s_index + 1):\n                word = s[s_index : s_index + length]\n                if word in words:\n                    continue\n                pattern_map[p] = word\n                words.add(word)\n                if backtrack(p_index + 1, s_index + length, pattern_map, words):\n                    return True\n                pattern_map.pop(p)\n                words.remove(word)\n        return False\n\n    return backtrack(0, 0, {}, set())", "java": "public boolean wordPatternMatch(String pattern, String s) {\n    Map<Character, String> patternMap = new HashMap<>();\n    Set<String> words = new HashSet<>();\n    return backtrack(pattern, 0, s, 0, patternMap, words);\n}\n\nprivate boolean backtrack(String pattern, int pIndex, String s, int sIndex, Map<Character, String> patternMap, Set<String> words) {\n    if (pIndex == pattern.length() && sIndex == s.length()) return true;\n    if (pIndex == pattern.length() || sIndex == s.length()) return false;\n\n    char p = pattern.charAt(pIndex);\n    if (patternMap.containsKey(p)) {\n        String word = patternMap.get(p);\n        if (!s.startsWith(word, sIndex)) return false;\n        return backtrack(pattern, pIndex + 1, s, sIndex + word.length(), patternMap, words);\n    } else {\n        for (int length = 1; length <= s.length() - sIndex; length++) {\n            String word = s.substring(sIndex, sIndex + length);\n            if (words.contains(word)) continue;\n            patternMap.put(p, word);\n            words.add(word);\n            if (backtrack(pattern, pIndex + 1, s, sIndex + length, patternMap, words)) return true;\n            patternMap.remove(p);\n            words.remove(word);\n        }\n    }\n    return false;\n}", "cpp": "bool wordPatternMatch(string pattern, string s) {\n    unordered_map<char, string> pattern_map;\n    unordered_set<string> words;\n    return backtrack(pattern, 0, s, 0, pattern_map, words);\n}\n\nbool backtrack(string& pattern, int p_index, string& s, int s_index, unordered_map<char, string>& pattern_map, unordered_set<string>& words) {\n    if (p_index == pattern.size() && s_index == s.size()) return true;\n    if (p_index == pattern.size() || s_index == s.size()) return false;\n\n    char p = pattern[p_index];\n    if (pattern_map.count(p)) {\n        string word = pattern_map[p];\n        if (s.substr(s_index, word.size()) != word) return false;\n        return backtrack(pattern, p_index + 1, s, s_index + word.size(), pattern_map, words);\n    } else {\n        for (int length = 1; length <= s.size() - s_index; length++) {\n            string word = s.substr(s_index, length);\n            if (words.count(word)) continue;\n            pattern_map[p] = word;\n            words.insert(word);\n            if (backtrack(pattern, p_index + 1, s, s_index + length, pattern_map, words)) return true;\n            pattern_map.erase(p);\n            words.erase(word);\n        }\n    }\n    return false;\n}", "javascript": "var wordPatternMatch = function(pattern, s) {\n    const patternMap = new Map();\n    const words = new Set();\n    return backtrack(pattern, 0, s, 0, patternMap, words);\n    \n    function backtrack(pattern, pIndex, s, sIndex, patternMap, words) {\n        if (pIndex == pattern.length && sIndex == s.length) return true;\n        if (pIndex == pattern.length || sIndex == s.length) return false;\n\n        let p = pattern[pIndex];\n        if (patternMap.has(p)) {\n            let word = patternMap.get(p);\n            if (s.slice(sIndex, sIndex + word.length) !== word) return false;\n            return backtrack(pattern, pIndex + 1, s, sIndex + word.length, patternMap, words);\n        } else {\n            for (let length = 1; length <= s.length - sIndex; length++) {\n                let word = s.substr(sIndex, length);\n                if (words.has(word)) continue;\n                patternMap.set(p, word);\n                words.add(word);\n                if (backtrack(pattern, pIndex + 1, s, sIndex + length, patternMap, words)) return true;\n                patternMap.delete(p);\n                words.delete(word);\n            }\n        }\n        return false;\n    }\n};"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/292", "prompt": "You are playing the following Nim Game with your friend:\n\n*   Initially, there is a heap of stones on the table.\n*   You and your friend will alternate taking turns, and **you go first**.\n*   On each turn, the person whose turn it is will remove 1 to 3 stones from the heap.\n*   The one who removes the last stone is the winner.\n\nGiven `n`, the number of stones in the heap, return `true` _if you can win the game assuming both you and your friend play optimally, otherwise return_ `false`.\n\n**Example 1:**\n\n**Input:** n = 4\n**Output:** false\n**Explanation:** These are the possible outcomes:\n1. You remove 1 stone. Your friend removes 3 stones, including the last stone. Your friend wins.\n2. You remove 2 stones. Your friend removes 2 stones, including the last stone. Your friend wins.\n3. You remove 3 stones. Your friend removes the last stone. Your friend wins.\nIn all outcomes, your friend wins.\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** true\n\n**Example 3:**\n\n**Input:** n = 2\n**Output:** true\n\n**Constraints:**\n\n*   `1 <= n <= 231 - 1`", "entry_point": "nim_game", "canonical_solutions": {"python": "def canWinNim(n):\n    return n % 4 != 0", "java": "public boolean canWinNim(int n) {\n    return n % 4 != 0;\n}", "cpp": "bool canWinNim(int n) {\n    return n % 4 != 0;\n}", "javascript": "function canWinNim(n) {\n    return n % 4 !== 0;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/293", "prompt": "You are playing a Flip Game with your friend.\n\nYou are given a string `currentState` that contains only `'+'` and `'-'`. You and your friend take turns to flip **two consecutive** `\"++ \"` into `\"-- \"`. The game ends when a person can no longer make a move, and therefore the other person will be the winner.\n\nReturn all possible states of the string `currentState` after **one valid move**. You may return the answer in **any order**. If there is no valid move, return an empty list `[]`.\n\n**Example 1:**\n\n**Input:** currentState =  \"++++ \"\n**Output:** \\[ \"--++ \", \"+--+ \", \"++-- \"\\]\n\n**Example 2:**\n\n**Input:** currentState =  \"+ \"\n**Output:** \\[\\]\n\n**Constraints:**\n\n*   `1 <= currentState.length <= 500`\n*   `currentState[i]` is either `'+'` or `'-'`.", "entry_point": "flip_game", "canonical_solutions": {"python": "def generate_possible_next_moves(current_state):\n    result = []\n    for i in range(1, len(current_state)):\n        if current_state[i] == '+' and current_state[i - 1] == '+':\n            result.append(current_state[:i - 1] + '--' + current_state[i + 1:])\n    return result", "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> generatePossibleNextMoves(String currentState) {\n    List<String> result = new ArrayList<>();\n    for (int i = 1; i < currentState.length(); i++) {\n        if (currentState.charAt(i) == '+' && currentState.charAt(i - 1) == '+') {\n            result.add(currentState.substring(0, i - 1) + \"--\" + currentState.substring(i + 1));\n        }\n    }\n    return result;\n}", "cpp": "#include <vector>\n#include <string>\n\nstd::vector<std::string> generatePossibleNextMoves(std::string currentState) {\n    std::vector<std::string> result;\n    for (int i = 1; i < currentState.size(); ++i) {\n        if (currentState[i] == '+' && currentState[i - 1] == '+') {\n            currentState[i] = currentState[i - 1] = '-';\n            result.push_back(currentState);\n            currentState[i] = currentState[i - 1] = '+';\n        }\n    }\n    return result;\n}", "javascript": "function generatePossibleNextMoves(currentState) {\n    const result = [];\n    for (let i = 1; i < currentState.length; i++) {\n        if (currentState[i] === '+' && currentState[i - 1] === '+') {\n            result.push(currentState.slice(0, i - 1) + '--' + currentState.slice(i + 1));\n        }\n    }\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/294", "prompt": "You are playing a Flip Game with your friend.\n\nYou are given a string `currentState` that contains only `'+'` and `'-'`. You and your friend take turns to flip **two consecutive** `\"++ \"` into `\"-- \"`. The game ends when a person can no longer make a move, and therefore the other person will be the winner.\n\nReturn `true` _if the starting player can **guarantee a win**_, and `false` otherwise.\n\n**Example 1:**\n\n**Input:** currentState =  \"++++ \"\n**Output:** true\n**Explanation:** The starting player can guarantee a win by flipping the middle  \"++ \" to become  \"+--+ \".\n\n**Example 2:**\n\n**Input:** currentState =  \"+ \"\n**Output:** false\n\n**Constraints:**\n\n*   `1 <= currentState.length <= 60`\n*   `currentState[i]` is either `'+'` or `'-'`.\n\n**Follow up:** Derive your algorithm's runtime complexity.", "entry_point": "flip_game_ii", "canonical_solutions": {"python": "def canWin(currentState: str) -> bool:\n    for i in range(len(currentState) - 1):\n        if currentState[i] == '+' and currentState[i + 1] == '+':\n            temp = currentState[:i] + \"--\" + currentState[i + 2:]\n            if not canWin(temp):\n                return True\n    return False", "java": "public boolean canWin(String currentState) {\n    for (int i = 0; i < currentState.length() - 1; ++i) {\n        if (currentState.charAt(i) == '+' && currentState.charAt(i + 1) == '+') {\n            String temp = currentState.substring(0, i) + \"--\" + currentState.substring(i + 2);\n            if (!canWin(temp)) return true;\n        }\n    }\n    return false;\n}", "cpp": "bool canWin(string currentState) {\n    for (int i = 0; i < currentState.size() - 1; ++i) {\n        if (currentState[i] == '+' && currentState[i + 1] == '+') {\n            currentState[i] = '-';\n            currentState[i + 1] = '-';\n            bool opponentWins = canWin(currentState);\n            currentState[i] = '+';\n            currentState[i + 1] = '+';\n            if (!opponentWins) return true;\n        }\n    }\n    return false;\n}", "javascript": "function canWin(currentState) {\n    for (let i = 0; i < currentState.length - 1; ++i) {\n        if (currentState[i] === '+' && currentState[i + 1] === '+') {\n            let temp = currentState.slice(0, i) + \"--\" + currentState.slice(i + 2);\n            if (!canWin(temp)) return true;\n        }\n    }\n    return false;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/295", "prompt": "The **median** is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.\n\n*   For example, for `arr = [2,3,4]`, the median is `3`.\n*   For example, for `arr = [2,3]`, the median is `(2 + 3) / 2 = 2.5`.\n\nImplement the MedianFinder class:\n\n*   `MedianFinder()` initializes the `MedianFinder` object.\n*   `void addNum(int num)` adds the integer `num` from the data stream to the data structure.\n*   `double findMedian()` returns the median of all elements so far. Answers within `10-5` of the actual answer will be accepted.\n\n**Example 1:**\n\n**Input**\n\\[ \"MedianFinder \",  \"addNum \",  \"addNum \",  \"findMedian \",  \"addNum \",  \"findMedian \"\\]\n\\[\\[\\], \\[1\\], \\[2\\], \\[\\], \\[3\\], \\[\\]\\]\n**Output**\n\\[null, null, null, 1.5, null, 2.0\\]\n\n**Explanation**\nMedianFinder medianFinder = new MedianFinder();\nmedianFinder.addNum(1);    // arr = \\[1\\]\nmedianFinder.addNum(2);    // arr = \\[1, 2\\]\nmedianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)\nmedianFinder.addNum(3);    // arr\\[1, 2, 3\\]\nmedianFinder.findMedian(); // return 2.0\n\n**Constraints:**\n\n*   `-105 <= num <= 105`\n*   There will be at least one element in the data structure before calling `findMedian`.\n*   At most `5 * 104` calls will be made to `addNum` and `findMedian`.\n\n**Follow up:**\n\n*   If all integer numbers from the stream are in the range `[0, 100]`, how would you optimize your solution?\n*   If `99%` of all integer numbers from the stream are in the range `[0, 100]`, how would you optimize your solution?", "entry_point": "find_median_from_data_stream", "canonical_solutions": {"python": "import heapq\n\nclass MedianFinder:\n    def __init__(self):\n        self.left = []  # max heap\n        self.right = []  # min heap\n\n    def addNum(self, num: int) -> None:\n        if not self.left or num <= -self.left[0]:\n            heapq.heappush(self.left, -num)\n        else:\n            heapq.heappush(self.right, num)\n        \n        if len(self.left) < len(self.right):\n            heapq.heappush(self.left, -heapq.heappop(self.right))\n        elif len(self.left) > len(self.right) + 1:\n            heapq.heappush(self.right, -heapq.heappop(self.left))\n\n    def findMedian(self) -> float:\n        if len(self.left) == len(self.right):\n            return (-self.left[0] + self.right[0]) / 2\n        else:\n            return -self.left[0]", "java": "import java.util.*;\n\nclass MedianFinder {\n    PriorityQueue<Integer> left;\n    PriorityQueue<Integer> right;\n\n    public MedianFinder() {\n        left = new PriorityQueue<>((a, b) -> b.compareTo(a));\n        right = new PriorityQueue<>();\n    }\n    \n    public void addNum(int num) {\n        if (left.isEmpty() || num <= left.peek()) {\n            left.offer(num);\n        } else {\n            right.offer(num);\n        }\n        \n        if (left.size() < right.size()) {\n            left.offer(right.poll());\n        } else if (left.size() > right.size() + 1) {\n            right.offer(left.poll());\n        }\n    }\n    \n    public double findMedian() {\n        if (left.size() == right.size()) {\n            return (left.peek() + right.peek()) / 2.0;\n        } else {\n            return left.peek();\n        }\n    }\n}", "cpp": "#include <queue>\nusing namespace std;\n\nclass MedianFinder {\npublic:\n    /** initialize your data structure here. */\n    priority_queue<int> left;\n    priority_queue<int, vector<int>, greater<int> > right;\n    \n    MedianFinder() {}\n    \n    void addNum(int num) {\n        if (left.empty() || num <= left.top()) {\n            left.push(num);\n        } else {\n            right.push(num);\n        }\n        \n        if (left.size() < right.size()) {\n            left.push(right.top());\n            right.pop();\n        } else if (left.size() > right.size() + 1) {\n            right.push(left.top());\n            left.pop();\n        }\n    }\n    \n    double findMedian() {\n        if(left.size() == right.size()){\n            return ((double)left.top() + (double)right.top()) / 2;\n        }\n        else{\n            return left.top();\n        }\n    }\n};", "javascript": "class MedianFinder {\n    constructor() {\n        this.left = new MaxPriorityQueue();\n        this.right = new MinPriorityQueue();\n    }\n    \n    addNum(num) {\n        if (this.left.isEmpty() || num <= this.left.peek().element) {\n            this.left.enqueue(num);\n        } else {\n            this.right.enqueue(num);\n        }\n        \n        if (this.left.size() < this.right.size()) {\n            this.left.enqueue(this.right.dequeue().element);\n        } else if (this.left.size() > this.right.size() + 1) {\n            this.right.enqueue(this.left.dequeue().element);\n        }\n    }\n    \n    findMedian() {\n        if (this.left.size() === this.right.size()) {\n            return (this.left.peek().element + this.right.peek().element) / 2.0;\n        } else {\n            return this.left.peek().element;\n        }\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/296", "prompt": "Given an `m x n` binary grid `grid` where each `1` marks the home of one friend, return _the minimal **total travel distance**_.\n\nThe **total travel distance** is the sum of the distances between the houses of the friends and the meeting point.\n\nThe distance is calculated using [Manhattan Distance](http://en.wikipedia.org/wiki/Taxicab_geometry), where `distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|`.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[1,0,0,0,1\\],\\[0,0,0,0,0\\],\\[0,0,1,0,0\\]\\]\n**Output:** 6\n**Explanation:** Given three friends living at (0,0), (0,4), and (2,2).\nThe point (0,2) is an ideal meeting point, as the total travel distance of 2 + 2 + 2 = 6 is minimal.\nSo return 6.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,1\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 200`\n*   `grid[i][j]` is either `0` or `1`.\n*   There will be **at least two** friends in the `grid`.", "entry_point": "best_meeting_point", "canonical_solutions": {"python": "def minTotalDistance(grid):\n    m, n = len(grid), len(grid[0])\n    rows, cols = [], []\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                rows.append(i)\n                cols.append(j)\n\n    cols.sort()\n    row_median, col_median = rows[len(rows) // 2], cols[len(cols) // 2]\n    distance = sum(abs(i - row_median) for i in rows) + sum(abs(j - col_median) for j in cols)\n    return distance", "java": "public int minTotalDistance(int[][] grid) {\n    List<Integer> rows = new ArrayList<Integer>();\n    List<Integer> cols = new ArrayList<Integer>();\n    int m = grid.length, n = grid[0].length;\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j] == 1) {\n                rows.add(i);\n                cols.add(j);\n            }\n        }\n    }\n    Collections.sort(cols);\n    int row_median = rows.get(rows.size() / 2), col_median = cols.get(cols.size() / 2);\n    int distance = 0;\n    for (int i : rows) distance += Math.abs(i - row_median);\n    for (int j : cols) distance += Math.abs(j - col_median);\n    return distance;\n}", "cpp": "int minTotalDistance(vector<vector<int>>& grid) {\n    vector<int> rows, cols;\n    int m = grid.size(), n = grid[0].size();\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j]) {\n                rows.push_back(i);\n                cols.push_back(j);\n            }\n        }\n    }\n    sort(cols.begin(), cols.end());\n    int row_median = rows[rows.size() / 2], col_median = cols[cols.size() / 2];\n    int distance = 0;\n    for (int i : rows) distance += abs(i - row_median);\n    for (int j : cols) distance += abs(j - col_median);\n    return distance;\n}", "javascript": "var minTotalDistance = function(grid) {\n    let m = grid.length, n = grid[0].length;\n    let rows = [], cols = [];\n    for (let i = 0; i < m; ++i) {\n        for (let j = 0; j < n; ++j) {\n            if (grid[i][j] === 1) {\n                rows.push(i);\n                cols.push(j);\n            }\n        }\n    }\n    cols.sort((a, b) => a - b);\n    let row_median = rows[Math.floor(rows.length / 2)], col_median = cols[Math.floor(cols.length / 2)];\n    let distance = rows.reduce((acc, i) => acc + Math.abs(i - row_median), 0) + cols.reduce((acc, j) => acc + Math.abs(j - col_median), 0);\n    return distance;\n};"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/297", "prompt": "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\n\nDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\n\n**Clarification:** The input/output format is the same as [how LeetCode serializes a binary tree](https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-). You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.\n\n**Example 1:**\n\n**Input:** root = \\[1,2,3,null,null,4,5\\]\n**Output:** \\[1,2,3,null,null,4,5\\]\n\n**Example 2:**\n\n**Input:** root = \\[\\]\n**Output:** \\[\\]\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 104]`.\n*   `-1000 <= Node.val <= 1000`", "entry_point": "serialize_and_deserialize_binary_tree", "canonical_solutions": {"python": "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef serialize(root):\n    if not root: return \"null,\"\n    return str(root.val) + \",\" + serialize(root.left) + serialize(root.right)\n\ndef deserialize(data):\n    def deserialize_helper(values):\n        val = values.pop(0)\n        if val == 'null': return None\n        root = TreeNode(int(val))\n        root.left = deserialize_helper(values)\n        root.right = deserialize_helper(values)\n        return root\n\n    values = data.split(\",\")\n    return deserialize_helper(values[:-1])  # Excluding the last empty element", "java": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Arrays;\n\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic String serialize(TreeNode root) {\n    if (root == null) return \"null,\";\n    return root.val + \",\" + serialize(root.left) + serialize(root.right);\n}\n\npublic TreeNode deserialize(String data) {\n    Queue<String> queue = new LinkedList<>(Arrays.asList(data.split(\",\")));\n    return deserializeHelper(queue);\n}\n\nprivate TreeNode deserializeHelper(Queue<String> queue) {\n    String val = queue.poll();\n    if (val.equals(\"null\")) return null;\n    TreeNode root = new TreeNode(Integer.parseInt(val));\n    root.left = deserializeHelper(queue);\n    root.right = deserializeHelper(queue);\n    return root;\n}", "cpp": "#include <sstream>\n#include <string>\n#include <queue>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nstring serialize(TreeNode* root) {\n    if (!root) return \"null,\";\n    return to_string(root->val) + \",\" + serialize(root->left) + serialize(root->right);\n}\n\nTreeNode* deserialize(string data) {\n    istringstream is(data);\n    return deserializeHelper(is);\n}\n\nTreeNode* deserializeHelper(istringstream& is) {\n    string val;\n    if (!getline(is, val, ',')) return nullptr;\n    if (val == \"null\") return nullptr;\n    TreeNode* root = new TreeNode(stoi(val));\n    root->left = deserializeHelper(is);\n    root->right = deserializeHelper(is);\n    return root;\n}", "javascript": "class TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction serialize(root) {\n    if (!root) return \"null,\";\n    return root.val + \",\" + serialize(root.left) + serialize(root.right);\n}\n\nfunction deserialize(data) {\n    const values = data.split(\",\");\n\n    function deserializeHelper() {\n        const val = values.shift();\n        if (val === \"null\") return null;\n        const root = new TreeNode(parseInt(val));\n        root.left = deserializeHelper();\n        root.right = deserializeHelper();\n        return root;\n    }\n\n    return deserializeHelper();\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/298", "prompt": "Given the `root` of a binary tree, return _the length of the longest **consecutive sequence path**_.\n\nA **consecutive sequence path** is a path where the values **increase by one** along the path.\n\nNote that the path can start **at any node** in the tree, and you cannot go from a node to its parent in the path.\n\n**Example 1:**\n\n**Input:** root = \\[1,null,3,2,4,null,null,null,5\\]\n**Output:** 3\n**Explanation:** Longest consecutive sequence path is 3-4-5, so return 3.\n\n**Example 2:**\n\n**Input:** root = \\[2,null,3,2,null,1\\]\n**Output:** 2\n**Explanation:** Longest consecutive sequence path is 2-3, not 3-2-1, so return 2.\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 3 * 104]`.\n*   `-3 * 104 <= Node.val <= 3 * 104`", "entry_point": "binary_tree_longest_consecutive_sequence", "canonical_solutions": {"python": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef longest_consecutive_sequence(root, longest_path):\n    if root is None:\n        return 0\n    left = longest_consecutive_sequence(root.left, longest_path)\n    right = longest_consecutive_sequence(root.right, longest_path)\n    curr_path = 1\n    if root.left and root.left.val == root.val + 1:\n        curr_path = max(curr_path, left + 1)\n    if root.right and root.right.val == root.val + 1:\n        curr_path = max(curr_path, right + 1)\n    longest_path[0] = max(longest_path[0], curr_path)\n    return curr_path\n\ndef longest_consecutive(root):\n    longest_path = [0]\n    longest_consecutive_sequence(root, longest_path)\n    return longest_path[0]", "java": "public class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic int longestConsecutiveSequence(TreeNode root, int[] longestPath) {\n    if (root == null) {\n        return 0;\n    }\n    int left = longestConsecutiveSequence(root.left, longestPath);\n    int right = longestConsecutiveSequence(root.right, longestPath);\n    int currPath = 1;\n    if (root.left != null && root.left.val == root.val + 1) {\n        currPath = Math.max(currPath, left + 1);\n    }\n    if (root.right != null && root.right.val == root.val + 1) {\n        currPath = Math.max(currPath, right + 1);\n    }\n    longestPath[0] = Math.max(longestPath[0], currPath);\n    return currPath;\n}\n\npublic int longestConsecutive(TreeNode root) {\n    int[] longestPath = new int[1];\n    longestConsecutiveSequence(root, longestPath);\n    return longestPath[0];\n}", "cpp": "struct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nint longestConsecutiveSequence(TreeNode* root, int &longestPath) {\n    if (root == NULL) {\n        return 0;\n    }\n    int left = longestConsecutiveSequence(root->left, longestPath);\n    int right = longestConsecutiveSequence(root->right, longestPath);\n    int currPath = 1;\n    if (root->left != NULL && root->left->val == root->val + 1) {\n        currPath = max(currPath, left + 1);\n    }\n    if (root->right != NULL && root->right->val == root->val + 1) {\n        currPath = max(currPath, right + 1);\n    }\n    longestPath = max(longestPath, currPath);\n    return currPath;\n}\n\nint longestConsecutive(TreeNode* root) {\n    int longestPath = 0;\n    longestConsecutiveSequence(root, longestPath);\n    return longestPath;\n}", "javascript": "class TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction longestConsecutiveSequence(root, longestPath) {\n    if (!root) {\n        return 0;\n    }\n    const left = longestConsecutiveSequence(root.left, longestPath);\n    const right = longestConsecutiveSequence(root.right, longestPath);\n    let currPath = 1;\n    if (root.left && root.left.val === root.val + 1) {\n        currPath = Math.max(currPath, left + 1);\n    }\n    if (root.right && root.right.val === root.val + 1) {\n        currPath = Math.max(currPath, right + 1);\n    }\n    longestPath[0] = Math.max(longestPath[0], currPath);\n    return currPath;\n}\n\nfunction longestConsecutive(root) {\n    const longestPath = [0];\n    longestConsecutiveSequence(root, longestPath);\n    return longestPath[0];\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/299", "prompt": "You are playing the **[Bulls and Cows](https://en.wikipedia.org/wiki/Bulls_and_Cows)** game with your friend.\n\nYou write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:\n\n*   The number of \"bulls \", which are digits in the guess that are in the correct position.\n*   The number of \"cows \", which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls.\n\nGiven the secret number `secret` and your friend's guess `guess`, return _the hint for your friend's guess_.\n\nThe hint should be formatted as `\"xAyB \"`, where `x` is the number of bulls and `y` is the number of cows. Note that both `secret` and `guess` may contain duplicate digits.\n\n**Example 1:**\n\n**Input:** secret =  \"1807 \", guess =  \"7810 \"\n**Output:**  \"1A3B \"\n**Explanation:** Bulls are connected with a '|' and cows are underlined:\n \"1807 \"\n  |\n \"7810 \"\n\n**Example 2:**\n\n**Input:** secret =  \"1123 \", guess =  \"0111 \"\n**Output:**  \"1A1B \"\n**Explanation:** Bulls are connected with a '|' and cows are underlined:\n \"1123 \"         \"1123 \"\n  |      or     |\n \"0111 \"         \"0111 \"\nNote that only one of the two unmatched 1s is counted as a cow since the non-bull digits can only be rearranged to allow one 1 to be a bull.\n\n**Constraints:**\n\n*   `1 <= secret.length, guess.length <= 1000`\n*   `secret.length == guess.length`\n*   `secret` and `guess` consist of digits only.", "entry_point": "bulls_and_cows", "canonical_solutions": {"python": "def get_hint(secret: str, guess: str) -> str:\n    bulls = cows = 0\n    secret_count = [0] * 10\n    guess_count = [0] * 10\n\n    for i in range(len(secret)):\n        if secret[i] == guess[i]:\n            bulls += 1\n        else:\n            secret_count[int(secret[i])] += 1\n            guess_count[int(guess[i])] += 1\n   \n    for i in range(10):\n        cows += min(secret_count[i], guess_count[i])\n    \n    return f\"{bulls}A{cows}B\"", "java": "public String getHint(String secret, String guess) {\n    int bulls = 0, cows = 0;\n    int[] secretCount = new int[10];\n    int[] guessCount = new int[10];\n\n    for (int i = 0; i < secret.length(); i++) {\n        if (secret.charAt(i) == guess.charAt(i)) {\n            bulls++;\n        } else {\n            secretCount[secret.charAt(i) - '0']++;\n            guessCount[guess.charAt(i) - '0']++;\n        }\n    }\n\n    for (int i = 0; i < 10; i++) {\n        cows += Math.min(secretCount[i], guessCount[i]);\n    }\n\n    return bulls + \"A\" + cows + \"B\";\n}", "cpp": "std::string getHint(std::string secret, std::string guess) {\n    int bulls = 0, cows = 0;\n    std::vector<int> secret_count(10, 0);\n    std::vector<int> guess_count(10, 0);\n\n    for (size_t i = 0; i < secret.length(); i++) {\n        if (secret[i] == guess[i]) {\n            bulls++;\n        } else {\n            secret_count[secret[i] - '0']++;\n            guess_count[guess[i] - '0']++;\n        }\n    }\n\n    for (size_t i = 0; i < 10; i++) {\n        cows += std::min(secret_count[i], guess_count[i]);\n    }\n\n    return std::to_string(bulls) + \"A\" + std::to_string(cows) + \"B\";\n}", "javascript": "function getHint(secret, guess) {\n    let bulls = 0, cows = 0;\n    let secretCount = Array(10).fill(0);\n    let guessCount = Array(10).fill(0);\n\n    for (let i = 0; i < secret.length; i++) {\n        if (secret[i] === guess[i]) {\n            bulls++;\n        } else {\n            secretCount[parseInt(secret[i])]++;\n            guessCount[parseInt(guess[i])]++;\n        }\n    }\n\n    for (let i = 0; i < 10; i++) {\n        cows += Math.min(secretCount[i], guessCount[i]);\n    }\n\n    return `${bulls}A${cows}B`;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/300", "prompt": "Given an integer array `nums`, return _the length of the longest **strictly increasing**_ _**subsequence**_.\n\n**Example 1:**\n\n**Input:** nums = \\[10,9,2,5,3,7,101,18\\]\n**Output:** 4\n**Explanation:** The longest increasing subsequence is \\[2,3,7,101\\], therefore the length is 4.\n\n**Example 2:**\n\n**Input:** nums = \\[0,1,0,3,2,3\\]\n**Output:** 4\n\n**Example 3:**\n\n**Input:** nums = \\[7,7,7,7,7,7,7\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= nums.length <= 2500`\n*   `-104 <= nums[i] <= 104`\n\n**Follow up:** Can you come up with an algorithm that runs in `O(n log(n))` time complexity?", "entry_point": "longest_increasing_subsequence", "canonical_solutions": {"python": "def lengthOfLIS(nums):\n    dp = [1] * len(nums)\n    max_length = 1\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n        max_length = max(max_length, dp[i])\n    return max_length", "java": "public int lengthOfLIS(int[] nums) {\n    int[] dp = new int[nums.length];\n    int max_length = 1;\n    Arrays.fill(dp, 1);\n    for (int i = 1; i < nums.length; i++) {\n        for (int j = 0; j < i; j++) {\n            if (nums[i] > nums[j]) {\n                dp[i] = Math.max(dp[i], dp[j] + 1);\n            }\n        }\n        max_length = Math.max(max_length, dp[i]);\n    }\n    return max_length;\n}", "cpp": "int lengthOfLIS(vector<int>& nums) {\n    vector<int> dp(nums.size(), 1);\n    int max_length = 1;\n    for (int i = 1; i < nums.size(); i++) {\n        for (int j = 0; j < i; j++) {\n            if (nums[i] > nums[j]) {\n                dp[i] = max(dp[i], dp[j] + 1);\n            }\n        }\n        max_length = max(max_length, dp[i]);\n    }\n    return max_length;\n}", "javascript": "function lengthOfLIS(nums) {\n    const dp = new Array(nums.length).fill(1);\n    let max_length = 1;\n    for (let i = 1; i < nums.length; i++) {\n        for (let j = 0; j < i; j++) {\n            if (nums[i] > nums[j]) {\n                dp[i] = Math.max(dp[i], dp[j] + 1);\n            }\n        }\n        max_length = Math.max(max_length, dp[i]);\n    }\n    return max_length;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/301", "prompt": "Given a string `s` that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.\n\nReturn _a list of **unique strings** that are valid with the minimum number of removals_. You may return the answer in **any order**.\n\n**Example 1:**\n\n**Input:** s =  \"()())() \"\n**Output:** \\[ \"(())() \", \"()()() \"\\]\n\n**Example 2:**\n\n**Input:** s =  \"(a)())() \"\n**Output:** \\[ \"(a())() \", \"(a)()() \"\\]\n\n**Example 3:**\n\n**Input:** s =  \")( \"\n**Output:** \\[ \" \"\\]\n\n**Constraints:**\n\n*   `1 <= s.length <= 25`\n*   `s` consists of lowercase English letters and parentheses `'('` and `')'`.\n*   There will be at most `20` parentheses in `s`.", "entry_point": "remove_invalid_parentheses", "canonical_solutions": {"python": "from collections import deque\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str):\n        visited = set()\n        queue = deque([s])\n        result = []\n        found = False\n\n        while queue:\n            cur = queue.popleft()\n\n            if self.is_valid(cur):\n                found = True\n                result.append(cur)\n\n            if found: continue\n\n            for i in range(len(cur)):\n                if cur[i] == '(' or cur[i] == ')':\n                    next_str = cur[:i] + cur[i+1:]\n                    if next_str not in visited:\n                        visited.add(next_str)\n                        queue.append(next_str)\n\n        return result\n\n    def is_valid(self, s: str) -> bool:\n        count = 0\n        for c in s:\n            if c == '(': count += 1\n            if c == ')':\n                count -= 1\n                if count < 0: return False\n        return count == 0", "java": "import java.util.*;\n\nclass Solution {\n    public List<String> removeInvalidParentheses(String s) {\n        Set<String> visited = new HashSet<>();\n        Queue<String> queue = new LinkedList<>();\n        List<String> result = new ArrayList<>();\n        boolean found = false;\n\n        visited.add(s);\n        queue.offer(s);\n\n        while (!queue.isEmpty()) {\n            String current = queue.poll();\n\n            if (isValid(current)) {\n                found = true;\n                result.add(current);\n            }\n\n            if (found) continue;\n\n            for (int i = 0; i < current.length(); i++) {\n                if (current.charAt(i) == '(' || current.charAt(i) == ')') {\n                    String next = current.substring(0, i) + current.substring(i + 1);\n                    if (!visited.contains(next)) {\n                        visited.add(next);\n                        queue.offer(next);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    private boolean isValid(String s) {\n        int count = 0;\n        for (char c : s.toCharArray()) {\n            if (c == '(') count++;\n            if (c == ')') count--;\n            if (count < 0) return false;\n        }\n        return count == 0;\n    }\n}", "cpp": "#include <vector>\n#include <string>\n#include <set>\n#include <queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> removeInvalidParentheses(string s) {\n        set<string> visited;\n        queue<string> q;\n        vector<string> result;\n        bool found = false;\n\n        visited.insert(s);\n        q.push(s);\n\n        while (!q.empty()) {\n            string cur = q.front();\n            q.pop();\n\n            if (isValid(cur)) {\n                found = true;\n                result.push_back(cur);\n            }\n\n            if (found) continue;\n\n            for (int i = 0; i < cur.length(); ++i) {\n                if (cur[i] == '(' || cur[i] == ')') {\n                    string next = cur.substr(0, i) + cur.substr(i+1);\n                    if (visited.find(next) == visited.end()) {\n                        visited.insert(next);\n                        q.push(next);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    bool isValid(const string &s) {\n        int count = 0;\n        for (char c : s) {\n            if (c == '(') count++;\n            if (c == ')') count--;\n            if (count < 0) return false;\n        }\n        return count == 0;\n    }\n};", "javascript": "class Solution {\n    removeInvalidParentheses(s) {\n        let visited = new Set();\n        let queue = [s];\n        let result = [];\n        let found = false;\n\n        while (queue.length > 0) {\n            let cur = queue.shift();\n\n            if (this.isValid(cur)) {\n                found = true;\n                result.push(cur);\n            }\n\n            if (found) continue;\n\n            for (let i = 0; i < cur.length; i++) {\n                if (cur[i] === '(' || cur[i] === ')') {\n                    let next = cur.slice(0, i) + cur.slice(i + 1);\n                    if (!visited.has(next)) {\n                        visited.add(next);\n                        queue.push(next);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    isValid(s) {\n        let count = 0;\n        for (let c of s) {\n            if (c === '(') count++;\n            if (c === ')') count--;\n            if (count < 0) return false;\n        }\n        return count === 0;\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/302", "prompt": "You are given an `m x n` binary matrix `image` where `0` represents a white pixel and `1` represents a black pixel.\n\nThe black pixels are connected (i.e., there is only one black region). Pixels are connected horizontally and vertically.\n\nGiven two integers `x` and `y` that represents the location of one of the black pixels, return _the area of the smallest (axis-aligned) rectangle that encloses all black pixels_.\n\nYou must write an algorithm with less than `O(mn)` runtime complexity\n\n**Example 1:**\n\n**Input:** image = \\[\\[ \"0 \", \"0 \", \"1 \", \"0 \"\\],\\[ \"0 \", \"1 \", \"1 \", \"0 \"\\],\\[ \"0 \", \"1 \", \"0 \", \"0 \"\\]\\], x = 0, y = 2\n**Output:** 6\n\n**Example 2:**\n\n**Input:** image = \\[\\[ \"1 \"\\]\\], x = 0, y = 0\n**Output:** 1\n\n**Constraints:**\n\n*   `m == image.length`\n*   `n == image[i].length`\n*   `1 <= m, n <= 100`\n*   `image[i][j]` is either `'0'` or `'1'`.\n*   `0 <= x < m`\n*   `0 <= y < n`\n*   `image[x][y] == '1'.`\n*   The black pixels in the `image` only form **one component**.", "entry_point": "smallest_rectangle_enclosing_black_pixels", "canonical_solutions": {"python": "def minArea(image, x, y):\n    top, bottom, left, right = x, x, y, y\n    for i, row in enumerate(image):\n        for j, cell in enumerate(row):\n            if cell == '1':\n                top, bottom = min(top, i), max(bottom, i)\n                left, right = min(left, j), max(right, j)\n    return (bottom - top + 1) * (right - left + 1)", "java": "public int minArea(char[][] image, int x, int y) {\n    int top = x, bottom = x, left = y, right = y;\n    for (int i = 0; i < image.length; ++i) {\n        for (int j = 0; j < image[i].length; ++j) {\n            if (image[i][j] == '1') {\n                top = Math.min(top, i);\n                bottom = Math.max(bottom, i);\n                left = Math.min(left, j);\n                right = Math.max(right, j);\n            }\n        }\n    }\n    return (bottom - top + 1) * (right - left + 1);\n}", "cpp": "int minArea(vector<vector<char>>& image, int x, int y) {\n    int top = x, bottom = x, left = y, right = y;\n    for (int i = 0; i < image.size(); ++i) {\n        for (int j = 0; j < image[i].size(); ++j) {\n            if (image[i][j] == '1') {\n                top = min(top, i);\n                bottom = max(bottom, i);\n                left = min(left, j);\n                right = max(right, j);\n            }\n        }\n    }\n    return (bottom - top + 1) * (right - left + 1);\n}", "javascript": "function minArea(image, x, y) {\n    let top = x, bottom = x, left = y, right = y;\n    for (let i = 0; i < image.length; ++i) {\n        for (let j = 0; j < image[i].length; ++j) {\n            if (image[i][j] === '1') {\n                top = Math.min(top, i);\n                bottom = Math.max(bottom, i);\n                left = Math.min(left, j);\n                right = Math.max(right, j);\n            }\n        }\n    }\n    return (bottom - top + 1) * (right - left + 1);\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/303", "prompt": "Given an integer array `nums`, handle multiple queries of the following type:\n\n1.  Calculate the **sum** of the elements of `nums` between indices `left` and `right` **inclusive** where `left <= right`.\n\nImplement the `NumArray` class:\n\n*   `NumArray(int[] nums)` Initializes the object with the integer array `nums`.\n*   `int sumRange(int left, int right)` Returns the **sum** of the elements of `nums` between indices `left` and `right` **inclusive** (i.e. `nums[left] + nums[left + 1] + ... + nums[right]`).\n\n**Example 1:**\n\n**Input**\n\\[ \"NumArray \",  \"sumRange \",  \"sumRange \",  \"sumRange \"\\]\n\\[\\[\\[-2, 0, 3, -5, 2, -1\\]\\], \\[0, 2\\], \\[2, 5\\], \\[0, 5\\]\\]\n**Output**\n\\[null, 1, -1, -3\\]\n\n**Explanation**\nNumArray numArray = new NumArray(\\[-2, 0, 3, -5, 2, -1\\]);\nnumArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1\nnumArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1\nnumArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3\n\n**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-105 <= nums[i] <= 105`\n*   `0 <= left <= right < nums.length`\n*   At most `104` calls will be made to `sumRange`.", "entry_point": "range_sum_query_immutable", "canonical_solutions": {"python": "class NumArray:\n\n    def __init__(self, nums: List[int]):\n        self.pSum = [0] * (len(nums) + 1)\n        for i, num in enumerate(nums):\n            self.pSum[i + 1] = self.pSum[i] + num\n\n    def sumRange(self, left: int, right: int) -> int:\n        return self.pSum[right + 1] - self.pSum[left]", "java": "class NumArray {\n    int[] pSum;\n\n    public NumArray(int[] nums) {\n        pSum = new int[nums.length + 1];\n        for (int i = 0; i < nums.length; i++) {\n            pSum[i + 1] = pSum[i] + nums[i];\n        }\n    }\n\n    public int sumRange(int left, int right) {\n        return pSum[right + 1] - pSum[left];\n    }\n}", "cpp": "#include <vector>\n\nclass NumArray {\npublic:\n    std::vector<int> pSum;\n\n    NumArray(std::vector<int> &nums) {\n        pSum.resize(nums.size() + 1);\n        for (int i = 0; i < nums.size(); i++) {\n            pSum[i + 1] = pSum[i] + nums[i];\n        }\n    }\n\n    int sumRange(int left, int right) {\n        return pSum[right + 1] - pSum[left];\n    }\n};", "javascript": "class NumArray {\n    constructor(nums) {\n        this.pSum = new Array(nums.length + 1).fill(0);\n        for (let i = 0; i < nums.length; i++) {\n            this.pSum[i + 1] = this.pSum[i] + nums[i];\n        }\n    }\n\n    sumRange(left, right) {\n        return this.pSum[right + 1] - this.pSum[left];\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/304", "prompt": "Given a 2D matrix `matrix`, handle multiple queries of the following type:\n\n*   Calculate the **sum** of the elements of `matrix` inside the rectangle defined by its **upper left corner** `(row1, col1)` and **lower right corner** `(row2, col2)`.\n\nImplement the `NumMatrix` class:\n\n*   `NumMatrix(int[][] matrix)` Initializes the object with the integer matrix `matrix`.\n*   `int sumRegion(int row1, int col1, int row2, int col2)` Returns the **sum** of the elements of `matrix` inside the rectangle defined by its **upper left corner** `(row1, col1)` and **lower right corner** `(row2, col2)`.\n\nYou must design an algorithm where `sumRegion` works on `O(1)` time complexity.\n\n**Example 1:**\n\n**Input**\n\\[ \"NumMatrix \",  \"sumRegion \",  \"sumRegion \",  \"sumRegion \"\\]\n\\[\\[\\[\\[3, 0, 1, 4, 2\\], \\[5, 6, 3, 2, 1\\], \\[1, 2, 0, 1, 5\\], \\[4, 1, 0, 1, 7\\], \\[1, 0, 3, 0, 5\\]\\]\\], \\[2, 1, 4, 3\\], \\[1, 1, 2, 2\\], \\[1, 2, 2, 4\\]\\]\n**Output**\n\\[null, 8, 11, 12\\]\n\n**Explanation**\nNumMatrix numMatrix = new NumMatrix(\\[\\[3, 0, 1, 4, 2\\], \\[5, 6, 3, 2, 1\\], \\[1, 2, 0, 1, 5\\], \\[4, 1, 0, 1, 7\\], \\[1, 0, 3, 0, 5\\]\\]);\nnumMatrix.sumRegion(2, 1, 4, 3); // return 8 (i.e sum of the red rectangle)\nnumMatrix.sumRegion(1, 1, 2, 2); // return 11 (i.e sum of the green rectangle)\nnumMatrix.sumRegion(1, 2, 2, 4); // return 12 (i.e sum of the blue rectangle)\n\n**Constraints:**\n\n*   `m == matrix.length`\n*   `n == matrix[i].length`\n*   `1 <= m, n <= 200`\n*   `-104 <= matrix[i][j] <= 104`\n*   `0 <= row1 <= row2 < m`\n*   `0 <= col1 <= col2 < n`\n*   At most `104` calls will be made to `sumRegion`.", "entry_point": "range_sum_query_2d_immutable", "canonical_solutions": {"python": "class NumMatrix:\n\n    def __init__(self, matrix: List[List[int]]):\n        m, n = len(matrix), len(matrix[0])\n        self.dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                self.dp[i][j] = self.dp[i - 1][j] + self.dp[i][j - 1] - self.dp[i - 1][j - 1] + matrix[i - 1][j - 1]\n\n    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:\n        return self.dp[row2 + 1][col2 + 1] - self.dp[row1][col2 + 1] - self.dp[row2 + 1][col1] + self.dp[row1][col1]", "java": "class NumMatrix {\n    private int[][] dp;\n\n    public NumMatrix(int[][] matrix) {\n        int m = matrix.length;\n        int n = matrix[0].length;\n        dp = new int[m + 1][n + 1];\n\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + matrix[i - 1][j - 1];\n            }\n        }\n    }\n\n    public int sumRegion(int row1, int col1, int row2, int col2) {\n        return dp[row2 + 1][col2 + 1] - dp[row1][col2 + 1] - dp[row2 + 1][col1] + dp[row1][col1];\n    }\n}", "cpp": "class NumMatrix {\npublic:\n    vector<vector<int>> dp;\n    \n    NumMatrix(vector<vector<int>>& matrix) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        dp = vector<vector<int>>(m + 1, vector<int>(n + 1));\n        \n        for (int i = 1; i <= m; ++i) {\n            for (int j = 1; j <= n; ++j) {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + matrix[i - 1][j - 1];\n            }\n        }\n    }\n    \n    int sumRegion(int row1, int col1, int row2, int col2) {\n        return dp[row2 + 1][col2 + 1] - dp[row1][col2 + 1] - dp[row2 + 1][col1] + dp[row1][col1];\n    }\n};", "javascript": "class NumMatrix {\n    constructor(matrix) {\n        this.dp = [];\n        let m = matrix.length;\n        let n = matrix[0].length;\n        \n        for (let i = 0; i <= m; i++) {\n            this.dp[i] = new Array(n + 1).fill(0);\n        }\n        \n        for (let i = 1; i <= m; i++) {\n            for (let j = 1; j <= n; j++) {\n                this.dp[i][j] = this.dp[i - 1][j] + this.dp[i][j - 1] - this.dp[i - 1][j - 1] + matrix[i - 1][j - 1];\n            }\n        }\n    }\n    \n    sumRegion(row1, col1, row2, col2) {\n        return this.dp[row2 + 1][col2 + 1] - this.dp[row1][col2 + 1] - this.dp[row2 + 1][col1] + this.dp[row1][col1];\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/305", "prompt": "You are given an empty 2D binary grid `grid` of size `m x n`. The grid represents a map where `0`'s represent water and `1`'s represent land. Initially, all the cells of `grid` are water cells (i.e., all the cells are `0`'s).\n\nWe may perform an add land operation which turns the water at position into a land. You are given an array `positions` where `positions[i] = [ri, ci]` is the position `(ri, ci)` at which we should operate the `ith` operation.\n\nReturn _an array of integers_ `answer` _where_ `answer[i]` _is the number of islands after turning the cell_ `(ri, ci)` _into a land_.\n\nAn **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n\n**Example 1:**\n\n**Input:** m = 3, n = 3, positions = \\[\\[0,0\\],\\[0,1\\],\\[1,2\\],\\[2,1\\]\\]\n**Output:** \\[1,1,2,3\\]\n**Explanation:**\nInitially, the 2d grid is filled with water.\n- Operation #1: addLand(0, 0) turns the water at grid\\[0\\]\\[0\\] into a land. We have 1 island.\n- Operation #2: addLand(0, 1) turns the water at grid\\[0\\]\\[1\\] into a land. We still have 1 island.\n- Operation #3: addLand(1, 2) turns the water at grid\\[1\\]\\[2\\] into a land. We have 2 islands.\n- Operation #4: addLand(2, 1) turns the water at grid\\[2\\]\\[1\\] into a land. We have 3 islands.\n\n**Example 2:**\n\n**Input:** m = 1, n = 1, positions = \\[\\[0,0\\]\\]\n**Output:** \\[1\\]\n\n**Constraints:**\n\n*   `1 <= m, n, positions.length <= 104`\n*   `1 <= m * n <= 104`\n*   `positions[i].length == 2`\n*   `0 <= ri < m`\n*   `0 <= ci < n`\n\n**Follow up:** Could you solve it in time complexity `O(k log(mn))`, where `k == positions.length`?", "entry_point": "number_of_islands_ii", "canonical_solutions": {"python": "def numIslands2(m: int, n: int, positions: List[List[int]]) -> List[int]:\n    def index(x: int, y: int) -> int:\n        return x * n + y\n    \n    def find(x: int) -> int:\n        if roots[x] != x:\n            roots[x] = find(roots[x])\n        return roots[x]\n\n    roots = [-1] * (m * n)\n    dirs = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n    islandCount = 0\n    result = []\n\n    for i, j in positions:\n        idx = index(i, j)\n        if roots[idx] != -1:\n            result.append(islandCount)\n            continue\n        islandCount += 1\n        roots[idx] = idx\n        for dx, dy in dirs:\n            ni, nj = i + dx, j + dy\n            neighbor = index(ni, nj)\n            if 0 <= ni < m and 0 <= nj < n and roots[neighbor] != -1:\n                root_neighbor = find(neighbor)\n                if idx != root_neighbor:\n                    roots[root_neighbor] = idx\n                    islandCount -= 1\n        result.append(islandCount)\n    return result", "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic List<Integer> numIslands2(int m, int n, int[][] positions) {\n    int[] roots = new int[m * n];\n    Arrays.fill(roots, -1);\n    int[][] dirs = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\n    int islandCount = 0;\n    List<Integer> result = new ArrayList<>();\n\n    for (int[] position : positions) {\n        int i = position[0], j = position[1], index = i * n + j;\n        if (roots[index] != -1) {\n            result.add(islandCount);\n            continue;\n        }\n        islandCount++;\n        roots[index] = index;\n        for (int[] dir : dirs) {\n            int ni = i + dir[0], nj = j + dir[1], neighbor = ni * n + nj;\n            if (ni >= 0 && ni < m && nj >= 0 && nj < n && roots[neighbor] != -1) {\n                int rootNb = find(roots, neighbor);\n                if (index != rootNb) {\n                    roots[rootNb] = index;\n                    islandCount--;\n                }\n            }\n        }\n        result.add(islandCount);\n    }\n    return result;\n}\n\nprivate int find(int[] roots, int x) {\n    if (roots[x] != x) roots[x] = find(roots, roots[x]);\n    return roots[x];\n}", "cpp": "#include <vector>\n\nusing namespace std;\n\nvector<int> numIslands2(int m, int n, vector<vector<int>>& positions) {\n    vector<int> roots(m * n, -1);\n    vector<vector<int>> dirs{{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\n    int islandCount = 0;\n    vector<int> result;\n    \n    auto getIndex = [&](int i, int j){\n        return i * n + j;\n    };        \n    \n    function<int(int)> findRoot = [&](int x) {\n        if (roots[x] != x) {\n            roots[x] = findRoot(roots[x]);\n        }\n        return roots[x];\n    };\n    \n    for(const auto& position : positions) {\n        int i = position[0], j = position[1], index = getIndex(i, j);\n        if (roots[index] != -1) {\n            result.push_back(islandCount);\n            continue;\n        }\n        islandCount++;\n        roots[index] = index;\n        for (const auto& dir : dirs) {\n            int ni = i + dir[0], nj = j + dir[1], neighbor = getIndex(ni, nj);\n            if (ni >= 0 && ni < m && nj >= 0 && nj < n && roots[neighbor] != -1) {\n                int rootNb = findRoot(neighbor);\n                if (index != rootNb) {\n                    roots[rootNb] = index;\n                    islandCount--;\n                }\n            }\n        }\n        result.push_back(islandCount);\n    }\n    return result;\n}", "javascript": "function numIslands2(m, n, positions) {\n    const roots = new Array(m * n).fill(-1);\n    const dirs = [[0, 1], [1, 0], [-1, 0], [0, -1]];\n    let islandCount = 0;\n    const result = [];\n\n    const index = (x, y) => x * n + y;\n    \n    function find(x) {\n        if (roots[x] !== x) roots[x] = find(roots[x]);\n        return roots[x];\n    }\n\n    for (const [i, j] of positions) {\n        const idx = index(i, j);\n        if (roots[idx] !== -1) {\n            result.push(islandCount);\n            continue;\n        }\n        islandCount++;\n        roots[idx] = idx;\n        for (const [dx, dy] of dirs) {\n            const ni = i + dx, nj = j + dy;\n            const neighbor = index(ni, nj);\n            if (ni >= 0 && ni < m && nj >= 0 && nj < n && roots[neighbor] !== -1) {\n                const root_neighbor = find(neighbor);\n                if (idx !== root_neighbor) {\n                    roots[root_neighbor] = idx;\n                    islandCount--;\n                }\n            }\n        }\n        result.push(islandCount);\n    }\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/306", "prompt": "An **additive number** is a string whose digits can form an **additive sequence**.\n\nA valid **additive sequence** should contain **at least** three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.\n\nGiven a string containing only digits, return `true` if it is an **additive number** or `false` otherwise.\n\n**Note:** Numbers in the additive sequence **cannot** have leading zeros, so sequence `1, 2, 03` or `1, 02, 3` is invalid.\n\n**Example 1:**\n\n**Input:**  \"112358 \"\n**Output:** true\n**Explanation:** \nThe digits can form an additive sequence: 1, 1, 2, 3, 5, 8. \n1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8\n\n**Example 2:**\n\n**Input:**  \"199100199 \"\n**Output:** true\n**Explanation:** \nThe additive sequence is: 1, 99, 100, 199. \n1 + 99 = 100, 99 + 100 = 199\n\n**Constraints:**\n\n*   `1 <= num.length <= 35`\n*   `num` consists only of digits.\n\n**Follow up:** How would you handle overflow for very large input integers?", "entry_point": "additive_number", "canonical_solutions": {"python": "def isAdditiveNumber(num):\n    for i in range(1, len(num) // 2 + 1):\n        for j in range(1, (len(num) - i) // 2 + 1):\n            if check(num[:i], num[i:i+j], num[i+j:]):\n                return True\n    return False\n\ndef check(num1, num2, remaining):\n    if (len(num1) > 1 and num1[0] == '0') or (len(num2) > 1 and num2[0] == '0'):\n        return False\n    _sum = add(num1, num2)\n    if remaining == _sum:\n        return True\n    if not remaining.startswith(_sum):\n        return False\n    return check(num2, _sum, remaining[len(_sum):])\n\ndef add(num1, num2):\n    carry, result = 0, []\n    i, j = len(num1) - 1, len(num2) - 1\n    while i >= 0 or j >= 0 or carry > 0:\n        n1 = int(num1[i]) if i >= 0 else 0\n        n2 = int(num2[j]) if j >= 0 else 0\n        _sum = n1 + n2 + carry\n        carry = _sum // 10\n        result.append(str(_sum % 10))\n        i, j = i - 1, j - 1\n    return ''.join(result[::-1])", "java": "public boolean isAdditiveNumber(String num) {\n    for (int i = 1; i <= num.length() / 2; i++) {\n        for (int j = 1; j <= (num.length() - i) / 2; j++) {\n            if (check(num.substring(0, i), num.substring(i, i + j), num.substring(i + j))) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nprivate boolean check(String num1, String num2, String remaining) {\n    if ((num1.length() > 1 && num1.charAt(0) == '0') || (num2.length() > 1 && num2.charAt(0) == '0')) {\n        return false;\n    }\n    String sum = add(num1, num2);\n    if (remaining.equals(sum)) {\n        return true;\n    }\n    if (!remaining.startsWith(sum)) {\n        return false;\n    }\n    return check(num2, sum, remaining.substring(sum.length()));\n}\n\nprivate String add(String num1, String num2) {\n    int carry = 0;\n    StringBuilder result = new StringBuilder();\n    for (int i = num1.length() - 1, j = num2.length() - 1;\n         i >= 0 || j >= 0 || carry > 0; i--, j--) {\n        int n1 = i >= 0 ? num1.charAt(i) - '0' : 0;\n        int n2 = j >= 0 ? num2.charAt(j) - '0' : 0;\n        int sum = n1 + n2 + carry;\n        carry = sum / 10;\n        result.append((char) ('0' + sum % 10));\n    }\n    return result.reverse().toString();\n}", "cpp": "bool isAdditiveNumber(std::string num) {\n    for (int i = 1; i <= num.length() / 2; i++) {\n        for (int j = 1; j <= (num.length() - i) / 2; j++) {\n            if (check(num.substr(0, i), num.substr(i, j), num.substr(i + j))) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool check(std::string num1, std::string num2, std::string remaining) {\n    if ((num1.size() > 1 && num1[0] == '0') || (num2.size() > 1 && num2[0] == '0')) {\n        return false;\n    }\n    std::string sum = add(num1, num2);\n    if (remaining == sum) {\n        return true;\n    }\n    if (remaining.substr(0, sum.size()) != sum) {\n        return false;\n    }\n    return check(num2, sum, remaining.substr(sum.size()));\n}\n\nstd::string add(std::string num1, std::string num2) {\n    int carry = 0;\n    std::string result;\n    for (int i = num1.size() - 1, j = num2.size() - 1;\n         i >= 0 || j >= 0 || carry > 0; i--, j--) {\n        int n1 = i >= 0 ? num1[i] - '0' : 0;\n        int n2 = j >= 0 ? num2[j] - '0' : 0;\n        int sum = n1 + n2 + carry;\n        carry = sum / 10;\n        result.push_back('0' + sum % 10);\n    }\n    std::reverse(result.begin(), result.end());\n    return result;\n}", "javascript": "function isAdditiveNumber(num) {\n    for (let i = 1; i <= num.length / 2; i++) {\n        for (let j = 1; j <= (num.length - i) / 2; j++) {\n            if (check(num.slice(0, i), num.slice(i, i + j), num.slice(i + j))) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nfunction check(num1, num2, remaining) {\n    if ((num1.length > 1 && num1[0] === '0') || (num2.length > 1 && num2[0] === '0')) {\n        return false;\n    }\n    let sum = add(num1, num2);\n    if (remaining === sum) {\n        return true;\n    }\n    if (!remaining.startsWith(sum)) {\n        return false;\n    }\n    return check(num2, sum, remaining.slice(sum.length));\n}\n\nfunction add(num1, num2) {\n    let carry = 0;\n    let result = '';\n    for (let i = num1.length - 1, j = num2.length - 1;\n         i >= 0 || j >= 0 || carry > 0; i--, j--) {\n        let n1 = i >= 0 ? Number(num1[i]) : 0;\n        let n2 = j >= 0 ? Number(num2[j]) : 0;\n        let sum = n1 + n2 + carry;\n        carry = Math.floor(sum / 10);\n        result = (sum % 10).toString() + result;\n    }\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/307", "prompt": "Given an integer array `nums`, handle multiple queries of the following types:\n\n1.  **Update** the value of an element in `nums`.\n2.  Calculate the **sum** of the elements of `nums` between indices `left` and `right` **inclusive** where `left <= right`.\n\nImplement the `NumArray` class:\n\n*   `NumArray(int[] nums)` Initializes the object with the integer array `nums`.\n*   `void update(int index, int val)` **Updates** the value of `nums[index]` to be `val`.\n*   `int sumRange(int left, int right)` Returns the **sum** of the elements of `nums` between indices `left` and `right` **inclusive** (i.e. `nums[left] + nums[left + 1] + ... + nums[right]`).\n\n**Example 1:**\n\n**Input**\n\\[ \"NumArray \",  \"sumRange \",  \"update \",  \"sumRange \"\\]\n\\[\\[\\[1, 3, 5\\]\\], \\[0, 2\\], \\[1, 2\\], \\[0, 2\\]\\]\n**Output**\n\\[null, 9, null, 8\\]\n\n**Explanation**\nNumArray numArray = new NumArray(\\[1, 3, 5\\]);\nnumArray.sumRange(0, 2); // return 1 + 3 + 5 = 9\nnumArray.update(1, 2);   // nums = \\[1, 2, 5\\]\nnumArray.sumRange(0, 2); // return 1 + 2 + 5 = 8\n\n**Constraints:**\n\n*   `1 <= nums.length <= 3 * 104`\n*   `-100 <= nums[i] <= 100`\n*   `0 <= index < nums.length`\n*   `-100 <= val <= 100`\n*   `0 <= left <= right < nums.length`\n*   At most `3 * 104` calls will be made to `update` and `sumRange`.", "entry_point": "range_sum_query_mutable", "canonical_solutions": {"python": "class NumArray:\n\n    def __init__(self, nums: List[int]):\n        self.prefix_sum = [0] * (len(nums) + 1)\n        for i in range(len(nums)):\n            self.prefix_sum[i + 1] = self.prefix_sum[i] + nums[i]\n\n    def sumRange(self, left: int, right: int) -> int:\n        return self.prefix_sum[right + 1] - self.prefix_sum[left]", "java": "class NumArray {\n    private int[] prefixSum;\n\n    public NumArray(int[] nums) {\n        prefixSum = new int[nums.length + 1];\n        for (int i = 0; i < nums.length; i++) {\n            prefixSum[i + 1] = prefixSum[i] + nums[i];\n        }\n    }\n\n    public int sumRange(int left, int right) {\n        return prefixSum[right + 1] - prefixSum[left];\n    }\n}", "cpp": "#include <vector>\n\nclass NumArray {\npublic:\n    std::vector<int> prefix_sum;\n\n    NumArray(std::vector<int>& nums) {\n        prefix_sum.resize(nums.size() + 1);\n        for (int i = 0; i < nums.size(); ++i) {\n            prefix_sum[i + 1] = prefix_sum[i] + nums[i];\n        }\n    }\n\n    int sumRange(int left, int right) {\n        return prefix_sum[right + 1] - prefix_sum[left];\n    }\n};", "javascript": "class NumArray {\n    constructor(nums) {\n        this.prefixSum = [0];\n        for (let i = 0; i < nums.length; i++) {\n            this.prefixSum[i + 1] = this.prefixSum[i] + nums[i];\n        }\n    }\n\n    sumRange(left, right) {\n        return this.prefixSum[right + 1] - this.prefixSum[left];\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/308", "prompt": "Given a 2D matrix `matrix`, handle multiple queries of the following types:\n\n1.  **Update** the value of a cell in `matrix`.\n2.  Calculate the **sum** of the elements of `matrix` inside the rectangle defined by its **upper left corner** `(row1, col1)` and **lower right corner** `(row2, col2)`.\n\nImplement the NumMatrix class:\n\n*   `NumMatrix(int[][] matrix)` Initializes the object with the integer matrix `matrix`.\n*   `void update(int row, int col, int val)` **Updates** the value of `matrix[row][col]` to be `val`.\n*   `int sumRegion(int row1, int col1, int row2, int col2)` Returns the **sum** of the elements of `matrix` inside the rectangle defined by its **upper left corner** `(row1, col1)` and **lower right corner** `(row2, col2)`.\n\n**Example 1:**\n\n**Input**\n\\[ \"NumMatrix \",  \"sumRegion \",  \"update \",  \"sumRegion \"\\]\n\\[\\[\\[\\[3, 0, 1, 4, 2\\], \\[5, 6, 3, 2, 1\\], \\[1, 2, 0, 1, 5\\], \\[4, 1, 0, 1, 7\\], \\[1, 0, 3, 0, 5\\]\\]\\], \\[2, 1, 4, 3\\], \\[3, 2, 2\\], \\[2, 1, 4, 3\\]\\]\n**Output**\n\\[null, 8, null, 10\\]\n\n**Explanation**\nNumMatrix numMatrix = new NumMatrix(\\[\\[3, 0, 1, 4, 2\\], \\[5, 6, 3, 2, 1\\], \\[1, 2, 0, 1, 5\\], \\[4, 1, 0, 1, 7\\], \\[1, 0, 3, 0, 5\\]\\]);\nnumMatrix.sumRegion(2, 1, 4, 3); // return 8 (i.e. sum of the left red rectangle)\nnumMatrix.update(3, 2, 2);       // matrix changes from left image to right image\nnumMatrix.sumRegion(2, 1, 4, 3); // return 10 (i.e. sum of the right red rectangle)\n\n**Constraints:**\n\n*   `m == matrix.length`\n*   `n == matrix[i].length`\n*   `1 <= m, n <= 200`\n*   `-1000 <= matrix[i][j] <= 1000`\n*   `0 <= row < m`\n*   `0 <= col < n`\n*   `-1000 <= val <= 1000`\n*   `0 <= row1 <= row2 < m`\n*   `0 <= col1 <= col2 < n`\n*   At most `5000` calls will be made to `sumRegion` and `update`.", "entry_point": "range_sum_query_2d_mutable", "canonical_solutions": {"python": "class NumMatrix:\n\n    def __init__(self, matrix: List[List[int]]):\n        self.dp = [[0] * (len(matrix[0]) + 1) for _ in range(len(matrix) + 1)]\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                self.dp[i + 1][j + 1] = self.dp[i + 1][j] + self.dp[i][j + 1] - self.dp[i][j] + matrix[i][j]\n                \n    def update(self, row: int, col: int, val: int) -> None:\n        oldValue = self.dp[row + 1][col + 1] - self.dp[row + 1][col] - self.dp[row][col + 1] + self.dp[row][col]\n        delta = val - oldValue\n        for i in range(row + 1, len(self.dp)):\n            for j in range(col + 1, len(self.dp[0])):\n                self.dp[i][j] += delta\n\n    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:\n        return self.dp[row2 + 1][col2 + 1] - self.dp[row2 + 1][col1] - self.dp[row1][col2 + 1] + self.dp[row1][col1]", "java": "class NumMatrix {\n    int[][] dp;\n    public NumMatrix(int[][] matrix) {\n        int m = matrix.length, n = matrix[0].length;\n        dp = new int[m + 1][n + 1];\n        for(int i = 0; i < m; i++) {\n            for(int j = 0; j < n; j++) {\n                dp[i + 1][j + 1] = dp[i + 1][j] + dp[i][j + 1] - dp[i][j] + matrix[i][j];\n            }\n        }\n    }\n\n    public void update(int row, int col, int val) {\n        int oldValue = dp[row + 1][col + 1] - dp[row + 1][col] - dp[row][col + 1] + dp[row][col];\n        int delta = val - oldValue;\n        for(int i = row + 1; i < dp.length; i++)\n            for(int j = col + 1; j < dp[0].length; j++)\n                dp[i][j] += delta;\n    }\n\n    public int sumRegion(int row1, int col1, int row2, int col2) {\n        return dp[row2 + 1][col2 + 1] - dp[row2 + 1][col1] - dp[row1][col2 + 1] + dp[row1][col1];\n    }\n}", "cpp": "class NumMatrix {\npublic:\n    vector<vector<int>> dp;\n    NumMatrix(vector<vector<int>>& matrix) {\n        int m = matrix.size(), n = matrix[0].size();\n        dp.resize(m + 1, vector<int>(n + 1, 0));\n        for(int i = 0; i < m; i++) {\n            for(int j = 0; j < n; j++) {\n                dp[i + 1][j + 1] = dp[i + 1][j] + dp[i][j + 1] - dp[i][j] + matrix[i][j];\n            }\n        }\n    }\n\n    void update(int row, int col, int val) {\n        int oldValue = dp[row + 1][col + 1] - dp[row + 1][col] - dp[row][col + 1] + dp[row][col];\n        int delta = val - oldValue;\n        for(int i = row + 1; i < dp.size(); i++)\n            for(int j = col + 1; j < dp[0].size(); j++)\n                dp[i][j] += delta;\n    }\n\n    int sumRegion(int row1, int col1, int row2, int col2) {\n        return dp[row2 + 1][col2 + 1] - dp[row2 + 1][col1] - dp[row1][col2 + 1] + dp[row1][col1];\n    }\n};", "javascript": "class NumMatrix {\n    constructor(matrix) {\n        this.dp = new Array(matrix.length + 1).fill().map(() => new Array(matrix[0].length + 1).fill(0));\n        for (let i = 0; i < matrix.length; i++) {\n            for (let j = 0; j < matrix[0].length; j++) {\n                this.dp[i + 1][j + 1] = this.dp[i + 1][j] + this.dp[i][j + 1] - this.dp[i][j] + matrix[i][j];\n            }\n        }\n    }\n\n    update(row, col, val) {\n        let oldValue = this.dp[row + 1][col + 1] - this.dp[row + 1][col] - this.dp[row][col + 1] + this.dp[row][col];\n        let delta = val - oldValue;\n        for (let i = row + 1; i < this.dp.length; i++) {\n            for (let j = col + 1; j < this.dp[0].length; j++) {\n                this.dp[i][j] += delta;\n            }\n        }\n    }\n\n    sumRegion(row1, col1, row2, col2) {\n        return this.dp[row2 + 1][col2 + 1] - this.dp[row2 + 1][col1] - this.dp[row1][col2 + 1] + this.dp[row1][col1];\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/309", "prompt": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\n\nFind the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:\n\n*   After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).\n\n**Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\n**Example 1:**\n\n**Input:** prices = \\[1,2,3,0,2\\]\n**Output:** 3\n**Explanation:** transactions = \\[buy, sell, cooldown, buy, sell\\]\n\n**Example 2:**\n\n**Input:** prices = \\[1\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= prices.length <= 5000`\n*   `0 <= prices[i] <= 1000`", "entry_point": "best_time_to_buy_and_sell_stock_with_cooldown", "canonical_solutions": {"python": "def maxProfit(prices):\n    profit = 0\n    for i in range(1, len(prices)):\n        profit += max(prices[i] - prices[i - 1], 0)\n    return profit", "java": "public int maxProfit(int[] prices) {\n    int profit = 0;\n    for (int i = 1; i < prices.length; i++) {\n        profit += Math.max(prices[i] - prices[i - 1], 0);\n    }\n    return profit;\n}", "cpp": "int maxProfit(vector<int>& prices) {\n    int profit = 0;\n    for (int i = 1; i < prices.size(); ++i) {\n        profit += max(prices[i] - prices[i - 1], 0);\n    }\n    return profit;\n}", "javascript": "function maxProfit(prices) {\n    let profit = 0;\n    for (let i = 1; i < prices.length; i++) {\n        profit += Math.max(prices[i] - prices[i - 1], 0);\n    }\n    return profit;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/310", "prompt": "A tree is an undirected graph in which any two vertices are connected by _exactly_ one path. In other words, any connected graph without simple cycles is a tree.\n\nGiven a tree of `n` nodes labelled from `0` to `n - 1`, and an array of `n - 1` `edges` where `edges[i] = [ai, bi]` indicates that there is an undirected edge between the two nodes `ai` and `bi` in the tree, you can choose any node of the tree as the root. When you select a node `x` as the root, the result tree has height `h`. Among all possible rooted trees, those with minimum height (i.e. `min(h)`) are called **minimum height trees** (MHTs).\n\nReturn _a list of all **MHTs'** root labels_. You can return the answer in **any order**.\n\nThe **height** of a rooted tree is the number of edges on the longest downward path between the root and a leaf.\n\n**Example 1:**\n\n**Input:** n = 4, edges = \\[\\[1,0\\],\\[1,2\\],\\[1,3\\]\\]\n**Output:** \\[1\\]\n**Explanation:** As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT.\n\n**Example 2:**\n\n**Input:** n = 6, edges = \\[\\[3,0\\],\\[3,1\\],\\[3,2\\],\\[3,4\\],\\[5,4\\]\\]\n**Output:** \\[3,4\\]\n\n**Constraints:**\n\n*   `1 <= n <= 2 * 104`\n*   `edges.length == n - 1`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   All the pairs `(ai, bi)` are distinct.\n*   The given input is **guaranteed** to be a tree and there will be **no repeated** edges.", "entry_point": "minimum_height_trees", "canonical_solutions": {"python": "from collections import deque\nfrom typing import List\n\ndef find_min_height_trees(n: int, edges: List[List[int]]) -> List[int]:\n    if n == 1:\n        return [0]\n\n    adj_list = [set() for _ in range(n)]\n    for a, b in edges:\n        adj_list[a].add(b)\n        adj_list[b].add(a)\n\n    leaves = deque(i for i in range(n) if len(adj_list[i]) == 1)\n\n    while n > 2:\n        leaves_size = len(leaves)\n        n -= leaves_size\n        for _ in range(leaves_size):\n            leaf = leaves.popleft()\n            for neighbor in adj_list[leaf]:\n                adj_list[neighbor].remove(leaf)\n                if len(adj_list[neighbor]) == 1:\n                    leaves.append(neighbor)\n\n    return list(leaves)", "java": "import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic List<Integer> findMinHeightTrees(int n, int[][] edges) {\n    if (n == 1) {\n        List<Integer> result = new ArrayList<>();\n        result.add(0);\n        return result;\n    }\n\n    int[] degrees = new int[n];\n    List<List<Integer>> adjList = new ArrayList<>(n);\n    for (int i = 0; i < n; i++) {\n        adjList.add(new ArrayList<>());\n    }\n\n    for (int[] edge : edges) {\n        adjList.get(edge[0]).add(edge[1]);\n        adjList.get(edge[1]).add(edge[0]);\n        degrees[edge[0]]++;\n        degrees[edge[1]]++;\n    }\n\n    Queue<Integer> queue = new LinkedList<>();\n    for (int i = 0; i < n; i++) {\n        if (degrees[i] == 1) queue.add(i);\n    }\n\n    while (n > 2) {\n        int leavesSize = queue.size();\n        n -= leavesSize;\n        for (int i = 0; i < leavesSize; i++) {\n            int leaf = queue.poll();\n            for (int neighbor : adjList.get(leaf)) {\n                if (--degrees[neighbor] == 1) queue.add(neighbor);\n            }\n        }\n    }\n\n    return new ArrayList<>(queue);\n}", "cpp": "#include <vector>\n#include <queue>\nusing namespace std;\n\nvector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\n    if (n == 1) return {0};\n\n    vector<int> degrees(n, 0);\n    vector<vector<int>> adjList(n);\n    for (const auto &edge : edges) {\n        adjList[edge[0]].push_back(edge[1]);\n        adjList[edge[1]].push_back(edge[0]);\n        degrees[edge[0]]++;\n        degrees[edge[1]]++;\n    }\n\n    queue<int> q;\n    for (int i = 0; i < n; ++i) {\n        if (degrees[i] == 1) q.push(i);\n    }\n\n    while (n > 2) {\n        int leaves_size = q.size();\n        n -= leaves_size;\n        for (int i = 0; i < leaves_size; i++) {\n            int leaf = q.front(); q.pop();\n            for (int neighbor : adjList[leaf]) {\n                if (--degrees[neighbor] == 1) q.push(neighbor);\n            }\n        }\n    }\n\n    vector<int> result;\n    while (!q.empty()) {\n        result.push_back(q.front());\n        q.pop();\n    }\n\n    return result;\n}", "javascript": "function findMinHeightTrees(n, edges) {\n  if (n === 1) return [0];\n\n  const adjList = Array.from({ length: n }, () => []);\n  const degrees = new Array(n).fill(0);\n\n  for (const [a, b] of edges) {\n    adjList[a].push(b);\n    adjList[b].push(a);\n    degrees[a]++;\n    degrees[b]++;\n  }\n\n  const queue = [];\n  for (let i = 0; i < n; i++) {\n    if (degrees[i] === 1) queue.push(i);\n  }\n\n  while (n > 2) {\n    const leavesSize = queue.length;\n    n -= leavesSize;\n    for (let i = 0; i < leavesSize; i++) {\n      const leaf = queue.shift();\n      for (const neighbor of adjList[leaf]) {\n        if (--degrees[neighbor] === 1) queue.push(neighbor);\n      }\n    }\n  }\n\n  return queue;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/311", "prompt": "Given two [sparse matrices](https://en.wikipedia.org/wiki/Sparse_matrix) `mat1` of size `m x k` and `mat2` of size `k x n`, return the result of `mat1 x mat2`. You may assume that multiplication is always possible.\n\n**Example 1:**\n\n**Input:** mat1 = \\[\\[1,0,0\\],\\[-1,0,3\\]\\], mat2 = \\[\\[7,0,0\\],\\[0,0,0\\],\\[0,0,1\\]\\]\n**Output:** \\[\\[7,0,0\\],\\[-7,0,3\\]\\]\n\n**Example 2:**\n\n**Input:** mat1 = \\[\\[0\\]\\], mat2 = \\[\\[0\\]\\]\n**Output:** \\[\\[0\\]\\]\n\n**Constraints:**\n\n*   `m == mat1.length`\n*   `k == mat1[i].length == mat2.length`\n*   `n == mat2[i].length`\n*   `1 <= m, n, k <= 100`\n*   `-100 <= mat1[i][j], mat2[i][j] <= 100`", "entry_point": "sparse_matrix_multiplication", "canonical_solutions": {"python": "def multiply(mat1, mat2):\n    m, k, n = len(mat1), len(mat1[0]), len(mat2[0])\n    result = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(k):\n            if mat1[i][j] != 0:\n                for l in range(n):\n                    result[i][l] += mat1[i][j] * mat2[j][l]\n    return result", "java": "public int[][] multiply(int[][] mat1, int[][] mat2) {\n    int m = mat1.length;\n    int k = mat1[0].length;\n    int n = mat2[0].length;\n    int[][] result = new int[m][n];\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < k; j++) {\n            if (mat1[i][j] != 0) {\n                for (int l = 0; l < n; l++) {\n                    result[i][l] += mat1[i][j] * mat2[j][l];\n                }\n            }\n        }\n    }\n    return result;\n}", "cpp": "#include <vector>\nusing namespace std;\n\nvector<vector<int>> multiply(vector<vector<int>>& mat1, vector<vector<int>>& mat2) {\n    int m = mat1.size();\n    int k = mat1[0].size();\n    int n = mat2[0].size();\n    vector<vector<int>> result(m, vector<int>(n, 0));\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < k; j++) {\n            if (mat1[i][j] != 0) {\n                for (int l = 0; l < n; l++) {\n                    result[i][l] += mat1[i][j] * mat2[j][l];\n                }\n            }\n        }\n    }\n    return result;\n}", "javascript": "function multiply(mat1, mat2) {\n    const m = mat1.length;\n    const k = mat1[0].length;\n    const n = mat2[0].length;\n    const result = Array.from({ length: m }, () => Array.from({ length: n }, () => 0));\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < k; j++) {\n            if (mat1[i][j] !== 0) {\n                for (let l = 0; l < n; l++) {\n                    result[i][l] += mat1[i][j] * mat2[j][l];\n                }\n            }\n        }\n    }\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/312", "prompt": "You are given `n` balloons, indexed from `0` to `n - 1`. Each balloon is painted with a number on it represented by an array `nums`. You are asked to burst all the balloons.\n\nIf you burst the `ith` balloon, you will get `nums[i - 1] * nums[i] * nums[i + 1]` coins. If `i - 1` or `i + 1` goes out of bounds of the array, then treat it as if there is a balloon with a `1` painted on it.\n\nReturn _the maximum coins you can collect by bursting the balloons wisely_.\n\n**Example 1:**\n\n**Input:** nums = \\[3,1,5,8\\]\n**Output:** 167\n**Explanation:**\nnums = \\[3,1,5,8\\] --> \\[3,5,8\\] --> \\[3,8\\] --> \\[8\\] --> \\[\\]\ncoins =  3\\*1\\*5    +   3\\*5\\*8   +  1\\*3\\*8  + 1\\*8\\*1 = 167\n\n**Example 2:**\n\n**Input:** nums = \\[1,5\\]\n**Output:** 10\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 300`\n*   `0 <= nums[i] <= 100`", "entry_point": "burst_balloons", "canonical_solutions": {"python": "def maxCoins(nums):\n    nums = [1] + nums + [1]\n    n = len(nums)\n    dp = [[0] * n for _ in range(n)]\n\n    for length in range(1, n - 1):\n        for left in range(1, n - length):\n            right = left + length - 1\n            for i in range(left, right + 1):\n                dp[left][right] = max(dp[left][right], nums[left - 1] * nums[i] * nums[right + 1] + dp[left][i - 1] + dp[i + 1][right])\n\n    return dp[1][n - 2]", "java": "public int maxCoins(int[] nums) {\n    int n = nums.length;\n    int[] newNums = new int[n + 2];\n    newNums[0] = 1;\n    newNums[n + 1] = 1;\n    for (int i = 1; i <= n; i++) {\n        newNums[i] = nums[i - 1];\n    }\n\n    int[][] dp = new int[n + 2][n + 2];\n    for (int len = 1; len <= n; len++) {\n        for (int left = 1; left <= n - len + 1; left++) {\n            int right = left + len - 1;\n            for (int i = left; i <= right; i++) {\n                dp[left][right] = Math.max(dp[left][right], newNums[left - 1] * newNums[i] * newNums[right + 1] + dp[left][i - 1] + dp[i + 1][right]);\n            }\n        }\n    }\n\n    return dp[1][n];\n}", "cpp": "int maxCoins(vector<int>& nums) {\n    int n = nums.size();\n    nums.insert(nums.begin(), 1);\n    nums.push_back(1);\n\n    vector<vector<int>> dp(n + 2, vector<int>(n + 2, 0));\n    for (int len = 1; len <= n; len++) {\n        for (int left = 1; left <= n - len + 1; left++) {\n            int right = left + len - 1;\n            for (int i = left; i <= right; i++) {\n                dp[left][right] = max(dp[left][right], nums[left - 1] * nums[i] * nums[right + 1] + dp[left][i - 1] + dp[i + 1][right]);\n            }\n        }\n    }\n\n    return dp[1][n];\n}", "javascript": "function maxCoins(nums) {\n    nums.unshift(1);\n    nums.push(1);\n    const n = nums.length;\n\n    const dp = [];\n    for (let i = 0; i < n; i++) {\n        dp.push(new Array(n).fill(0));\n    }\n\n    for (let len = 1; len <= n - 2; len++) {\n        for (let left = 1; left <= n - len - 1; left++) {\n            const right = left + len - 1;\n            for (let i = left; i <= right; i++) {\n                dp[left][right] = Math.max(dp[left][right], nums[left - 1] * nums[i] * nums[right + 1] + dp[left][i - 1] + dp[i + 1][right]);\n            }\n        }\n    }\n\n    return dp[1][n - 2];\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/313", "prompt": "A **super ugly number** is a positive integer whose prime factors are in the array `primes`.\n\nGiven an integer `n` and an array of integers `primes`, return _the_ `nth` _**super ugly number**_.\n\nThe `nth` **super ugly number** is **guaranteed** to fit in a **32-bit** signed integer.\n\n**Example 1:**\n\n**Input:** n = 12, primes = \\[2,7,13,19\\]\n**Output:** 32\n**Explanation:** \\[1,2,4,7,8,13,14,16,19,26,28,32\\] is the sequence of the first 12 super ugly numbers given primes = \\[2,7,13,19\\].\n\n**Example 2:**\n\n**Input:** n = 1, primes = \\[2,3,5\\]\n**Output:** 1\n**Explanation:** 1 has no prime factors, therefore all of its prime factors are in the array primes = \\[2,3,5\\].\n\n**Constraints:**\n\n*   `1 <= n <= 105`\n*   `1 <= primes.length <= 100`\n*   `2 <= primes[i] <= 1000`\n*   `primes[i]` is **guaranteed** to be a prime number.\n*   All the values of `primes` are **unique** and sorted in **ascending order**.", "entry_point": "super_ugly_number", "canonical_solutions": {"python": "def nthSuperUglyNumber(n, primes):\n    ugly = [0] * n\n    ugly[0] = 1\n    indices = [0] * len(primes)\n\n    for i in range(1, n):\n        min_val = float(\"inf\")\n\n        for j in range(len(primes)):\n            min_val = min(min_val, ugly[indices[j]] * primes[j])\n\n        ugly[i] = min_val\n\n        for j in range(len(primes)):\n            if ugly[i] == ugly[indices[j]] * primes[j]:\n                indices[j] += 1\n\n    return ugly[-1]", "java": "public int nthSuperUglyNumber(int n, int[] primes) {\n    int[] ugly = new int[n];\n    ugly[0] = 1;\n    int[] indices = new int[primes.length];\n\n    for (int i = 1; i < n; i++) {\n        int minVal = Integer.MAX_VALUE;\n\n        for (int j = 0; j < primes.length; j++)\n            minVal = Math.min(minVal, ugly[indices[j]] * primes[j]);\n\n        ugly[i] = minVal;\n\n        for (int j = 0; j < primes.length; j++)\n            if (ugly[i] == ugly[indices[j]] * primes[j])\n                indices[j]++;\n    }\n\n    return ugly[n - 1];\n}", "cpp": "int nthSuperUglyNumber(int n, vector<int>& primes) {\n    vector<int> ugly(n);\n    ugly[0] = 1;\n    vector<int> indices(primes.size(), 0);\n    \n    for (int i = 1; i < n; i++) {\n        int min_val = INT_MAX;\n        \n        for (int j = 0; j < primes.size(); j++)\n            min_val = min(min_val, ugly[indices[j]] * primes[j]);\n        \n        ugly[i] = min_val;\n        \n        for (int j = 0; j < primes.size(); j++)\n            if (ugly[i] == ugly[indices[j]] * primes[j])\n                indices[j]++;\n    }\n    \n    return ugly.back();\n}", "javascript": "function nthSuperUglyNumber(n, primes) {\n    let ugly = new Array(n);\n    ugly[0] = 1;\n    let indices = new Array(primes.length).fill(0);\n\n    for (let i = 1; i < n; i++) {\n        let minVal = Number.MAX_SAFE_INTEGER;\n\n        for (let j = 0; j < primes.length; j++)\n            minVal = Math.min(minVal, ugly[indices[j]] * primes[j]);\n\n        ugly[i] = minVal;\n\n        for (let j = 0; j < primes.length; j++)\n            if (ugly[i] == ugly[indices[j]] * primes[j])\n                indices[j]++;\n    }\n\n    return ugly[n - 1];\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/314", "prompt": "Given the `root` of a binary tree, return _**the vertical order traversal** of its nodes' values_. (i.e., from top to bottom, column by column).\n\nIf two nodes are in the same row and column, the order should be from **left to right**.\n\n**Example 1:**\n\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** \\[\\[9\\],\\[3,15\\],\\[20\\],\\[7\\]\\]\n\n**Example 2:**\n\n**Input:** root = \\[3,9,8,4,0,1,7\\]\n**Output:** \\[\\[4\\],\\[9\\],\\[3,0,1\\],\\[8\\],\\[7\\]\\]\n\n**Example 3:**\n\n**Input:** root = \\[3,9,8,4,0,1,7,null,null,null,2,5\\]\n**Output:** \\[\\[4\\],\\[9,5\\],\\[3,0,1\\],\\[8,2\\],\\[7\\]\\]\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 100]`.\n*   `-100 <= Node.val <= 100`", "entry_point": "binary_tree_vertical_order_traversal", "canonical_solutions": {"python": "from collections import defaultdict, deque\nfrom typing import List, Optional\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef verticalOrder(root: Optional[TreeNode]) -> List[List[int]]:\n    if not root: return []\n\n    column_table = defaultdict(list)\n    q = deque([(root, 0)])\n\n    while q:\n        cur_node, column = q.popleft()\n\n        if cur_node:\n            column_table[column].append(cur_node.val)\n            q.append((cur_node.left, column - 1))\n            q.append((cur_node.right, column + 1))\n\n    return [column_table[key] for key in sorted(column_table)]", "java": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nclass Solution {\n    public List<List<Integer>> verticalOrder(TreeNode root) {\n        if (root == null) return new ArrayList<>();\n\n        HashMap<Integer, List<Integer>> columnTable = new HashMap<>();\n        Queue<Pair<TreeNode, Integer>> q = new LinkedList<>();\n        q.offer(new Pair<>(root, 0));\n\n        while (!q.isEmpty()) {\n            TreeNode curNode = q.peek().getKey();\n            int column = q.peek().getValue();\n            q.poll();\n\n            if (curNode != null) {\n                columnTable.putIfAbsent(column, new ArrayList<>());\n                columnTable.get(column).add(curNode.val);\n                q.offer(new Pair<>(curNode.left, column - 1));\n                q.offer(new Pair<>(curNode.right, column + 1));\n            }\n        }\n\n        return new ArrayList<>(columnTable.values());\n    }\n}", "cpp": "#include <vector>\n#include <map>\n#include <queue>\n\nclass TreeNode {\npublic:\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {}\n};\n\nstd::vector<std::vector<int>> verticalOrder(TreeNode* root) {\n    if (!root) return {};\n\n    std::map<int, std::vector<int>> columnTable;\n    std::queue<std::pair<TreeNode*, int>> q;\n    q.push({root, 0});\n\n    while (!q.empty()) {\n        TreeNode* curNode = q.front().first;\n        int column = q.front().second;\n        q.pop();\n\n        if (curNode) {\n            columnTable[column].push_back(curNode->val);\n            q.push({curNode->left, column - 1});\n            q.push({curNode->right, column + 1});\n        }\n    }\n\n    std::vector<std::vector<int>> result;\n    for (auto& [_, values] : columnTable) {\n        result.push_back(std::move(values));\n    }\n\n    return result;\n}", "javascript": "class TreeNode {\n    constructor(val, left, right) {\n        this.val = (val===undefined ? 0 : val)\n        this.left = (left===undefined ? null : left)\n        this.right = (right===undefined ? null : right)\n    }\n}\n\nvar verticalOrder = function(root) {\n    if (!root) return [];\n    \n    const columnTable = new Map();\n    const q = [[root, 0]];\n\n    while (q.length) {\n        const [curNode, column] = q.shift();\n\n        if (curNode) {\n            if (!columnTable.has(column)) columnTable.set(column, []);\n            columnTable.get(column).push(curNode.val);\n            q.push([curNode.left, column - 1]);\n            q.push([curNode.right, column + 1]);\n        }\n    }\n\n    return Array.from(columnTable.entries()).sort((a, b) => a[0] - b[0]).map(entry => entry[1]);\n};"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/315", "prompt": "Given an integer array `nums`, return _an integer array_ `counts` _where_ `counts[i]` _is the number of smaller elements to the right of_ `nums[i]`.\n\n**Example 1:**\n\n**Input:** nums = \\[5,2,6,1\\]\n**Output:** \\[2,1,1,0\\]\n**Explanation:**\nTo the right of 5 there are **2** smaller elements (2 and 1).\nTo the right of 2 there is only **1** smaller element (1).\nTo the right of 6 there is **1** smaller element (1).\nTo the right of 1 there is **0** smaller element.\n\n**Example 2:**\n\n**Input:** nums = \\[-1\\]\n**Output:** \\[0\\]\n\n**Example 3:**\n\n**Input:** nums = \\[-1,-1\\]\n**Output:** \\[0,0\\]\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-104 <= nums[i] <= 104`", "entry_point": "count_of_smaller_numbers_after_self", "canonical_solutions": {"python": "def countSmaller(nums):\n    def merge_sort(indices):\n        if len(indices) <= 1:\n            return indices\n        mid = len(indices) // 2\n        left = merge_sort(indices[:mid])\n        right = merge_sort(indices[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        merged, count = [], 0\n        while left and right:\n            if nums[left[0]] <= nums[right[0]]:\n                counts[left[0]] += count\n                merged.append(left.pop(0))\n            else:\n                count += len(left)\n                merged.append(right.pop(0))\n        for i in left:\n            counts[i] += count\n        return merged + left + right\n\n    counts = [0] * len(nums)\n    merge_sort(list(range(len(nums))))\n    return counts", "java": "import java.util.List;\nimport java.util.ArrayList;\n\npublic List<Integer> countSmaller(int[] nums) {\n    int n = nums.length;\n    int[] indices = new int[n];\n    int[] counts = new int[n];\n    \n    for (int i = 0; i < n; i++) {\n        indices[i] = i;\n    }\n    \n    mergeSort(nums, indices, counts, 0, n - 1);\n    List<Integer> result = new ArrayList<>();\n    for (int count : counts) {\n        result.add(count);\n    }\n    return result;\n}\n\nprivate void mergeSort(int[] nums, int[] indices, int[] counts, int left, int right) {\n    if (left >= right) {\n        return;\n    }\n    \n    int mid = left + (right - left) / 2;\n    mergeSort(nums, indices, counts, left, mid);\n    mergeSort(nums, indices, counts, mid + 1, right);\n    \n    int[] temp = new int[right - left + 1];\n    int i = left, j = mid + 1, k = 0;\n    while (i <= mid && j <= right) {\n        if (nums[indices[i]] <= nums[indices[j]]) {\n            counts[indices[i]] += j - mid - 1;\n            temp[k++] = indices[i++];\n        } else {\n            temp[k++] = indices[j++];\n        }\n    }\n    \n    while (i <= mid) {\n        counts[indices[i]] += j - mid - 1;\n        temp[k++] = indices[i++];\n    }\n    \n    while (j <= right) {\n        temp[k++] = indices[j++];\n    }\n    \n    System.arraycopy(temp, 0, indices, left, right - left + 1);\n}", "cpp": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nvector<int> countSmaller(vector<int>& nums) {\n    vector<int> result(nums.size(), 0);\n    vector<int> indices(nums.size(), 0);\n\n    for (int i = 0; i < nums.size(); ++i) {\n        indices[i] = i;\n    }\n\n    mergeSort(nums, indices, result, 0, nums.size() - 1);\n    return result;\n}\n\nvoid mergeSort(vector<int>& nums, vector<int>& indices, vector<int>& result, int left, int right) {\n    if (left >= right) {\n        return;\n    }\n\n    int mid = left + (right - left) / 2;\n    mergeSort(nums, indices, result, left, mid);\n    mergeSort(nums, indices, result, mid + 1, right);\n\n\n    int I = left;\n    int J = mid + 1;\n    int K = 0;\n    vector<int> temp(right - left + 1);\n    while (I <= mid && J <= right) {\n        if (nums[indices[I]] <= nums[indices[J]]) {\n            result[indices[I]] += (J - mid - 1);\n            temp[K++] = indices[I++];\n        } else {\n            temp[K++] = indices[J++];\n        }\n    }\n\n    while (I <= mid) {\n        result[indices[I]] += (J - mid - 1);\n        temp[K++] = indices[I++];\n    }\n\n    while (J <= right) {\n        temp[K++] = indices[J++];\n    }\n\n    for (int i = left, k = 0; i <= right; ++i, ++k) {\n        indices[i] = temp[k];\n    }\n}", "javascript": "function countSmaller(nums) {\n    function mergeSort(indices, start, end) {\n        if (start >= end) {\n            return;\n        }\n\n        let mid = start + ((end - start) >> 1);\n        mergeSort(indices, start, mid);\n        mergeSort(indices, mid + 1, end);\n\n        let i = start, j = mid + 1, k = 0, cnt = 0;\n        let temp = [];\n        while (i <= mid || j <= end) {\n            if (j > end || (i <= mid && nums[indices[i]] <= nums[indices[j]])) {\n                cnt += j - mid - 1;\n                counts[indices[i]] = cnt;\n                temp[k++] = indices[i++];\n            } else {\n                temp[k++] = indices[j++];\n            }\n        }\n\n        for (let i = 0; i < k; i++) {\n            indices[start + i] = temp[i];\n        }\n    }\n    \n    let counts = Array(nums.length).fill(0);\n    let indices = Array.from({length: nums.length}, (_, i) => i);\n    mergeSort(indices, 0, nums.length - 1);\n    return counts;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/316", "prompt": "Given a string `s`, remove duplicate letters so that every letter appears once and only once. You must make sure your result is **the smallest in lexicographical order** among all possible results.\n\n**Example 1:**\n\n**Input:** s =  \"bcabc \"\n**Output:**  \"abc \"\n\n**Example 2:**\n\n**Input:** s =  \"cbacdcbc \"\n**Output:**  \"acdb \"\n\n**Constraints:**\n\n*   `1 <= s.length <= 104`\n*   `s` consists of lowercase English letters.\n\n**Note:** This question is the same as 1081: [https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/](https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/)", "entry_point": "remove_duplicate_letters", "canonical_solutions": {"python": "def removeDuplicateLetters(s):\n    count = [0] * 256\n    visited = [False] * 256\n    st = []\n\n    for ch in s:\n        count[ord(ch)] += 1\n\n    for ch in s:\n        count[ord(ch)] -= 1\n        if visited[ord(ch)]:\n            continue\n        while st and ch < st[-1] and count[ord(st[-1])] > 0:\n            visited[ord(st.pop())] = False\n        st.append(ch)\n        visited[ord(ch)] = True\n\n    return \"\".join(st)", "java": "import java.util.*;\n\npublic class Solution {\n    public String removeDuplicateLetters(String s) {\n        int[] count = new int[256];\n        boolean[] visited = new boolean[256];\n        Stack<Character> st = new Stack<>();\n        \n        for (char ch : s.toCharArray()) {\n            count[ch]++;\n        }\n        \n        for (char ch : s.toCharArray()) {\n            count[ch]--;\n            if (visited[ch]) continue;\n            while (!st.isEmpty() && ch < st.peek() && count[st.peek()] > 0) {\n                visited[st.pop()] = false;\n            }\n            st.push(ch);\n            visited[ch] = true;\n        }\n        \n        StringBuilder result = new StringBuilder();\n        while (!st.empty()) {\n            result.append(st.pop());\n        }\n        return result.reverse().toString();\n    }\n}", "cpp": "#include <string>\n#include <vector>\n#include <stack>\nusing namespace std;\n\nstring removeDuplicateLetters(string s) {\n    vector<int> count(256, 0);\n    vector<bool> visited(256, false);\n    stack<char> st;\n    \n    for (char ch : s) {\n        count[ch]++;\n    }\n    \n    for (char ch : s) {\n        count[ch]--;\n        if (visited[ch]) continue;\n        while (!st.empty() && ch < st.top() && count[st.top()] > 0) {\n            visited[st.top()] = false;\n            st.pop();\n        }\n        st.push(ch);\n        visited[ch] = true;\n    }\n    \n    string result = \"\";\n    while (!st.empty()) {\n        result = st.top() + result;\n        st.pop();\n    }\n    return result;\n}", "javascript": "function removeDuplicateLetters(s) {\n    let count = new Array(256).fill(0);\n    let visited = new Array(256).fill(false);\n    let st = [];\n    \n    for (let ch of s) {\n        count[ch.charCodeAt(0)]++;\n    }\n    \n    for (let ch of s) {\n        count[ch.charCodeAt(0)]--;\n        if (visited[ch.charCodeAt(0)]) continue;\n        while (st.length > 0 && ch < st[st.length - 1] && count[st[st.length - 1].charCodeAt(0)] > 0) {\n            visited[st.pop().charCodeAt(0)] = false;\n        }\n        st.push(ch);\n        visited[ch.charCodeAt(0)] = true;\n    }\n\n    return st.join(\"\");\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/317", "prompt": "You are given an `m x n` grid `grid` of values `0`, `1`, or `2`, where:\n\n*   each `0` marks **an empty land** that you can pass by freely,\n*   each `1` marks **a building** that you cannot pass through, and\n*   each `2` marks **an obstacle** that you cannot pass through.\n\nYou want to build a house on an empty land that reaches all buildings in the **shortest total travel** distance. You can only move up, down, left, and right.\n\nReturn _the **shortest travel distance** for such a house_. If it is not possible to build such a house according to the above rules, return `-1`.\n\nThe **total travel distance** is the sum of the distances between the houses of the friends and the meeting point.\n\nThe distance is calculated using [Manhattan Distance](http://en.wikipedia.org/wiki/Taxicab_geometry), where `distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|`.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[1,0,2,0,1\\],\\[0,0,0,0,0\\],\\[0,0,1,0,0\\]\\]\n**Output:** 7\n**Explanation:** Given three buildings at (0,0), (0,4), (2,2), and an obstacle at (0,2).\nThe point (1,2) is an ideal empty land to build a house, as the total travel distance of 3+3+1=7 is minimal.\nSo return 7.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,0\\]\\]\n**Output:** 1\n\n**Example 3:**\n\n**Input:** grid = \\[\\[1\\]\\]\n**Output:** -1\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 50`\n*   `grid[i][j]` is either `0`, `1`, or `2`.\n*   There will be **at least one** building in the `grid`.", "entry_point": "shortest_distance_from_all_buildings", "canonical_solutions": {"python": "from collections import deque\n\ndef shortestDistance(grid: list[list[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n\n    total_count = [[0] * n for _ in range(m)]\n    dist_sum = [[0] * n for _ in range(m)]\n    house_count = 0\n\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                house_count += 1\n                q = deque([(i, j)])\n                visited = [[False] * n for _ in range(m)]\n                level = 1\n                while q:\n                    for _ in range(len(q)):\n                        x, y = q.popleft()\n                        for dx, dy in dirs:\n                            x_new, y_new = x + dx, y + dy\n                            if 0 <= x_new < m and 0 <= y_new < n and not visited[x_new][y_new] and grid[x_new][y_new] == 0:\n                                visited[x_new][y_new] = True\n                                q.append((x_new, y_new))\n                                dist_sum[x_new][y_new] += level\n                                total_count[x_new][y_new] += 1\n                    level += 1\n\n    min_dist = float(\"inf\")\n    for i in range(m):\n        for j in range(n):\n            if total_count[i][j] == house_count:\n                min_dist = min(min_dist, dist_sum[i][j])\n\n    return -1 if min_dist == float(\"inf\") else min_dist", "java": "import java.util.LinkedList;\nimport java.util.Queue;\n\npublic int shortestDistance(int[][] grid) {\n    int m = grid.length;\n    int n = grid[0].length;\n    \n    int[][] total_count = new int[m][n];\n    int[][] dist_sum = new int[m][n];\n    int house_count = 0;\n    \n    int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n    \n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] == 1) {\n                house_count++;\n                Queue<int[]> q = new LinkedList<>();\n                q.offer(new int[]{i, j});\n                boolean[][] visited = new boolean[m][n];\n                int level = 1;\n                while (!q.isEmpty()) {\n                    int sz = q.size();\n                    for (int q_i = 0; q_i < sz; q_i++) {\n                        int[] cur = q.poll();\n                        int x = cur[0];\n                        int y = cur[1];\n                        for (int[] dir : dirs) {\n                            int x_new = x + dir[0];\n                            int y_new = y + dir[1];\n                            if (x_new >= 0 && x_new < m && y_new >= 0 && y_new < n && !visited[x_new][y_new] && grid[x_new][y_new] == 0) {\n                                visited[x_new][y_new] = true;\n                                q.offer(new int[]{x_new, y_new});\n                                dist_sum[x_new][y_new] += level;\n                                total_count[x_new][y_new]++;\n                            }\n                        }\n                    }\n                    level++;\n                }\n            }\n        }\n    }\n                                         \n    int min_dist = Integer.MAX_VALUE;\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (total_count[i][j] == house_count) {\n                min_dist = Math.min(min_dist, dist_sum[i][j]);\n            }\n        }\n    }\n    \n    return min_dist == Integer.MAX_VALUE ? -1 : min_dist;\n}", "cpp": "#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint shortestDistance(vector<vector<int>>& grid) {\n    int m = grid.size();\n    int n = grid[0].size();\n    \n    vector<vector<int>> total_count(m, vector<int>(n, 0));\n    vector<vector<int>> dist_sum(m, vector<int>(n, 0));\n    int house_count = 0;\n    \n    int dirs[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n    \n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] == 1) {\n                house_count++;\n                queue<pair<int, int>> q;\n                q.push({i, j});\n                vector<vector<bool>> visited(m, vector<bool>(n, false));\n                int level = 1;\n                while (!q.empty()) {\n                    int sz = q.size();\n                    for (int q_i = 0; q_i < sz; q_i++) {\n                        int x = q.front().first;\n                        int y = q.front().second;\n                        q.pop();\n                        for (auto &dir : dirs) {\n                            int x_new = x + dir[0];\n                            int y_new = y + dir[1];\n                            if (x_new >= 0 && x_new < m && y_new >= 0 && y_new < n && !visited[x_new][y_new] && grid[x_new][y_new] == 0) {\n                                visited[x_new][y_new] = true;\n                                q.push({x_new, y_new});\n                                dist_sum[x_new][y_new] += level;\n                                total_count[x_new][y_new]++;\n                            }\n                        }\n                    }\n                    level++;\n                }\n            }\n        }\n    }\n                                         \n    int min_dist = INT_MAX;\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (total_count[i][j] == house_count) {\n                min_dist = min(min_dist, dist_sum[i][j]);\n            }\n        }\n    }\n    \n    return min_dist == INT_MAX ? -1 : min_dist;\n}", "javascript": "function shortestDistance(grid) {\n    let m = grid.length;\n    let n = grid[0].length;\n    \n    let total_count = Array.from({length: m}, () => Array(n).fill(0));\n    let dist_sum = Array.from({length: m}, () => Array(n).fill(0));\n    let house_count = 0;\n    \n    let dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]];\n    \n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (grid[i][j] === 1) {\n                house_count++;\n                let q = [{x: i, y: j}];\n                let visited = Array.from({length: m}, () => Array(n).fill(false));\n                let level = 1;\n                while (q.length) {\n                    let sz = q.length;\n                    for (let q_i = 0; q_i < sz; q_i++) {\n                        let { x, y } = q.shift();\n                        dirs.forEach(([dx, dy]) => {\n                            let x_new = x + dx;\n                            let y_new = y + dy;\n                            if (x_new >= 0 && x_new < m && y_new >= 0 && y_new < n && !visited[x_new][y_new] && grid[x_new][y_new] === 0) {\n                                visited[x_new][y_new] = true;\n                                q.push({ x: x_new, y: y_new });\n                                dist_sum[x_new][y_new] += level;\n                                total_count[x_new][y_new]++;\n                            }\n                        });\n                    }\n                    level++;\n                }\n            }\n        }\n    }\n                                         \n    let min_dist = Infinity;\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (total_count[i][j] === house_count) {\n                min_dist = Math.min(min_dist, dist_sum[i][j]);\n            }\n        }\n    }\n    \n    return min_dist === Infinity ? -1 : min_dist;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/318", "prompt": "Given a string array `words`, return _the maximum value of_ `length(word[i]) * length(word[j])` _where the two words do not share common letters_. If no such two words exist, return `0`.\n\n**Example 1:**\n\n**Input:** words = \\[ \"abcw \", \"baz \", \"foo \", \"bar \", \"xtfn \", \"abcdef \"\\]\n**Output:** 16\n**Explanation:** The two words can be  \"abcw \",  \"xtfn \".\n\n**Example 2:**\n\n**Input:** words = \\[ \"a \", \"ab \", \"abc \", \"d \", \"cd \", \"bcd \", \"abcd \"\\]\n**Output:** 4\n**Explanation:** The two words can be  \"ab \",  \"cd \".\n\n**Example 3:**\n\n**Input:** words = \\[ \"a \", \"aa \", \"aaa \", \"aaaa \"\\]\n**Output:** 0\n**Explanation:** No such pair of words.\n\n**Constraints:**\n\n*   `2 <= words.length <= 1000`\n*   `1 <= words[i].length <= 1000`\n*   `words[i]` consists only of lowercase English letters.", "entry_point": "maximum_product_of_word_lengths", "canonical_solutions": {"python": "def maxProduct(words):\n    n = len(words)\n    mask = [0] * n\n    for i, word in enumerate(words):\n        for c in word:\n            mask[i] |= (1 << (ord(c) - ord('a')))\n    \n    max_product = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (mask[i] & mask[j]) == 0:\n                max_product = max(max_product, len(words[i]) * len(words[j]))\n    \n    return max_product", "java": "import java.util.*;\n\nclass Solution {\n    public int maxProduct(String[] words) {\n        int n = words.length;\n        int[] mask = new int[n];\n        for (int i = 0; i < n; i++) {\n            for (char c : words[i].toCharArray()) {\n                mask[i] |= (1 << (c - 'a'));\n            }\n        }\n\n        int maxProduct = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if ((mask[i] & mask[j]) == 0) {\n                    maxProduct = Math.max(maxProduct, words[i].length() * words[j].length());\n                }\n            }\n        }\n\n        return maxProduct;\n    }\n}", "cpp": "#include <vector>\n#include <string>\n\nint maxProduct(std::vector<std::string>& words) {\n    int n = words.size();\n    std::vector<int> mask(n, 0);\n    for (int i = 0; i < n; ++i) {\n        for (char c : words[i]) {\n            mask[i] |= (1 << (c - 'a'));\n        }\n    }\n\n    int max_product = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if ((mask[i] & mask[j]) == 0) {\n                max_product = std::max(max_product, int(words[i].length() * words[j].length()));\n            }\n        }\n    }\n\n    return max_product;\n}", "javascript": "function maxProduct(words) {\n    const n = words.length;\n    const mask = new Array(n).fill(0);\n    for (let i = 0; i < n; i++) {\n        for (const c of words[i]) {\n            mask[i] |= (1 << (c.charCodeAt(0) - 'a'.charCodeAt(0)));\n        }\n    }\n\n    let maxProduct = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            if ((mask[i] & mask[j]) === 0) {\n                maxProduct = Math.max(maxProduct, words[i].length * words[j].length);\n            }\n        }\n    }\n\n    return maxProduct;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/319", "prompt": "There are `n` bulbs that are initially off. You first turn on all the bulbs, then you turn off every second bulb.\n\nOn the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the `ith` round, you toggle every `i` bulb. For the `nth` round, you only toggle the last bulb.\n\nReturn _the number of bulbs that are on after `n` rounds_.\n\n**Example 1:**\n\n**Input:** n = 3\n**Output:** 1\n**Explanation:** At first, the three bulbs are \\[off, off, off\\].\nAfter the first round, the three bulbs are \\[on, on, on\\].\nAfter the second round, the three bulbs are \\[on, off, on\\].\nAfter the third round, the three bulbs are \\[on, off, off\\]. \nSo you should return 1 because there is only one bulb is on.\n\n**Example 2:**\n\n**Input:** n = 0\n**Output:** 0\n\n**Example 3:**\n\n**Input:** n = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `0 <= n <= 109`", "entry_point": "bulb_switcher", "canonical_solutions": {"python": "def bulbSwitch(n):\n    return int(n**0.5)", "java": "public int bulbSwitch(int n) {\n    return (int)Math.sqrt(n);\n}", "cpp": "int bulbSwitch(int n) {\n    return sqrt(n);\n}", "javascript": "function bulbSwitch(n) {\n    return Math.floor(Math.sqrt(n));\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/320", "prompt": "A word's **generalized abbreviation** can be constructed by taking any number of **non-overlapping** and **non-adjacent** substrings and replacing them with their respective lengths.\n\n*   For example, `\"abcde \"` can be abbreviated into:\n    *   `\"a3e \"` ( `\"bcd \"` turned into `\"3 \"`)\n    *   `\"1bcd1 \"` ( `\"a \"` and `\"e \"` both turned into `\"1 \"`)\n    *   `\"5 \"` ( `\"abcde \"` turned into `\"5 \"`)\n    *   `\"abcde \"` (no substrings replaced)\n*   However, these abbreviations are **invalid**:\n    *   `\"23 \"` ( `\"ab \"` turned into `\"2 \"` and `\"cde \"` turned into `\"3 \"`) is invalid as the substrings chosen are adjacent.\n    *   `\"22de \"` ( `\"ab \"` turned into `\"2 \"` and `\"bc \"` turned into `\"2 \"`) is invalid as the substring chosen overlap.\n\nGiven a string `word`, return _a list of all the possible **generalized abbreviations** of_ `word`. Return the answer in **any order**.\n\n**Example 1:**\n\n**Input:** word = \"word\"\n**Output:** \\[\"4\",\"3d\",\"2r1\",\"2rd\",\"1o2\",\"1o1d\",\"1or1\",\"1ord\",\"w3\",\"w2d\",\"w1r1\",\"w1rd\",\"wo2\",\"wo1d\",\"wor1\",\"word\"\\]\n\n**Example 2:**\n\n**Input:** word = \"a\"\n**Output:** \\[\"1\",\"a\"\\]\n\n**Constraints:**\n\n*   `1 <= word.length <= 15`\n*   `word` consists of only lowercase English letters.", "entry_point": "generalized_abbreviation", "canonical_solutions": {"python": "def generateAbbreviations(word):\n    if not word:\n        return [\"\"]\n    res = []\n    for i in range(len(word) + 1):\n        for item in generateAbbreviations(word[i+1:]):\n            if i == 0 or not item or not item[0].isdigit():\n                res.append(word[:i+1] + item)\n            if item and item[0].isdigit():\n                res.append(word[:i] + '1' + item)\n    return res", "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> generateAbbreviations(String word) {\n    List<String> res = new ArrayList<>();\n    res.add(word.isEmpty() ? \"\" : Integer.toString(word.length()));\n    for (int i = 0; i < word.length(); ++i) {\n        String pre = word.substring(0, i);\n        for (String abbr : generateAbbreviations(word.substring(i + 1))) {\n            int num = abbr.chars().findFirst_NEG_INT().getAsInt();\n            if (abbr.isEmpty() || num > 0) {\n                res.add(pre + '1' + abbr);\n            }\n            if (i == 0 || abbr.isEmpty() || abbr.charAt(0) > '9') {\n                res.add(word.substring(0, i + 1) + abbr);\n            }\n        }\n    }\n    return res;\n}", "cpp": "#include <vector>\n#include <string>\n\nstd::vector<std::string> generateAbbreviations(std::string word) {\n    std::vector<std::string> res;\n    res.push_back(word.empty() ? \"\" : std::to_string(word.size()));\n    for (size_t i = 0; i < word.size(); ++i)\n        for (const std::string &abbr : generateAbbreviations(word.substr(i + 1))) {\n            size_t num;\n            if (abbr.empty() || (num = abbr.find_first_not_of('123456789')) > 0)\n                res.push_back(word.substr(0, i) + '1' + abbr);\n            if (i == 0 || abbr.empty() || abbr[0] > '9')\n                res.push_back(word.substr(0, i + 1) + abbr);\n        }\n    return res;\n}", "javascript": "function generateAbbreviations(word) {\n    if (word === '') {\n        return ['']\n    }\n    const res = []\n    for (let i = 0; i < word.length + 1; i++) {\n        for (const item of generateAbbreviations(word.slice(i + 1))) {\n            if (i === 0 || !item || isNaN(item[0])) {\n                res.push(word.slice(0, i + 1) + item)\n            }\n            if (item && !isNaN(item[0])) {\n                res.push(word.slice(0, i) + '1' + item)\n            }\n        }\n    }\n    return res\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/321", "prompt": "You are given two integer arrays `nums1` and `nums2` of lengths `m` and `n` respectively. `nums1` and `nums2` represent the digits of two numbers. You are also given an integer `k`.\n\nCreate the maximum number of length `k <= m + n` from digits of the two numbers. The relative order of the digits from the same array must be preserved.\n\nReturn an array of the `k` digits representing the answer.\n\n**Example 1:**\n\n**Input:** nums1 = \\[3,4,6,5\\], nums2 = \\[9,1,2,5,8,3\\], k = 5\n**Output:** \\[9,8,6,5,3\\]\n\n**Example 2:**\n\n**Input:** nums1 = \\[6,7\\], nums2 = \\[6,0,4\\], k = 5\n**Output:** \\[6,7,6,0,4\\]\n\n**Example 3:**\n\n**Input:** nums1 = \\[3,9\\], nums2 = \\[8,9\\], k = 3\n**Output:** \\[9,8,9\\]\n\n**Constraints:**\n\n*   `m == nums1.length`\n*   `n == nums2.length`\n*   `1 <= m, n <= 500`\n*   `0 <= nums1[i], nums2[i] <= 9`\n*   `1 <= k <= m + n`", "entry_point": "create_maximum_number", "canonical_solutions": {"python": "function maxNumber(nums1, nums2, k) {\r\n    function maxArray(nums, k) {\r\n        let ans = [];\r\n        for (let i = 0; i < nums.length; i++) {\r\n            while (nums.length - i > k - ans.length && ans.length && ans[ans.length - 1] < nums[i])\r\n                ans.pop();\r\n            if (ans.length < k) ans.push(nums[i]);\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    function merge(nums1, nums2) {\r\n        let ans = [], i = 0, j = 0;\r\n        while (i < nums1.length || j < nums2.length)\r\n            ans.push((nums1.slice(i).join('') >= nums2.slice(j).join('') ? nums1[i++] : nums2[j++]));\r\n        return ans;\r\n    }\r\n\r\n    let result = [];\r\n    for (let i = Math.max(0, k - nums2.length); i <= k && i <= nums1.length; i++) {\r\n        const candidate = merge(maxArray(nums1, i), maxArray(nums2, k - i));\r\n        if (candidate.join('') > result.join('')) result = candidate;\r\n    }\r\n    return result;\r\n}", "java": "public int[] maxNumber(int[] nums1, int[] nums2, int k) {\r\n    int[] ans = new int[k];\r\n    int m = nums1.length, n = nums2.length;\r\n    \r\n    for (int i = Math.max(0, k - n); i <= k && i <= m; i++) {\r\n        int[] candidate = merge(maxArray(nums1, i), maxArray(nums2, k - i), k);\r\n        if (greater(candidate, 0, ans, 0)) ans = candidate;\r\n    }\r\n    return ans;\r\n}\r\n\r\nprivate int[] maxArray(int[] nums, int k) {\r\n    int n = nums.length;\r\n    int[] ans = new int[k];\r\n    for (int i = 0, j = 0; i < n; i++) {\r\n        while (n - i > k - j && j > 0 && ans[j - 1] < nums[i]) j--;\r\n        if (j < k) ans[j++] = nums[i];\r\n    }\r\n    return ans;\r\n}\r\n\r\nprivate int[] merge(int[] nums1, int[] nums2, int k) {\r\n    int[] ans = new int[k];\r\n    for (int i = 0, j = 0, r = 0; r < k; r++)\r\n        ans[r] = greater(nums1, i, nums2, j) ? nums1[i++] : nums2[j++];\r\n    return ans;\r\n}\r\n\r\nprivate boolean greater(int[] nums1, int i, int[] nums2, int j) {\r\n    while (i < nums1.length && j < nums2.length && nums1[i] == nums2[j]) {\r\n        i++;\r\n        j++;\r\n    }\r\n    return j == nums2.length || (i < nums1.length && nums1[i] > nums2[j]);\r\n}", "cpp": "#include <vector>\r\n#include <algorithm>\r\n\r\nstd::vector<int> maxNumber(std::vector<int>& nums1, std::vector<int>& nums2, int k) {\r\n    int m = nums1.size(), n = nums2.size();\r\n    std::vector<int> ans(k, 0);\r\n    for (int i = std::max(0, k - n); i <= k && i <= m; ++i) {\r\n        std::vector<int> candidate = merge(maxArray(nums1, i), maxArray(nums2, k - i), k);\r\n        if (greater(candidate, 0, ans, 0)) ans = candidate;\r\n    }\r\n    return ans;\r\n}\r\n\r\nstd::vector<int> maxArray(std::vector<int>& nums, int k) {\r\n    int n = nums.size();\r\n    std::vector<int> ans(k, 0);\r\n    for (int i = 0, j = 0; i < n; ++i) {\r\n        while (n - i > k - j && j > 0 && ans[j - 1] < nums[i]) j--;\r\n        if (j < k) ans[j++] = nums[i];\r\n    }\r\n    return ans;\r\n}\r\n\r\nstd::vector<int> merge(std::vector<int>& nums1, std::vector<int>& nums2, int k) {\r\n    std::vector<int> ans(k, 0);\r\n    for (int i = 0, j = 0, r = 0; r < k; ++r)\r\n        ans[r] = greater(nums1, i, nums2, j) ? nums1[i++] : nums2[j++];\r\n    return ans;\r\n}\r\n\r\nbool greater(std::vector<int>& nums1, int i, std::vector<int>& nums2, int j) {\r\n    while (i < nums1.size() && j < nums2.size() && nums1[i] == nums2[j]) {\r\n        i++;\r\n        j++;\r\n    }\r\n    return j == nums2.size() || (i < nums1.size() && nums1[i] > nums2[j]);\r\n}", "javascript": "def maxNumber(nums1, nums2, k):\r\n    def maxArray(nums, k):\r\n        ans = []\r\n        for i, num in enumerate(nums):\r\n            while len(ans) + len(nums) - i > k and ans and ans[-1] < num:\r\n                ans.pop()\r\n            if len(ans) < k:\r\n                ans.append(num)\r\n        return ans\r\n\r\n    def merge(nums1, nums2):\r\n        return [max(nums1, nums2).pop(0) for _ in nums1 + nums2]\r\n\r\n    return max(merge(maxArray(nums1, i), maxArray(nums2, k - i))\r\n               for i in range(k + 1)\r\n               if i <= len(nums1) and k - i <= len(nums2))"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/322", "prompt": "You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money.\n\nReturn _the fewest number of coins that you need to make up that amount_. If that amount of money cannot be made up by any combination of the coins, return `-1`.\n\nYou may assume that you have an infinite number of each kind of coin.\n\n**Example 1:**\n\n**Input:** coins = \\[1,2,5\\], amount = 11\n**Output:** 3\n**Explanation:** 11 = 5 + 5 + 1\n\n**Example 2:**\n\n**Input:** coins = \\[2\\], amount = 3\n**Output:** -1\n\n**Example 3:**\n\n**Input:** coins = \\[1\\], amount = 0\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= coins.length <= 12`\n*   `1 <= coins[i] <= 231 - 1`\n*   `0 <= amount <= 104`", "entry_point": "coin_change", "canonical_solutions": {"python": "def coinChange(coins, amount):\n    dp = [amount + 1] * (amount + 1)\n    dp[0] = 0\n\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    return dp[amount] if dp[amount] <= amount else -1", "java": "public int coinChange(int[] coins, int amount) {\n    int[] dp = new int[amount + 1];\n    Arrays.fill(dp, amount + 1);\n    dp[0] = 0;\n    \n    for (int coin : coins) {\n        for (int i = coin; i <= amount; i++) {\n            dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n        }\n    }\n\n    return dp[amount] <= amount ? dp[amount] : -1;\n}", "cpp": "#include <vector>\n#include <algorithm>\n\nint coinChange(std::vector<int>& coins, int amount) {\n    std::vector<int> dp(amount + 1, amount + 1);\n    dp[0] = 0;\n    \n    for (int i = 0; i < coins.size(); i++) {\n        for (int j = coins[i]; j <= amount; j++) {\n            dp[j] = std::min(dp[j], dp[j - coins[i]] + 1);\n        }\n    }\n\n    return dp[amount] <= amount ? dp[amount] : -1;\n}", "javascript": "function coinChange(coins, amount) {\n    const dp = new Array(amount + 1).fill(amount + 1);\n    dp[0] = 0;\n\n    for (const coin of coins) {\n        for (let i = coin; i <= amount; i++) {\n            dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n        }\n    }\n\n    return dp[amount] <= amount ? dp[amount] : -1;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/323", "prompt": "You have a graph of `n` nodes. You are given an integer `n` and an array `edges` where `edges[i] = [ai, bi]` indicates that there is an edge between `ai` and `bi` in the graph.\n\nReturn _the number of connected components in the graph_.\n\n**Example 1:**\n\n**Input:** n = 5, edges = \\[\\[0,1\\],\\[1,2\\],\\[3,4\\]\\]\n**Output:** 2\n\n**Example 2:**\n\n**Input:** n = 5, edges = \\[\\[0,1\\],\\[1,2\\],\\[2,3\\],\\[3,4\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= n <= 2000`\n*   `1 <= edges.length <= 5000`\n*   `edges[i].length == 2`\n*   `0 <= ai <= bi < n`\n*   `ai != bi`\n*   There are no repeated edges.", "entry_point": "number_of_connected_components_in_an_undirected_graph", "canonical_solutions": {"python": "def countComponents(n, edges):\n    adj_list = [[] for _ in range(n)]\n    for edge in edges:\n        adj_list[edge[0]].append(edge[1])\n        adj_list[edge[1]].append(edge[0])\n\n    visited = [False] * n\n    connected_components = 0\n\n    def dfs(node):\n        visited[node] = True\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n\n    for i in range(n):\n        if not visited[i]:\n            dfs(i)\n            connected_components += 1\n\n    return connected_components", "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic int countComponents(int n, int[][] edges) {\n    List<List<Integer>> adjList = new ArrayList<>();\n    for (int i = 0; i < n; i++) {\n        adjList.add(new ArrayList<>());\n    }\n    for (int[] edge : edges) {\n        adjList.get(edge[0]).add(edge[1]);\n        adjList.get(edge[1]).add(edge[0]);\n    }\n\n    boolean[] visited = new boolean[n];\n    int connectedComponents = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            dfs(i, visited, adjList);\n            connectedComponents++;\n        }\n    }\n    return connectedComponents;\n}\n\nvoid dfs(int node, boolean[] visited, List<List<Integer>> adjList) {\n    visited[node] = true;\n    for (int neighbor : adjList.get(node)) {\n        if (!visited[neighbor]) {\n            dfs(neighbor, visited, adjList);\n        }\n    }\n}", "cpp": "#include <vector>\n\nint countComponents(int n, std::vector<std::vector<int>>& edges) {\n    std::vector<std::vector<int>> adjList(n);\n    for (const auto& edge : edges) {\n        adjList[edge[0]].push_back(edge[1]);\n        adjList[edge[1]].push_back(edge[0]);\n    }\n    \n    std::vector<bool> visited(n, false);\n    int connectedComponents = 0;\n\n    for (int i = 0; i < n; ++i) {\n        if (!visited[i]) {\n            std::function<void(int)> dfs = [&](int node) {\n                visited[node] = true;\n                for (int neighbor : adjList[node]) {\n                    if (!visited[neighbor]) {\n                        dfs(neighbor);\n                    }\n                }\n            };\n            dfs(i);\n            connectedComponents++;\n        }\n    }\n    return connectedComponents;\n}", "javascript": "function countComponents(n, edges) {\n    const adjList = new Array(n).fill(0).map(() => []);\n    for (const edge of edges) {\n        adjList[edge[0]].push(edge[1]);\n        adjList[edge[1]].push(edge[0]);\n    }\n\n    const visited = new Array(n).fill(false);\n    let connectedComponents = 0;\n\n    function dfs(node) {\n        visited[node] = true;\n        for (const neighbor of adjList[node]) {\n            if (!visited[neighbor]) {\n                dfs(neighbor);\n            }\n        }\n    }\n\n    for (let i = 0; i < n; i++) {\n        if (!visited[i]) {\n            dfs(i);\n            connectedComponents++;\n        }\n    }\n    return connectedComponents;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/324", "prompt": "Given an integer array `nums`, reorder it such that `nums[0] < nums[1] > nums[2] < nums[3]...`.\n\nYou may assume the input array always has a valid answer.\n\n**Example 1:**\n\n**Input:** nums = \\[1,5,1,1,6,4\\]\n**Output:** \\[1,6,1,5,1,4\\]\n**Explanation:** \\[1,4,1,5,1,6\\] is also accepted.\n\n**Example 2:**\n\n**Input:** nums = \\[1,3,2,2,3,1\\]\n**Output:** \\[2,3,1,3,1,2\\]\n\n**Constraints:**\n\n*   `1 <= nums.length <= 5 * 104`\n*   `0 <= nums[i] <= 5000`\n*   It is guaranteed that there will be an answer for the given input `nums`.\n\n**Follow Up:** Can you do it in `O(n)` time and/or **in-place** with `O(1)` extra space?", "entry_point": "wiggle_sort_ii", "canonical_solutions": {"python": "def wiggleSort(nums):\n    nums.sort()\n    for i in range(1, len(nums) - 1, 2):\n        nums[i], nums[i + 1] = nums[i + 1], nums[i]", "java": "import java.util.Arrays;\npublic void wiggleSort(int[] nums) {\n    Arrays.sort(nums);\n    for (int i = 1; i < nums.length - 1; i += 2) {\n        int temp = nums[i];\n        nums[i] = nums[i + 1];\n        nums[i + 1] = temp;\n    }\n}", "cpp": "#include <algorithm>\nvoid wiggleSort(vector<int>& nums) {\n    sort(nums.begin(), nums.end());\n    for (int i = 1; i < nums.size() - 1; i += 2) {\n        swap(nums[i], nums[i + 1]);\n    }\n}", "javascript": "function wiggleSort(nums) {\n    nums.sort((a, b) => a - b);\n    for (let i = 1; i < nums.length - 1; i += 2) {\n        [nums[i], nums[i + 1]] = [nums[i + 1], nums[i]];\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/325", "prompt": "Given an integer array `nums` and an integer `k`, return _the maximum length of a_ _subarray_ _that sums to_ `k`. If there is not one, return `0` instead.\n\n**Example 1:**\n\n**Input:** nums = \\[1,-1,5,-2,3\\], k = 3\n**Output:** 4\n**Explanation:** The subarray \\[1, -1, 5, -2\\] sums to 3 and is the longest.\n\n**Example 2:**\n\n**Input:** nums = \\[-2,-1,2,1\\], k = 1\n**Output:** 2\n**Explanation:** The subarray \\[-1, 2\\] sums to 1 and is the longest.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 2 * 105`\n*   `-104 <= nums[i] <= 104`\n*   `-109 <= k <= 109`", "entry_point": "maximum_size_subarray_sum_equals_k", "canonical_solutions": {"python": "def maxSubArrayLen(nums: List[int], k: int) -> int:\n    sum_index = {}\n    maxLength = sum = 0\n    for i, num in enumerate(nums):\n        sum += num\n        if sum == k:\n            maxLength = i + 1\n        if sum - k in sum_index:\n            maxLength = max(maxLength, i - sum_index[sum - k])\n        if sum not in sum_index:\n            sum_index[sum] = i\n    return maxLength", "java": "public int maxSubArrayLen(int[] nums, int k) {\n    Map<Integer, Integer> sumIndex = new HashMap<>();\n    int maxLength = 0, sum = 0;\n    for(int i = 0; i < nums.length; i++) {\n        sum += nums[i];\n        if (sum == k) maxLength = i + 1;\n        if (sumIndex.containsKey(sum - k)) maxLength = Math.max(maxLength, i - sumIndex.get(sum - k));\n        if (!sumIndex.containsKey(sum)) sumIndex.put(sum, i);\n    }\n    return maxLength;\n}", "cpp": "int maxSubArrayLen(vector<int>& nums, int k) {\n    unordered_map<int, int> sumIndex;\n    int maxLength = 0, sum = 0;\n    for(int i = 0; i < nums.size(); i++) {\n        sum += nums[i];\n        if(sum == k) maxLength = i + 1;\n        if(sumIndex.count(sum - k)) maxLength = max(maxLength, i - sumIndex[sum - k]);\n        if(!sumIndex.count(sum)) sumIndex[sum] = i;\n    }\n    return maxLength;\n}", "javascript": "function maxSubArrayLen(nums, k) {\n    let sumIndex = new Map();\n    let maxLength = 0, sum = 0;\n    for (let i = 0; i < nums.length; i++) {\n        sum += nums[i];\n        if (sum === k) maxLength = i + 1;\n        if (sumIndex.has(sum - k)) maxLength = Math.max(maxLength, i - sumIndex.get(sum - k));\n        if (!sumIndex.has(sum)) sumIndex.set(sum, i);\n    }\n    return maxLength;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/326", "prompt": "Given an integer `n`, return _`true` if it is a power of three. Otherwise, return `false`_.\n\nAn integer `n` is a power of three, if there exists an integer `x` such that `n == 3x`.\n\n**Example 1:**\n\n**Input:** n = 27\n**Output:** true\n**Explanation:** 27 = 33\n\n**Example 2:**\n\n**Input:** n = 0\n**Output:** false\n**Explanation:** There is no x where 3x = 0.\n\n**Example 3:**\n\n**Input:** n = -1\n**Output:** false\n**Explanation:** There is no x where 3x = (-1).\n\n**Constraints:**\n\n*   `-231 <= n <= 231 - 1`\n\n**Follow up:** Could you solve it without loops/recursion?", "entry_point": "power_of_three", "canonical_solutions": {"python": "def is_power_of_three(n: int) -> bool:\n    if n < 1:\n        return False\n    \n    while n % 3 == 0:\n        n //= 3\n    \n    return n == 1", "java": "public boolean isPowerOfThree(int n) {\n    if (n < 1) {\n        return false;\n    }\n    \n    while (n % 3 == 0) {\n        n /= 3;\n    }\n    \n    return n == 1;\n}", "cpp": "bool isPowerOfThree(int n) {\n    if (n < 1) {\n        return false;\n    }\n    \n    while (n % 3 == 0) {\n        n /= 3;\n    }\n    \n    return n == 1;\n}", "javascript": "function isPowerOfThree(n) {\n    if (n < 1) {\n        return false;\n    }\n    \n    while (n % 3 === 0) {\n        n /= 3;\n    }\n    \n    return n === 1;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/327", "prompt": "Given an integer array `nums` and two integers `lower` and `upper`, return _the number of range sums that lie in_ `[lower, upper]` _inclusive_.\n\nRange sum `S(i, j)` is defined as the sum of the elements in `nums` between indices `i` and `j` inclusive, where `i <= j`.\n\n**Example 1:**\n\n**Input:** nums = \\[-2,5,-1\\], lower = -2, upper = 2\n**Output:** 3\n**Explanation:** The three ranges are: \\[0,0\\], \\[2,2\\], and \\[0,2\\] and their respective sums are: -2, -1, 2.\n\n**Example 2:**\n\n**Input:** nums = \\[0\\], lower = 0, upper = 0\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-231 <= nums[i] <= 231 - 1`\n*   `-105 <= lower <= upper <= 105`\n*   The answer is **guaranteed** to fit in a **32-bit** integer.", "entry_point": "count_of_range_sum", "canonical_solutions": {"python": "def countRangeSum(nums, lower, upper):\n    sums = [0] * (len(nums) + 1)\n    for i in range(len(nums)):\n        sums[i + 1] = sums[i] + nums[i]\n\n    def mergeSort(start, end):\n        if start == end:\n            return 0\n        mid = start + (end - start) // 2\n        count = mergeSort(start, mid) + mergeSort(mid + 1, end)\n\n        j, k = mid + 1, mid + 1\n        for i in range(start, mid + 1):\n            while j <= end and sums[j] - sums[i] < lower: j += 1\n            while k <= end and sums[k] - sums[i] <= upper: k += 1\n            count += k - j\n\n        sums[start:end + 1] = sorted(sums[start:end + 1])\n        return count\n\n    return mergeSort(0, len(nums))", "java": "public int countRangeSum(int[] nums, int lower, int upper) {\n    long[] sums = new long[nums.length + 1];\n    for (int i = 0; i < nums.length; ++i)\n        sums[i + 1] = sums[i] + nums[i];\n\n    return countWhileMergeSort(sums, lower, upper, 0, nums.length);\n}\n\nprivate int countWhileMergeSort(long[] sums, int lower, int upper, int start, int end) {\n    if (start >= end)\n        return 0;\n\n    int mid = start + (end - start) / 2;\n    int count = countWhileMergeSort(sums, lower, upper, start, mid) + countWhileMergeSort(sums, lower, upper, mid + 1, end);\n\n    int j = mid + 1, k = mid + 1;\n    for (int i = start; i <= mid; ++i) {\n        while (j <= end && sums[j] - sums[i] < lower) ++j;\n        while (k <= end && sums[k] - sums[i] <= upper) ++k;\n        count += k - j;\n    }\n\n    Arrays.sort(sums, start, end + 1);\n    return count;\n}", "cpp": "int countRangeSum(vector<int>& nums, int lower, int upper) {\n    int n = nums.size();\n    vector<long> sums(n + 1, 0);\n    for (int i = 0; i < n; ++i)\n        sums[i + 1] = sums[i] + nums[i];\n\n    function<int(int, int)> mergeSort = [&](int start, int end) {\n        if (start == end)\n            return 0;\n        int mid = start + (end - start) / 2;\n        int count = mergeSort(start, mid) + mergeSort(mid + 1, end);\n\n        int j = mid + 1, k = mid + 1;\n        for (int i = start; i <= mid; ++i) {\n            while (j <= end && sums[j] - sums[i] < lower) ++j;\n            while (k <= end && sums[k] - sums[i] <= upper) ++k;\n            count += k - j;\n        }\n\n        inplace_merge(sums.begin() + start, sums.begin() + mid + 1, sums.begin() + end + 1);\n        return count;\n    };\n\n    return mergeSort(0, n);\n}", "javascript": "function countRangeSum(nums, lower, upper) {\n    let sums = new Array(nums.length + 1).fill(0);\n    for (let i = 0; i < nums.length; ++i)\n        sums[i + 1] = sums[i] + nums[i];\n\n    function mergeSort(start, end) {\n        if (start === end)\n            return 0;\n        let mid = start + Math.floor((end - start) / 2);\n        let count = mergeSort(start, mid) + mergeSort(mid + 1, end);\n\n        let j = mid + 1, k = mid + 1;\n        for (let i = start; i <= mid; ++i) {\n            while (j <= end && sums[j] - sums[i] < lower) ++j;\n            while (k <= end && sums[k] - sums[i] <= upper) ++k;\n            count += k - j;\n        }\n\n        let sortedPart = sums.slice(start, end + 1).sort((a, b) => a - b);\n        for (let i = start; i <= end; ++i) {\n            sums[i] = sortedPart[i - start];\n        }\n\n        return count;\n    };\n\n    return mergeSort(0, nums.length);\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/328", "prompt": "Given the `head` of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return _the reordered list_.\n\nThe **first** node is considered **odd**, and the **second** node is **even**, and so on.\n\nNote that the relative order inside both the even and odd groups should remain as it was in the input.\n\nYou must solve the problem in `O(1)` extra space complexity and `O(n)` time complexity.\n\n**Example 1:**\n\n**Input:** head = \\[1,2,3,4,5\\]\n**Output:** \\[1,3,5,2,4\\]\n\n**Example 2:**\n\n**Input:** head = \\[2,1,3,5,6,4,7\\]\n**Output:** \\[2,3,6,7,1,5,4\\]\n\n**Constraints:**\n\n*   The number of nodes in the linked list is in the range `[0, 104]`.\n*   `-106 <= Node.val <= 106`", "entry_point": "odd_even_linked_list", "canonical_solutions": {"python": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef odd_even_list(head: ListNode) -> ListNode:\n    if not head:\n        return None\n    odd, even, even_head = head, head.next, head.next\n    while even and even.next:\n        odd.next = even.next\n        odd = odd.next\n        even.next = odd.next\n        even = even.next\n    odd.next = even_head\n    return head", "java": "public class ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\npublic ListNode oddEvenList(ListNode head) {\n    if (head == null) return null;\n    ListNode odd = head, even = head.next, evenHead = even;\n    while (even != null && even.next != null) {\n        odd.next = even.next;\n        odd = odd.next;\n        even.next = odd.next;\n        even = even.next;\n    }\n    odd.next = evenHead;\n    return head;\n}", "cpp": "struct ListNode {\n     int val;\n     ListNode *next;\n     ListNode() : val(0), next(nullptr) {}\n     ListNode(int x) : val(x), next(nullptr) {}\n     ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nListNode* oddEvenList(ListNode* head) {\n    if (!head) return nullptr;\n    ListNode *odd = head, *even = head->next, *even_head = even;\n    while (even && even->next) {\n        odd->next = even->next;\n        odd = odd->next;\n        even->next = odd->next;\n        even = even->next;\n    }\n    odd->next = even_head;\n    return head;\n}", "javascript": "class ListNode {\n    constructor(val, next = null) {\n        this.val = val;\n        this.next = next;\n    }\n}\n\nfunction oddEvenList(head) {\n    if (!head) return null;\n    let odd = head,\n        even = head.next,\n        evenHead = even;\n    while (even && even.next) {\n        odd.next = even.next;\n        odd = odd.next;\n        even.next = odd.next;\n        even = even.next;\n    }\n    odd.next = evenHead;\n    return head;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/329", "prompt": "Given an `m x n` integers `matrix`, return _the length of the longest increasing path in_ `matrix`.\n\nFrom each cell, you can either move in four directions: left, right, up, or down. You **may not** move **diagonally** or move **outside the boundary** (i.e., wrap-around is not allowed).\n\n**Example 1:**\n\n**Input:** matrix = \\[\\[9,9,4\\],\\[6,6,8\\],\\[2,1,1\\]\\]\n**Output:** 4\n**Explanation:** The longest increasing path is `[1, 2, 6, 9]`.\n\n**Example 2:**\n\n**Input:** matrix = \\[\\[3,4,5\\],\\[3,2,6\\],\\[2,2,1\\]\\]\n**Output:** 4\n**Explanation:** The longest increasing path is `[3, 4, 5, 6]`. Moving diagonally is not allowed.\n\n**Example 3:**\n\n**Input:** matrix = \\[\\[1\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `m == matrix.length`\n*   `n == matrix[i].length`\n*   `1 <= m, n <= 200`\n*   `0 <= matrix[i][j] <= 231 - 1`", "entry_point": "longest_increasing_path_in_a_matrix", "canonical_solutions": {"python": "dx = (0, 0, 1, -1)\ndy = (1, -1, 0, 0)\n\ndef dfs(matrix, memo, i, j):\n    if memo[i][j] != 0:\n        return memo[i][j]\n    \n    max_len = 0\n    for k in range(4):\n        ni, nj = i + dx[k], j + dy[k]\n        if (0 <= ni < len(matrix) and 0 <= nj < len(matrix[0]) and matrix[ni][nj] > matrix[i][j]):\n            max_len = max(max_len, dfs(matrix, memo, ni, nj))\n    \n    memo[i][j] = max_len + 1\n    return memo[i][j]\n\ndef longest_increasing_path(matrix):\n    m, n = len(matrix), len(matrix[0])\n    \n    memo = [[0] * n for _ in range(m)]\n    \n    ans = 0\n    for i in range(m):\n        for j in range(n):\n            ans = max(ans, dfs(matrix, memo, i, j))\n    \n    return ans", "java": "int[] dx = {0, 0, 1, -1};\nint[] dy = {1, -1, 0, 0};\n\npublic int dfs(int[][] matrix, int[][] memo, int i, int j) {\n    if (memo[i][j] != 0) return memo[i][j];\n    \n    int max_len = 0;\n    for (int k = 0; k < 4; ++k) {\n        int ni = i + dx[k], nj = j + dy[k];\n        if (ni >= 0 && ni < matrix.length && nj >= 0 && nj < matrix[0].length && matrix[ni][nj] > matrix[i][j]) {\n            max_len = Math.max(max_len, dfs(matrix, memo, ni, nj));\n        }\n    }\n    \n    memo[i][j] = max_len + 1;\n    return memo[i][j];\n}\n\npublic int longestIncreasingPath(int[][] matrix) {\n    int m = matrix.length, n = matrix[0].length;\n    \n    int[][] memo = new int[m][n];\n    \n    int ans = 0;\n    for (int i = 0; i < m; ++i)\n        for (int j = 0; j < n; ++j)\n            ans = Math.max(ans, dfs(matrix, memo, i, j));\n    \n    return ans;\n}", "cpp": "int dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nint dfs(vector<vector<int>>& matrix, vector<vector<int>>& memo, int i, int j) {\n    if (memo[i][j] != 0) return memo[i][j];\n    \n    int max_len = 0;\n    for (int k = 0; k < 4; ++k) {\n        int ni = i + dx[k], nj = j + dy[k];\n        if (ni >= 0 && ni < matrix.size() && nj >= 0 && nj < matrix[0].size() && matrix[ni][nj] > matrix[i][j]) {\n            max_len = max(max_len, dfs(matrix, memo, ni, nj));\n        }\n    }\n    \n    memo[i][j] = max_len + 1;\n    return memo[i][j];\n}\n\nint longestIncreasingPath(vector<vector<int>>& matrix) {\n    int m = matrix.size(), n = matrix[0].size();\n    \n    vector<vector<int>> memo(m, vector<int>(n, 0));\n    \n    int ans = 0;\n    for (int i = 0; i < m; ++i)\n        for (int j = 0; j < n; ++j)\n            ans = max(ans, dfs(matrix, memo, i, j));\n    \n    return ans;\n}", "javascript": "const dx = [0, 0, 1, -1];\nconst dy = [1, -1, 0, 0];\n\nfunction dfs(matrix, memo, i, j) {\n    if (memo[i][j] !== 0) return memo[i][j];\n    \n    let max_len = 0;\n    for (let k = 0; k < 4; ++k) {\n        const ni = i + dx[k], nj = j + dy[k];\n        if (ni >= 0 && ni < matrix.length && nj >= 0 && nj < matrix[0].length && matrix[ni][nj] > matrix[i][j]) {\n            max_len = Math.max(max_len, dfs(matrix, memo, ni, nj));\n        }\n    }\n    \n    memo[i][j] = max_len + 1;\n    return memo[i][j];\n}\n\nfunction longestIncreasingPath(matrix) {\n    const m = matrix.length, n = matrix[0].length;\n    \n    const memo = Array.from({length: m}, () => Array.from({length: n}, () => 0));\n    \n    let ans = 0;\n    for (let i = 0; i < m; ++i) {\n        for (let j = 0; j < n; ++j) {\n            ans = Math.max(ans, dfs(matrix, memo, i, j));\n        }\n    }\n    \n    return ans;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/330", "prompt": "Given a sorted integer array `nums` and an integer `n`, add/patch elements to the array such that any number in the range `[1, n]` inclusive can be formed by the sum of some elements in the array.\n\nReturn _the minimum number of patches required_.\n\n**Example 1:**\n\n**Input:** nums = \\[1,3\\], n = 6\n**Output:** 1\nExplanation:\nCombinations of nums are \\[1\\], \\[3\\], \\[1,3\\], which form possible sums of: 1, 3, 4.\nNow if we add/patch 2 to nums, the combinations are: \\[1\\], \\[2\\], \\[3\\], \\[1,3\\], \\[2,3\\], \\[1,2,3\\].\nPossible sums are 1, 2, 3, 4, 5, 6, which now covers the range \\[1, 6\\].\nSo we only need 1 patch.\n\n**Example 2:**\n\n**Input:** nums = \\[1,5,10\\], n = 20\n**Output:** 2\nExplanation: The two patches can be \\[2, 4\\].\n\n**Example 3:**\n\n**Input:** nums = \\[1,2,2\\], n = 5\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `1 <= nums[i] <= 104`\n*   `nums` is sorted in **ascending order**.\n*   `1 <= n <= 231 - 1`", "entry_point": "patching_array", "canonical_solutions": {"python": "def minPatches(nums, n):\n    max_sum = 0\n    patches = 0\n    i = 0\n\n    while max_sum < n:\n        if i < len(nums) and nums[i] <= max_sum + 1:\n            max_sum += nums[i]\n            i += 1\n        else:\n            max_sum += max_sum + 1\n            patches += 1\n\n    return patches", "java": "public int minPatches(int[] nums, int n) {\n    long maxSum = 0;\n    int patches = 0, i = 0;\n    \n    while (maxSum < n) {\n        if (i < nums.length && nums[i] <= maxSum + 1) {\n            maxSum += nums[i];\n            i++;\n        } else {\n            maxSum += maxSum + 1;\n            patches++;\n        }\n    }\n    return patches;\n}", "cpp": "int minPatches(vector<int>& nums, int n) {\n    long long maxSum = 0;\n    int patches = 0, i = 0;\n    \n    while (maxSum < n) {\n        if (i < nums.size() && nums[i] <= maxSum + 1) {\n            maxSum += nums[i];\n            i++;\n        } else {\n            maxSum += maxSum + 1;\n            patches++;\n        }\n    }\n    return patches;\n}", "javascript": "function minPatches(nums, n) {\n    let maxSum = 0;\n    let patches = 0;\n    let i = 0;\n\n    while (maxSum < n) {\n        if (i < nums.length && nums[i] <= maxSum + 1) {\n            maxSum += nums[i];\n            i++;\n        } else {\n            maxSum += maxSum + 1;\n            patches++;\n        }\n    }\n    return patches;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/331", "prompt": "One way to serialize a binary tree is to use **preorder traversal**. When we encounter a non-null node, we record the node's value. If it is a null node, we record using a sentinel value such as `'#'`.\n\nFor example, the above binary tree can be serialized to the string `\"9,3,4,#,#,1,#,#,2,#,6,#,# \"`, where `'#'` represents a null node.\n\nGiven a string of comma-separated values `preorder`, return `true` if it is a correct preorder traversal serialization of a binary tree.\n\nIt is **guaranteed** that each comma-separated value in the string must be either an integer or a character `'#'` representing null pointer.\n\nYou may assume that the input format is always valid.\n\n*   For example, it could never contain two consecutive commas, such as `\"1,,3 \"`.\n\n**Note:** You are not allowed to reconstruct the tree.\n\n**Example 1:**\n\n**Input:** preorder = \"9,3,4,#,#,1,#,#,2,#,6,#,#\"\n**Output:** true\n\n**Example 2:**\n\n**Input:** preorder = \"1,#\"\n**Output:** false\n\n**Example 3:**\n\n**Input:** preorder = \"9,#,#,1\"\n**Output:** false\n\n**Constraints:**\n\n*   `1 <= preorder.length <= 104`\n*   `preorder` consist of integers in the range `[0, 100]` and `'#'` separated by commas `','`.", "entry_point": "verify_preorder_serialization_of_a_binary_tree", "canonical_solutions": {"python": "def is_valid_serialization(preorder: str) -> bool:\n    nodes = preorder.split(',')\n    node_count = 1\n\n    for node in nodes:\n        node_count -= 1\n        if node_count < 0:\n            return False\n        if node != '#':\n            node_count += 2\n\n    return node_count == 0", "java": "public boolean isValidSerialization(String preorder) {\n    String[] nodes = preorder.split(\",\");\n    int node_count = 1;\n\n    for (String node : nodes) {\n        node_count--;\n\n        if (node_count < 0) return false;\n        if (!node.equals(\"#\")) node_count += 2;\n    }\n\n    return node_count == 0;\n}", "cpp": "#include <string>\n#include <sstream>\n#include <vector>\n\nbool isValidSerialization(const std::string &preorder) {\n    std::istringstream iss(preorder);\n    std::string token;\n    int node_count = 1;\n\n    while (std::getline(iss, token, ',')) {\n        --node_count;\n        if (node_count < 0) return false;\n        if (token != \"#\") node_count += 2;\n    }\n\n    return node_count == 0;\n}", "javascript": "function isValidSerialization(preorder) {\n    const nodes = preorder.split(',');\n    let node_count = 1;\n\n    for (let node of nodes) {\n        node_count--;\n\n        if (node_count < 0) return false;\n        if (node !== '#') node_count += 2;\n    }\n\n    return node_count === 0;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/332", "prompt": "You are given a list of airline `tickets` where `tickets[i] = [fromi, toi]` represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.\n\nAll of the tickets belong to a man who departs from `\"JFK \"`, thus, the itinerary must begin with `\"JFK \"`. If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.\n\n*   For example, the itinerary `[ \"JFK \", \"LGA \"]` has a smaller lexical order than `[ \"JFK \", \"LGB \"]`.\n\nYou may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.\n\n**Example 1:**\n\n**Input:** tickets = \\[\\[ \"MUC \", \"LHR \"\\],\\[ \"JFK \", \"MUC \"\\],\\[ \"SFO \", \"SJC \"\\],\\[ \"LHR \", \"SFO \"\\]\\]\n**Output:** \\[ \"JFK \", \"MUC \", \"LHR \", \"SFO \", \"SJC \"\\]\n\n**Example 2:**\n\n**Input:** tickets = \\[\\[ \"JFK \", \"SFO \"\\],\\[ \"JFK \", \"ATL \"\\],\\[ \"SFO \", \"ATL \"\\],\\[ \"ATL \", \"JFK \"\\],\\[ \"ATL \", \"SFO \"\\]\\]\n**Output:** \\[ \"JFK \", \"ATL \", \"JFK \", \"SFO \", \"ATL \", \"SFO \"\\]\n**Explanation:** Another possible reconstruction is \\[ \"JFK \", \"SFO \", \"ATL \", \"JFK \", \"ATL \", \"SFO \"\\] but it is larger in lexical order.\n\n**Constraints:**\n\n*   `1 <= tickets.length <= 300`\n*   `tickets[i].length == 2`\n*   `fromi.length == 3`\n*   `toi.length == 3`\n*   `fromi` and `toi` consist of uppercase English letters.\n*   `fromi != toi`", "entry_point": "reconstruct_itinerary", "canonical_solutions": {"python": "from collections import defaultdict\n\ndef findItinerary(tickets):\n    flights = defaultdict(list)\n    itinerary = []\n\n    for ticket in tickets:\n        flights[ticket[0]].append(ticket[1])\n        flights[ticket[0]].sort(reverse=True)\n\n    def dfs(airport):\n        while flights[airport]:\n            dfs(flights[airport].pop())\n        itinerary.append(airport)\n\n    dfs(\"JFK\")\n    \n    return itinerary[::-1]", "java": "import java.util.*;\n\nclass Solution {\n    public List<String> findItinerary(List<List<String>> tickets) {\n        HashMap<String, PriorityQueue<String>> flights = new HashMap<>();\n        LinkedList<String> itinerary = new LinkedList<>();\n        \n        for (List<String> ticket : tickets) {\n            flights.putIfAbsent(ticket.get(0), new PriorityQueue<>());\n            flights.get(ticket.get(0)).offer(ticket.get(1));\n        }\n        \n        Stack<String> dfs = new Stack<>();\n        dfs.push(\"JFK\");\n        \n        while (!dfs.isEmpty()) {\n            String nextAirport = dfs.peek();\n            if (flights.get(nextAirport) == null || flights.get(nextAirport).isEmpty()) {\n                itinerary.addFirst(dfs.pop());\n            } else {\n                dfs.push(flights.get(nextAirport).poll());\n            }\n        }\n        \n        return itinerary;\n    }\n}", "cpp": "#include <vector>\n#include <string>\n#include <unordered_map>\n#include <set>\n\nusing namespace std;\n\nvector<string> findItinerary(vector<vector<string>>& tickets) {\n    unordered_map<string, multiset<string>> flights;\n    vector<string> itinerary;\n    \n    for (const auto& ticket : tickets)\n        flights[ticket[0]].insert(ticket[1]);\n    \n    stack<string> dfs;\n    dfs.push(\"JFK\");\n    \n    while (!dfs.empty()) {\n        string next_airport = dfs.top();\n        if (flights[next_airport].empty()) {\n            itinerary.push_back(next_airport);\n            dfs.pop();\n        } else {\n            dfs.push(*flights[next_airport].begin());\n            flights[next_airport].erase(flights[next_airport].begin());\n        }\n    }\n    \n    reverse(itinerary.begin(), itinerary.end());\n    return itinerary;\n}", "javascript": "function findItinerary(tickets) {\n    const flights = {};\n    const itinerary = [];\n\n    for (const ticket of tickets) {\n        if (!flights[ticket[0]]) {\n            flights[ticket[0]] = [];\n        }\n        flights[ticket[0]].push(ticket[1]);\n        flights[ticket[0]].sort((a, b) => b.localeCompare(a));\n    }\n\n    function dfs(airport) {\n        while (flights[airport] && flights[airport].length > 0) {\n            dfs(flights[airport].pop());\n        }\n        itinerary.push(airport);\n    }\n\n    dfs(\"JFK\");\n    \n    return itinerary.reverse();\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/333", "prompt": "Given the root of a binary tree, find the largest subtree, which is also a Binary Search Tree (BST), where the largest means subtree has the largest number of nodes.\n\nA **Binary Search Tree (BST)** is a tree in which all the nodes follow the below-mentioned properties:\n\n*   The left subtree values are less than the value of their parent (root) node's value.\n*   The right subtree values are greater than the value of their parent (root) node's value.\n\n**Note:** A subtree must include all of its descendants.\n\n**Example 1:**\n\n**Input:** root = \\[10,5,15,1,8,null,7\\]\n**Output:** 3\n**Explanation:** The Largest BST Subtree in this case is the highlighted one. The return value is the subtree's size, which is 3.\n\n**Example 2:**\n\n**Input:** root = \\[4,2,7,2,3,5,null,2,null,null,null,null,null,1\\]\n**Output:** 2\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 104]`.\n*   `-104 <= Node.val <= 104`\n\n**Follow up:** Can you figure out ways to solve it with `O(n)` time complexity?", "entry_point": "largest_bst_subtree", "canonical_solutions": {"python": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef largestBSTSubtree(root: TreeNode) -> int:\n    def largestBSTUtil(root):\n        if not root:\n            return True, 0, float('inf'), float('-inf')\n        \n        left = largestBSTUtil(root.left)\n        right = largestBSTUtil(root.right)\n        \n        if left[0] and root.val > left[3] and right[0] and root.val < right[2]:\n            largestBST[0] = max(largestBST[0], left[1] + 1 + right[1])\n            return True, left[1] + 1 + right[1], min(root.val, left[2]), max(root.val, right[3])\n        \n        return False, -1, float('inf'), float('-inf')\n    \n    largestBST = [0]\n    largestBSTUtil(root)\n    \n    return largestBST[0]", "java": "class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n}\n\nclass TreeInfo {\n    boolean isBST;\n    int size;\n    int minValue;\n    int maxValue;\n\n    TreeInfo(boolean isBST, int size, int minValue, int maxValue) {\n        this.isBST = isBST;\n        this.size = size;\n        this.minValue = minValue;\n        this.maxValue = maxValue;\n    }\n}\n\npublic int largestBSTSubtree(TreeNode root) {\n    return largestBSTUtil(root, new int[1]).size;\n}\n\nprivate TreeInfo largestBSTUtil(TreeNode root, int[] largestBST) {\n    if (root == null) return new TreeInfo(true, 0, Integer.MAX_VALUE, Integer.MIN_VALUE);\n\n    TreeInfo left = largestBSTUtil(root.left, largestBST);\n    TreeInfo right = largestBSTUtil(root.right, largestBST);\n\n    if (left.isBST && root.val > left.maxValue && right.isBST && root.val <right.minValue) {\n        largestBST[0] = Math.max(largestBST[0], left.size + 1 + right.size);\n        return new TreeInfo(true, left.size + 1 + right.size, Math.min(root.val, left.minValue), Math.max(root.val, right.maxValue));\n    }\n\n    return new TreeInfo(false, -1, Integer.MAX_VALUE, Integer.MIN_VALUE);\n}", "cpp": "struct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n};\n\nstruct TreeInfo {\n    bool isBST;\n    int size;\n    int minValue;\n    int maxValue;\n};\n\nTreeInfo largestBSTUtil(TreeNode* root, int &largestBST) {\n    if (!root) return {true, 0, INT_MAX, INT_MIN};\n\n    TreeInfo left = largestBSTUtil(root->left, largestBST);\n    TreeInfo right = largestBSTUtil(root->right, largestBST);\n\n    if (left.isBST && root->val > left.maxValue && right.isBST && root->val < right.minValue) {\n        largestBST = max(largestBST, left.size + 1 + right.size);\n        return {true, left.size + 1 + right.size, min(root->val, left.minValue), max(root->val, right.maxValue)};\n    }\n\n    return {false, -1, INT_MAX, INT_MIN};\n}\n\nint largestBSTSubtree(TreeNode* root) {\n    int largestBST = 0;\n    largestBSTUtil(root, largestBST);\n    return largestBST;\n}", "javascript": "class TreeNode {\n    constructor(val, left, right) {\n        this.val = (val===undefined ? 0 : val);\n        this.left = (left===undefined ? null : left);\n        this.right = (right===undefined ? null : right);\n    }\n}\n\nfunction largestBSTSubtree(root) {\n    function largestBSTUtil(root, largestBST) {\n        if (!root) return [true, 0, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER];\n\n        let left = largestBSTUtil(root.left, largestBST);\n        let right = largestBSTUtil(root.right, largestBST);\n\n        if (left[0] && root.val > left[3] && right[0] && root.val < right[2]) {\n            largestBST[0] = Math.max(largestBST[0], left[1] + 1 + right[1]);\n            return [true, left[1] + 1 + right[1], Math.min(root.val, left[2]), Math.max(root.val, right[3])];\n        }\n\n        return [false, -1, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER];\n    }\n\n    let largestBST = [0];\n    largestBSTUtil(root, largestBST);\n\n    return largestBST[0];\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/334", "prompt": "Given an integer array `nums`, return `true` _if there exists a triple of indices_ `(i, j, k)` _such that_ `i < j < k` _and_ `nums[i] < nums[j] < nums[k]`. If no such indices exists, return `false`.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3,4,5\\]\n**Output:** true\n**Explanation:** Any triplet where i < j < k is valid.\n\n**Example 2:**\n\n**Input:** nums = \\[5,4,3,2,1\\]\n**Output:** false\n**Explanation:** No triplet exists.\n\n**Example 3:**\n\n**Input:** nums = \\[2,1,5,0,4,6\\]\n**Output:** true\n**Explanation:** The triplet (3, 4, 5) is valid because nums\\[3\\] == 0 < nums\\[4\\] == 4 < nums\\[5\\] == 6.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 5 * 105`\n*   `-231 <= nums[i] <= 231 - 1`\n\n**Follow up:** Could you implement a solution that runs in `O(n)` time complexity and `O(1)` space complexity?", "entry_point": "increasing_triplet_subsequence", "canonical_solutions": {"python": "def findTriplets(nums: List[int]) -> bool:\n    first = float('inf')\n    second = float('inf')\n\n    for num in nums:\n        if num <= first:\n            first = num\n        elif num <= second:\n            second = num\n        else:\n            return True\n    return False", "java": "public boolean findTriplets(int[] nums) {\n    int first = Integer.MAX_VALUE;\n    int second = Integer.MAX_VALUE;\n\n    for (int num : nums) {\n        if (num <= first) {\n            first = num;\n        } else if (num <= second) {\n            second = num;\n        } else {\n            return true;\n        }\n    }\n    return false;\n}", "cpp": "bool findTriplets(vector<int>& nums) {\n    int first = INT_MAX, second = INT_MAX;\n\n    for (int num : nums) {\n        if (num <= first) {\n            first = num;\n        } else if (num <= second) {\n            second = num;\n        } else {\n            return true;\n        }\n    }\n    return false;\n}", "javascript": "function findTriplets(nums) {\n    let first = Number.MAX_VALUE;\n    let second = Number.MAX_VALUE;\n\n    for (let num of nums) {\n        if (num <= first) {\n            first = num;\n        } else if (num <= second) {\n            second = num;\n        } else {\n            return true;\n        }\n    }\n    return false;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/335", "prompt": "You are given an array of integers `distance`.\n\nYou start at the point `(0, 0)` on an **X-Y plane,** and you move `distance[0]` meters to the north, then `distance[1]` meters to the west, `distance[2]` meters to the south, `distance[3]` meters to the east, and so on. In other words, after each move, your direction changes counter-clockwise.\n\nReturn `true` _if your path crosses itself or_ `false` _if it does not_.\n\n**Example 1:**\n\n**Input:** distance = \\[2,1,1,2\\]\n**Output:** true\n**Explanation:** The path crosses itself at the point (0, 1).\n\n**Example 2:**\n\n**Input:** distance = \\[1,2,3,4\\]\n**Output:** false\n**Explanation:** The path does not cross itself at any point.\n\n**Example 3:**\n\n**Input:** distance = \\[1,1,1,2,1\\]\n**Output:** true\n**Explanation:** The path crosses itself at the point (0, 0).\n\n**Constraints:**\n\n*   `1 <= distance.length <= 105`\n*   `1 <= distance[i] <= 105`", "entry_point": "self_crossing", "canonical_solutions": {"python": "def is_path_crossing(distance):\n    visited = set([(0, 0)])\n    x, y = 0, 0\n    directions = [(0, 1), (-1, 0), (0, -1), (1, 0)]\n    \n    for i, d in enumerate(distance):\n        dx, dy = directions[i % 4]\n        for _ in range(d):\n            x += dx\n            y += dy\n            if (x, y) in visited:\n                return True\n            visited.add((x, y))\n    return False", "java": "public boolean isPathCrossing(int[] distance) {\n    Set<Pair<Integer, Integer>> visited = new HashSet<>();\n    int x = 0, y = 0;\n    visited.add(new Pair<>(x, y));\n    int[] dx = {0, -1, 0, 1};\n    int[] dy = {1, 0, -1, 0};\n    \n    for (int i = 0; i < distance.length; i++) {\n        int direction = i % 4;\n        for (int j = 0; j < distance[i]; j++) {\n            x += dx[direction];\n            y += dy[direction];\n            Pair<Integer, Integer> point = new Pair<>(x, y);\n            if (!visited.add(point)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "cpp": "bool isPathCrossing(const std::vector<int>& distance) {\n    std::unordered_set<std::pair<int, int>, pair_hash> visited;\n    int x = 0, y = 0;\n    visited.insert({x, y});\n    int dx[] = {0, -1, 0, 1};\n    int dy[] = {1, 0, -1, 0};\n    \n    for (int i = 0; i < distance.size(); ++i) {\n        int direction = i % 4;\n        for (int j = 0; j < distance[i]; ++j) {\n            x += dx[direction];\n            y += dy[direction];\n            if (!visited.insert({x, y}).second) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "javascript": "function isPathCrossing(distance) {\n    let visited = new Set([\"0,0\"]);\n    let x = 0, y = 0;\n    const dx = [0, -1, 0, 1];\n    const dy = [1, 0, -1, 0];\n    \n    for (let i = 0; i < distance.length; i++) {\n        let direction = i % 4;\n        for (let j = 0; j < distance[i]; j++) {\n            x += dx[direction];\n            y += dy[direction];\n            let point = `${x},${y}`; \n            if (visited.has(point)) {\n                return true;\n            }\n            visited.add(point);\n        }\n    }\n    return false;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/336", "prompt": "You are given a **0-indexed** array of **unique** strings `words`.\n\nA **palindrome pair** is a pair of integers `(i, j)` such that:\n\n*   `0 <= i, j < words.length`,\n*   `i != j`, and\n*   `words[i] + words[j]` (the concatenation of the two strings) is a palindrome.\n\nReturn _an array of all the **palindrome pairs** of_ `words`.\n\n**Example 1:**\n\n**Input:** words = \\[ \"abcd \", \"dcba \", \"lls \", \"s \", \"sssll \"\\]\n**Output:** \\[\\[0,1\\],\\[1,0\\],\\[3,2\\],\\[2,4\\]\\]\n**Explanation:** The palindromes are \\[ \"abcddcba \", \"dcbaabcd \", \"slls \", \"llssssll \"\\]\n\n**Example 2:**\n\n**Input:** words = \\[ \"bat \", \"tab \", \"cat \"\\]\n**Output:** \\[\\[0,1\\],\\[1,0\\]\\]\n**Explanation:** The palindromes are \\[ \"battab \", \"tabbat \"\\]\n\n**Example 3:**\n\n**Input:** words = \\[ \"a \", \" \"\\]\n**Output:** \\[\\[0,1\\],\\[1,0\\]\\]\n**Explanation:** The palindromes are \\[ \"a \", \"a \"\\]\n\n**Constraints:**\n\n*   `1 <= words.length <= 5000`\n*   `0 <= words[i].length <= 300`\n*   `words[i]` consists of lowercase English letters.", "entry_point": "palindrome_pairs", "canonical_solutions": {"python": "def palindrome_pairs(words):\n    def is_palindrome(s):\n        return s == s[::-1]\n\n    result = []\n    for i in range(len(words)):\n        for j in range(len(words)):\n            if i == j:\n                continue\n            concat = words[i] + words[j]\n            if is_palindrome(concat):\n                result.append([i, j])\n    return result", "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> palindromePairs(String[] words) {\n    List<List<Integer>> result = new ArrayList<>();\n\n    for (int i = 0; i < words.length; i++) {\n        for (int j = 0; j < words.length; j++) {\n            if (i == j) continue;\n            String concat = words[i] + words[j];\n\n            boolean isPalindrome = true;\n            for (int left = 0, right = concat.length() - 1; left < right; left++, right--) {\n                if (concat.charAt(left) != concat.charAt(right)) {\n                    isPalindrome = false;\n                    break;\n                }\n            }\n\n            if (isPalindrome) {\n                List<Integer> pair = new ArrayList<>();\n                pair.add(i);\n                pair.add(j);\n                result.add(pair);\n            }\n        }\n    }\n\n    return result;\n}", "cpp": "#include <vector>\n#include <string>\n\nstd::vector<std::pair<int, int>> palindromePairs(const std::vector<std::string> &words) {\n    std::vector<std::pair<int, int>> result;\n\n    for (size_t i = 0; i < words.size(); i++) {\n        for (size_t j = 0; j < words.size(); j++) {\n            if (i == j) continue;\n            std::string concat = words[i] + words[j];\n\n            bool is_palindrome = true;\n            for (size_t left = 0, right = concat.size() - 1; left < right; left++, right--) {\n                if (concat[left] != concat[right]) {\n                    is_palindrome = false;\n                    break;\n                }\n            }\n\n            if (is_palindrome) {\n                result.push_back(std::make_pair(i, j));\n            }\n        }\n    }\n\n    return result;\n}", "javascript": "function palindromePairs(words) {\n    function isPalindrome(s) {\n        return s === s.split('').reverse().join('');\n    }\n\n    const result = [];\n    for (let i = 0; i < words.length; i++) {\n        for (let j = 0; j < words.length; j++) {\n            if (i === j) continue;\n            const concat = words[i] + words[j];\n            if (isPalindrome(concat)) {\n                result.push([i, j]);\n            }\n        }\n    }\n\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/337", "prompt": "The thief has found himself a new place for his thievery again. There is only one entrance to this area, called `root`.\n\nBesides the `root`, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if **two directly-linked houses were broken into on the same night**.\n\nGiven the `root` of the binary tree, return _the maximum amount of money the thief can rob **without alerting the police**_.\n\n**Example 1:**\n\n**Input:** root = \\[3,2,3,null,3,null,1\\]\n**Output:** 7\n**Explanation:** Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.\n\n**Example 2:**\n\n**Input:** root = \\[3,4,5,1,3,null,1\\]\n**Output:** 9\n**Explanation:** Maximum amount of money the thief can rob = 4 + 5 = 9.\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `0 <= Node.val <= 104`", "entry_point": "house_robber_iii", "canonical_solutions": {"python": "def rob(self, root: TreeNode) -> int:\n    def rob_helper(node):\n        if not node:\n            return 0, 0\n\n        left_with_node, left_without_node = rob_helper(node.left)\n        right_with_node, right_without_node = rob_helper(node.right)\n\n        with_node = node.val + left_without_node + right_without_node\n        without_node = max(left_with_node, left_without_node) + max(right_with_node, right_without_node)\n        return with_node, without_node\n\n    return max(rob_helper(root))", "java": "public int rob(TreeNode root) {\n    int[] result = robHelper(root);\n    return Math.max(result[0], result[1]);\n}\n\nprivate int[] robHelper(TreeNode node) {\n    if (node == null) return new int[2];\n\n    int[] left = robHelper(node.left);\n    int[] right = robHelper(node.right);\n    int[] result = new int[2];\n\n    result[0] = node.val + left[1] + right[1];\n    result[1] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);\n    return result;\n}", "cpp": "int robHelper(TreeNode* node, int& includeNode, int& excludeNode) {\n    if (!node) return 0;\n\n    int left_include, left_exclude, right_include, right_exclude;\n\n    robHelper(node->left, left_include, left_exclude);\n    robHelper(node->right, right_include, right_exclude);\n\n    includeNode = node->val + left_exclude + right_exclude;\n    excludeNode = max(left_include, left_exclude) + max(right_include, right_exclude);\n    return max(includeNode, excludeNode);\n}\n\nint rob(TreeNode* root) {\n    int includeNode = 0, excludeNode = 0;\n    return robHelper(root, includeNode, excludeNode);\n}", "javascript": "var rob = function(root) {\n    const [withNode, withoutNode] = robHelper(root);\n    return Math.max(withNode, withoutNode);\n};\n\nfunction robHelper(node) {\n    if (!node) return [0, 0];\n\n    const [leftWithNode, leftWithoutNode] = robHelper(node.left);\n    const [rightWithNode, rightWithoutNode] = robHelper(node.right);\n\n    const withNode = node.val + leftWithoutNode + rightWithoutNode;\n    const withoutNode = Math.max(leftWithNode, leftWithoutNode) + Math.max(rightWithNode, rightWithoutNode);\n    return [withNode, withoutNode];\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/338", "prompt": "Given an integer `n`, return _an array_ `ans` _of length_ `n + 1` _such that for each_ `i` (`0 <= i <= n`)_,_ `ans[i]` _is the **number of**_ `1`_**'s** in the binary representation of_ `i`.\n\n**Example 1:**\n\n**Input:** n = 2\n**Output:** \\[0,1,1\\]\n**Explanation:**\n0 --> 0\n1 --> 1\n2 --> 10\n\n**Example 2:**\n\n**Input:** n = 5\n**Output:** \\[0,1,1,2,1,2\\]\n**Explanation:**\n0 --> 0\n1 --> 1\n2 --> 10\n3 --> 11\n4 --> 100\n5 --> 101\n\n**Constraints:**\n\n*   `0 <= n <= 105`\n\n**Follow up:**\n\n*   It is very easy to come up with a solution with a runtime of `O(n log n)`. Can you do it in linear time `O(n)` and possibly in a single pass?\n*   Can you do it without using any built-in function (i.e., like `__builtin_popcount` in C++)?", "entry_point": "counting_bits", "canonical_solutions": {"python": "def countBits(n):\n    ans = [0] * (n + 1)\n    for i in range(1, n + 1):\n        ans[i] = ans[i & (i - 1)] + 1\n    return ans", "java": "public int[] countBits(int n) {\n    int[] ans = new int[n + 1];\n    for (int i = 1; i <= n; ++i) {\n        ans[i] = ans[i & (i - 1)] + 1;\n    }\n    return ans;\n}", "cpp": "#include <vector>\nusing namespace std;\n\nvector<int> countBits(int n) {\n    vector<int> ans(n + 1, 0);\n    for (int i = 1; i <= n; ++i) {\n        ans[i] = ans[i & (i - 1)] + 1;\n    }\n    return ans;\n}", "javascript": "function countBits(n) {\n    const ans = new Array(n + 1).fill(0);\n    for (let i = 1; i <= n; ++i) {\n        ans[i] = ans[i & (i - 1)] + 1;\n    }\n    return ans;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/339", "prompt": "You are given a nested list of integers `nestedList`. Each element is either an integer or a list whose elements may also be integers or other lists.\n\nThe **depth** of an integer is the number of lists that it is inside of. For example, the nested list `[1,[2,2],[[3],2],1]` has each integer's value set to its **depth**.\n\nReturn _the sum of each integer in_ `nestedList` _multiplied by its **depth**_.\n\n**Example 1:**\n\n**Input:** nestedList = \\[\\[1,1\\],2,\\[1,1\\]\\]\n**Output:** 10\n**Explanation:** Four 1's at depth 2, one 2 at depth 1. 1\\*2 + 1\\*2 + 2\\*1 + 1\\*2 + 1\\*2 = 10.\n\n**Example 2:**\n\n**Input:** nestedList = \\[1,\\[4,\\[6\\]\\]\\]\n**Output:** 27\n**Explanation:** One 1 at depth 1, one 4 at depth 2, and one 6 at depth 3. 1\\*1 + 4\\*2 + 6\\*3 = 27.\n\n**Example 3:**\n\n**Input:** nestedList = \\[0\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= nestedList.length <= 50`\n*   The values of the integers in the nested list is in the range `[-100, 100]`.\n*   The maximum **depth** of any integer is less than or equal to `50`.", "entry_point": "nested_list_weight_sum", "canonical_solutions": {"python": "from typing import List, Union\n\ndef depth_sum(nested_list: List[Union[int, List]]) -> int:\n    def depth_sum_helper(nested_list: List[Union[int, List]], depth: int) -> int:\n        return sum(element * depth if isinstance(element, int) else depth_sum_helper(element, depth + 1) for element in nested_list)\n\n    return depth_sum_helper(nested_list, 1)", "java": "import java.util.List;\n\npublic int depthSum(List<?> nestedList) {\n    return depthSumHelper(nestedList, 1);\n}\n\nprivate int depthSumHelper(List<?> nestedList, int depth) {\n    int sum = 0;\n    for (Object element : nestedList) {\n        if (element instanceof Integer) {\n            sum += (int) element * depth;\n        } else {\n            sum += depthSumHelper((List<?>) element, depth + 1);\n        }\n    }\n    return sum;\n}", "cpp": "#include <vector>\n#include <variant>\n\nusing NestedList = std::vector<std::variant<int, std::vector<std::variant<int, std::vector<int>>>>>;\n\nint depthSumHelper(NestedList nestedList, int depth) {\n    int sum = 0;\n    for (auto& element : nestedList) {\n        if (std::holds_alternative<int>(element)) {\n            sum += std::get<int>(element) * depth;\n        } else {\n            sum += depthSumHelper(std::get<std::vector<std::variant<int, std::vector<int>>>>(element), depth + 1);\n        }\n    }\n    return sum;\n}\n\nint depthSum(NestedList nestedList) {\n    return depthSumHelper(nestedList, 1);\n}", "javascript": "function depthSum(nestedList) {\n    return depthSumHelper(nestedList, 1);\n}\n\nfunction depthSumHelper(nestedList, depth) {\n    let sum = 0;\n    for (let element of nestedList) {\n        if (typeof element === \"number\") {\n            sum += element * depth;\n        } else {\n            sum += depthSumHelper(element, depth + 1);\n        }\n    }\n    return sum;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/340", "prompt": "Given a string `s` and an integer `k`, return _the length of the longest_ _substring_ _of_ `s` _that contains at most_ `k` _**distinct** characters_.\n\n**Example 1:**\n\n**Input:** s =  \"eceba \", k = 2\n**Output:** 3\n**Explanation:** The substring is  \"ece \" with length 3.\n\n**Example 2:**\n\n**Input:** s =  \"aa \", k = 1\n**Output:** 2\n**Explanation:** The substring is  \"aa \" with length 2.\n\n**Constraints:**\n\n*   `1 <= s.length <= 5 * 104`\n*   `0 <= k <= 50`", "entry_point": "longest_substring_with_at_most_k_distinct_characters", "canonical_solutions": {"python": "def length_of_longest_substring_k_distinct(s: str, k: int) -> int:\n    char_count = {}\n    left = 0\n    max_length = 0\n\n    for right, char in enumerate(s):\n        char_count[char] = char_count.get(char, 0) + 1\n\n        while len(char_count) > k:\n            char_count[s[left]] -= 1\n            if char_count[s[left]] == 0:\n                del char_count[s[left]]\n            left += 1\n\n        max_length = max(max_length, right - left + 1)\n\n    return max_length", "java": "import java.util.HashMap;\n\npublic int lengthOfLongestSubstringKDistinct(String s, int k) {\n    HashMap<Character, Integer> charCount = new HashMap<>();\n    int left = 0, maxLength = 0;\n\n    for (int right = 0; right < s.length(); ++right) {\n        charCount.put(s.charAt(right), charCount.getOrDefault(s.charAt(right), 0) + 1);\n\n        while (charCount.size() > k) {\n            charCount.put(s.charAt(left), charCount.get(s.charAt(left)) - 1);\n            if (charCount.get(s.charAt(left)) == 0) {\n                charCount.remove(s.charAt(left));\n            }\n            left++;\n        }\n\n        maxLength = Math.max(maxLength, right - left + 1);\n    }\n    return maxLength;\n}", "cpp": "#include <unordered_map>\n#include <algorithm>\n\nint lengthOfLongestSubstringKDistinct(std::string s, int k) {\n    std::unordered_map<char, int> charCount;\n    int left = 0, maxLength = 0;\n\n    for (int right = 0; right < s.size(); ++right) {\n        charCount[s[right]]++;\n\n        while (charCount.size() > k) {\n            charCount[s[left]]--;\n            if (charCount[s[left]] == 0) {\n                charCount.erase(s[left]);\n            }\n            left++;\n        }\n\n        maxLength = std::max(maxLength, right - left + 1);\n    }\n    return maxLength;\n}", "javascript": "function lengthOfLongestSubstringKDistinct(s, k) {\n    const charCount = new Map();\n    let left = 0;\n    let maxLength = 0;\n\n    for (let right = 0; right < s.length; ++right) {\n        charCount.set(s[right], (charCount.get(s[right]) || 0) + 1);\n\n        while (charCount.size > k) {\n            charCount.set(s[left], charCount.get(s[left]) - 1);\n            if (charCount.get(s[left]) === 0) {\n                charCount.delete(s[left]);\n            }\n            left++;\n        }\n\n        maxLength = Math.max(maxLength, right - left + 1);\n    }\n    return maxLength;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/341", "prompt": "You are given a nested list of integers `nestedList`. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it.\n\nImplement the `NestedIterator` class:\n\n*   `NestedIterator(List nestedList)` Initializes the iterator with the nested list `nestedList`.\n*   `int next()` Returns the next integer in the nested list.\n*   `boolean hasNext()` Returns `true` if there are still some integers in the nested list and `false` otherwise.\n\nYour code will be tested with the following pseudocode:\n\ninitialize iterator with nestedList\nres = \\[\\]\nwhile iterator.hasNext()\n    append iterator.next() to the end of res\nreturn res\n\nIf `res` matches the expected flattened list, then your code will be judged as correct.\n\n**Example 1:**\n\n**Input:** nestedList = \\[\\[1,1\\],2,\\[1,1\\]\\]\n**Output:** \\[1,1,2,1,1\\]\n**Explanation:** By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: \\[1,1,2,1,1\\].\n\n**Example 2:**\n\n**Input:** nestedList = \\[1,\\[4,\\[6\\]\\]\\]\n**Output:** \\[1,4,6\\]\n**Explanation:** By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: \\[1,4,6\\].\n\n**Constraints:**\n\n*   `1 <= nestedList.length <= 500`\n*   The values of the integers in the nested list is in the range `[-106, 106]`.", "entry_point": "flatten_nested_list_iterator", "canonical_solutions": {"python": "class NestedIterator:\n    def __init__(self, nestedList):\n        def flatten(nestedList, flatList):\n            for item in nestedList:\n                if isinstance(item, int):\n                    flatList.append(item)\n                else:\n                    flatten(item, flatList)\n        self.flatList = []\n        flatten(nestedList, self.flatList)\n        self.index = 0\n\n    def next(self):\n        result = self.flatList[self.index]\n        self.index += 1\n        return result\n\n    def hasNext(self):\n        return self.index < len(self.flatList)", "java": "import java.util.*;\n\npublic class NestedIterator implements Iterator<Integer> {\n    List<Integer> flatList;\n    int index;\n\n    public NestedIterator(List<NestedInteger> nestedList) {\n        flatList = new ArrayList<Integer>();\n        flatten(nestedList);\n        index = 0;\n    }\n\n    private void flatten(List<NestedInteger> nestedList) {\n        for (NestedInteger ni : nestedList) {\n            if (ni.isInteger()) {\n                flatList.add(ni.getInteger());\n            } else {\n                flatten(ni.getList());\n            }\n        }\n    }\n\n    @Override\n    public Integer next() {\n        return flatList.get(index++);\n    }\n\n    @Override\n    public boolean hasNext() {\n        return index < flatList.size();\n    }\n}", "cpp": "class NestedIterator {\npublic:\n    vector<int> flatList;\n    int index;\n    \n    void flatten(vector<NestedInteger> &nestedList) {\n        for (NestedInteger &ni : nestedList) {\n            if (ni.isInteger()) {\n                flatList.push_back(ni.getInteger());\n            } else {\n                flatten(ni.getList());\n            }\n        }\n    }\n    \n    NestedIterator(vector<NestedInteger> &nestedList) {\n        flatten(nestedList);\n        index = 0;\n    }\n    \n    int next() {\n        return flatList[index++];\n    }\n    \n    bool hasNext() {\n        return index < flatList.size();\n    }\n};", "javascript": "class NestedIterator {\n    constructor(nestedList) {\n        this.flatList = [];\n        this.flatten(nestedList, this.flatList);\n        this.index = 0;\n    }\n    \n    flatten(nestedList, flatList) {\n        for (let item of nestedList) {\n            if (Number.isInteger(item)) {\n                flatList.push(item);\n            } else {\n                this.flatten(item, flatList);\n            }\n        }\n    }\n    \n    next() {\n        return this.flatList[this.index++];\n    }\n    \n    hasNext() {\n        return this.index < this.flatList.length;\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/342", "prompt": "Given an integer `n`, return _`true` if it is a power of four. Otherwise, return `false`_.\n\nAn integer `n` is a power of four, if there exists an integer `x` such that `n == 4x`.\n\n**Example 1:**\n\n**Input:** n = 16\n**Output:** true\n\n**Example 2:**\n\n**Input:** n = 5\n**Output:** false\n\n**Example 3:**\n\n**Input:** n = 1\n**Output:** true\n\n**Constraints:**\n\n*   `-231 <= n <= 231 - 1`\n\n**Follow up:** Could you solve it without loops/recursion?", "entry_point": "power_of_four", "canonical_solutions": {"python": "def isPowerOfFour(n: int) -> bool:\n    if n <= 0:\n        return False\n    while n % 4 == 0:\n        n //= 4\n    return n == 1", "java": "public boolean isPowerOfFour(int n) {\n    if (n <= 0) return false;\n    while (n % 4 == 0) {\n        n /= 4;\n    }\n    return n == 1;\n}", "cpp": "bool isPowerOfFour(int n) {\n    if (n <= 0) return false;\n    while (n % 4 == 0) {\n        n /= 4;\n    }\n    return n == 1;\n}", "javascript": "function isPowerOfFour(n) {\n    if (n <= 0) return false;\n    while (n % 4 === 0) {\n        n = Math.floor(n / 4);\n    }\n    return n === 1;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/343", "prompt": "Given an integer `n`, break it into the sum of `k` **positive integers**, where `k >= 2`, and maximize the product of those integers.\n\nReturn _the maximum product you can get_.\n\n**Example 1:**\n\n**Input:** n = 2\n**Output:** 1\n**Explanation:** 2 = 1 + 1, 1 \\* 1 = 1.\n\n**Example 2:**\n\n**Input:** n = 10\n**Output:** 36\n**Explanation:** 10 = 3 + 3 + 4, 3 \\* 3 \\* 4 = 36.\n\n**Constraints:**\n\n*   `2 <= n <= 58`", "entry_point": "integer_break", "canonical_solutions": {"python": "def integer_break(n):\n    if n <= 3:\n        return n - 1\n    product = 1\n    while n > 4:\n        product *= 3\n        n -= 3\n    return product * n", "java": "public int integerBreak(int n) {\n    if (n <= 3) return n - 1;\n    int product = 1;\n    while (n > 4) {\n        product *= 3;\n        n -= 3;\n    }\n    return product * n;\n}", "cpp": "int integerBreak(int n) {\n    if (n <= 3) return n - 1;\n    int product = 1;\n    while (n > 4) {\n        product *= 3;\n        n -= 3;\n    }\n    return product * n;\n}", "javascript": "function integerBreak(n) {\n    if (n <= 3) return n - 1;\n    let product = 1;\n    while (n > 4) {\n        product *= 3;\n        n -= 3;\n    }\n    return product * n;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/344", "prompt": "Write a function that reverses a string. The input string is given as an array of characters `s`.\n\nYou must do this by modifying the input array [in-place](https://en.wikipedia.org/wiki/In-place_algorithm) with `O(1)` extra memory.\n\n**Example 1:**\n\n**Input:** s = \\[\"h\",\"e\",\"l\",\"l\",\"o\"\\]\n**Output:** \\[\"o\",\"l\",\"l\",\"e\",\"h\"\\]\n\n**Example 2:**\n\n**Input:** s = \\[\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"\\]\n**Output:** \\[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"\\]\n\n**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s[i]` is a [printable ascii character](https://en.wikipedia.org/wiki/ASCII#Printable_characters).", "entry_point": "reverse_string", "canonical_solutions": {"python": "def reverseString(s: List[str]) -> None:\n    left, right = 0, len(s) - 1\n    while left < right:\n        s[left], s[right] = s[right], s[left]\n        left, right = left + 1, right - 1", "java": "public void reverseString(char[] s) {\n    int left = 0, right = s.length - 1;\n    while (left < right) {\n        char temp = s[left];\n        s[left++] = s[right];\n        s[right--] = temp;\n    }\n}", "cpp": "void reverseString(vector<char>& s) {\n    int left = 0, right = s.size() - 1;\n    while (left < right) {\n        swap(s[left++], s[right--]);\n    }\n}", "javascript": "function reverseString(s) {\n    let left = 0, right = s.length - 1;\n    while (left < right) {\n        [s[left], s[right]] = [s[right], s[left]];\n        left++;\n        right--;\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/345", "prompt": "Given a string `s`, reverse only all the vowels in the string and return it.\n\nThe vowels are `'a'`, `'e'`, `'i'`, `'o'`, and `'u'`, and they can appear in both lower and upper cases, more than once.\n\n**Example 1:**\n\n**Input:** s = \"hello\"\n**Output:** \"holle\"\n\n**Example 2:**\n\n**Input:** s = \"leetcode\"\n**Output:** \"leotcede\"\n\n**Constraints:**\n\n*   `1 <= s.length <= 3 * 105`\n*   `s` consist of **printable ASCII** characters.", "entry_point": "reverse_vowels_of_a_string", "canonical_solutions": {"python": "def reverseVowels(s: str) -> str:\n    vowels = set('aeiouAEIOU')\n    s_list = list(s)\n    i, j = 0, len(s) - 1\n    while i < j:\n        if s_list[i] not in vowels:\n            i += 1\n        elif s_list[j] not in vowels:\n            j -= 1\n        else:\n            s_list[i], s_list[j] = s_list[j], s_list[i]\n            i += 1\n            j -= 1\n    return ''.join(s_list)", "java": "import java.util.HashSet;\nimport java.util.Set;\n\npublic String reverseVowels(String s) {\n    int i = 0, j = s.length() - 1;\n    char[] result = new char[s.length()];\n    Set<Character> vowels = new HashSet<>();\n    for (char c : \"aeiouAEIOU\".toCharArray()) {\n        vowels.add(c);\n    }\n    while (i <= j) {\n        char ci = s.charAt(i);\n        char cj = s.charAt(j);\n        if (!vowels.contains(ci)) {\n            result[i++] = ci;\n        } else if (!vowels.contains(cj)) {\n            result[j--] = cj;\n        } else {\n            result[i++] = cj;\n            result[j--] = ci;\n        }\n    }\n    return new String(result);\n}", "cpp": "#include <algorithm>\n#include <string>\n\nstd::string reverseVowels(std::string s) {\n    int i = 0, j = s.size() - 1;\n    while (i < j) {\n        if (!isVowel(s[i])) {\n            i++;\n        } else if (!isVowel(s[j])) {\n            j--;\n        } else {\n            std::swap(s[i], s[j]);\n            i++;\n            j--;\n        }\n    }\n    return s;\n}\n\nbool isVowel(char c) {\n    c = std::tolower(c);\n    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\n}", "javascript": "function reverseVowels(s) {\n    const vowels = new Set('aeiouAEIOU');\n    let chars = Array.from(s);\n    let i = 0, j = s.length - 1;\n    while (i < j) {\n        if (!vowels.has(chars[i])) {\n            i++;\n        } else if (!vowels.has(chars[j])) {\n            j--;\n        } else {\n            [chars[i], chars[j]] = [chars[j], chars[i]];\n            i++;\n            j--;\n        }\n    }\n    return chars.join('');\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/346", "prompt": "Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.\n\nImplement the `MovingAverage` class:\n\n*   `MovingAverage(int size)` Initializes the object with the size of the window `size`.\n*   `double next(int val)` Returns the moving average of the last `size` values of the stream.\n\n**Example 1:**\n\n**Input**\n\\[ \"MovingAverage \",  \"next \",  \"next \",  \"next \",  \"next \"\\]\n\\[\\[3\\], \\[1\\], \\[10\\], \\[3\\], \\[5\\]\\]\n**Output**\n\\[null, 1.0, 5.5, 4.66667, 6.0\\]\n\n**Explanation**\nMovingAverage movingAverage = new MovingAverage(3);\nmovingAverage.next(1); // return 1.0 = 1 / 1\nmovingAverage.next(10); // return 5.5 = (1 + 10) / 2\nmovingAverage.next(3); // return 4.66667 = (1 + 10 + 3) / 3\nmovingAverage.next(5); // return 6.0 = (10 + 3 + 5) / 3\n\n**Constraints:**\n\n*   `1 <= size <= 1000`\n*   `-105 <= val <= 105`\n*   At most `104` calls will be made to `next`.", "entry_point": "moving_average_from_data_stream", "canonical_solutions": {"python": "from collections import deque\n\nclass MovingAverage:\n    def __init__(self, size: int):\n        self.queue = deque()\n        self.maxSize = size\n        self.sum = 0.0\n\n    def next(self, val: int) -> float:\n        if len(self.queue) == self.maxSize:\n            self.sum -= self.queue.popleft()\n        self.queue.append(val)\n        self.sum += val\n        return self.sum / len(self.queue)", "java": "import java.util.LinkedList;\nimport java.util.Queue;\n\nclass MovingAverage {\n    private Queue<Integer> queue;\n    private int maxSize;\n    private double sum;\n\n    public MovingAverage(int size) {\n        queue = new LinkedList<>();\n        maxSize = size;\n        sum = 0.0;\n    }\n\n    public double next(int val) {\n        if (queue.size() == maxSize) {\n            sum -= queue.remove();\n        }\n        queue.add(val);\n        sum += val;\n        return sum / queue.size();\n    }\n}", "cpp": "#include <queue>\nusing namespace std;\n\nclass MovingAverage {\npublic:\n    queue<int> q;\n    int maxSize;\n    double sum;\n\n    MovingAverage(int size) {\n        maxSize = size;\n        sum = 0;\n    }\n\n    double next(int val) {\n        if (q.size() == maxSize) {\n            sum -= q.front();\n            q.pop();\n        }\n        q.push(val);\n        sum += val;\n        return sum / q.size();\n    }\n};", "javascript": "class MovingAverage {\n    constructor(size) {\n        this.queue = [];\n        this.maxSize = size;\n        this.sum = 0;\n    }\n\n    next(val) {\n        if (this.queue.length === this.maxSize) {\n            this.sum -= this.queue.shift();\n        }\n        this.queue.push(val);\n        this.sum += val;\n        return this.sum / this.queue.length;\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/347", "prompt": "Given an integer array `nums` and an integer `k`, return _the_ `k` _most frequent elements_. You may return the answer in **any order**.\n\n**Example 1:**\n\n**Input:** nums = \\[1,1,1,2,2,3\\], k = 2\n**Output:** \\[1,2\\]\n\n**Example 2:**\n\n**Input:** nums = \\[1\\], k = 1\n**Output:** \\[1\\]\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-104 <= nums[i] <= 104`\n*   `k` is in the range `[1, the number of unique elements in the array]`.\n*   It is **guaranteed** that the answer is **unique**.\n\n**Follow up:** Your algorithm's time complexity must be better than `O(n log n)`, where n is the array's size.", "entry_point": "top_k_frequent_elements", "canonical_solutions": {"python": "from heapq import heappush, heappop\nfrom collections import Counter\n\ndef k_most_frequent(nums, k):\n    frequency = Counter(nums)\n    min_heap = []\n\n    for num, freq in frequency.items():\n        heappush(min_heap, (freq, num))\n        if len(min_heap) > k:\n            heappop(min_heap)\n\n    return [heappop(min_heap)[1] for _ in range(k)]", "java": "import java.util.*;\n\npublic List<Integer> kMostFrequent(int[] nums, int k) {\n    Map<Integer, Integer> frequency = new HashMap<>();\n    for (int num : nums) {\n        frequency.put(num, frequency.getOrDefault(num, 0) + 1);\n    }\n\n    PriorityQueue<Map.Entry<Integer, Integer>> min_heap = new PriorityQueue<>(Comparator.comparingInt(Map.Entry::getValue));\n    for (Map.Entry<Integer, Integer> entry : frequency.entrySet()) {\n        min_heap.offer(entry);\n        if (min_heap.size() > k) {\n            min_heap.poll();\n        }\n    }\n\n    List<Integer> result = new ArrayList<>();\n    while (!min_heap.isEmpty()) {\n        result.add(min_heap.poll().getKey());\n    }\n    return result;\n}", "cpp": "#include <vector>\n#include <unordered_map>\n#include <queue>\nusing namespace std;\n\nvector<int> kMostFrequent(vector<int>& nums, int k) {\n    unordered_map<int, int> frequency;\n    for (int num : nums) {\n        frequency[num]++;\n    }\n\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> min_heap;\n    for (const auto& entry : frequency) {\n        min_heap.push({entry.second, entry.first});\n        if (min_heap.size() > k) {\n            min_heap.pop();\n        }\n    }\n\n    vector<int> result;\n    while (!min_heap.empty()) {\n        result.push_back(min_heap.top().second);\n        min_heap.pop();\n    }\n\n    return result;\n}", "javascript": "function kMostFrequent(nums, k) {\n  const frequency = new Map();\n  for (const num of nums) {\n    frequency.set(num, (frequency.get(num) || 0) + 1);\n  }\n\n  const minHeap = [];\n\n  for (const [num, freq] of frequency) {\n    minHeap.push([freq, num]);\n    if (minHeap.length > k) {\n      minHeap.sort((a, b) => a[0] - b[0]).shift();\n    }\n  }\n\n  return minHeap.map(entry => entry[1]);\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/348", "prompt": "Assume the following rules are for the tic-tac-toe game on an `n x n` board between two players:\n\n1.  A move is guaranteed to be valid and is placed on an empty block.\n2.  Once a winning condition is reached, no more moves are allowed.\n3.  A player who succeeds in placing `n` of their marks in a horizontal, vertical, or diagonal row wins the game.\n\nImplement the `TicTacToe` class:\n\n*   `TicTacToe(int n)` Initializes the object the size of the board `n`.\n*   `int move(int row, int col, int player)` Indicates that the player with id `player` plays at the cell `(row, col)` of the board. The move is guaranteed to be a valid move, and the two players alternate in making moves. Return\n    *   `0` if there is **no winner** after the move,\n    *   `1` if **player 1** is the winner after the move, or\n    *   `2` if **player 2** is the winner after the move.\n\n**Example 1:**\n\n**Input**\n\\[ \"TicTacToe \",  \"move \",  \"move \",  \"move \",  \"move \",  \"move \",  \"move \",  \"move \"\\]\n\\[\\[3\\], \\[0, 0, 1\\], \\[0, 2, 2\\], \\[2, 2, 1\\], \\[1, 1, 2\\], \\[2, 0, 1\\], \\[1, 0, 2\\], \\[2, 1, 1\\]\\]\n**Output**\n\\[null, 0, 0, 0, 0, 0, 0, 1\\]\n\n**Explanation**\nTicTacToe ticTacToe = new TicTacToe(3);\nAssume that player 1 is  \"X \" and player 2 is  \"O \" in the board.\nticTacToe.move(0, 0, 1); // return 0 (no one wins)\n|X| | |\n| | | |    // Player 1 makes a move at (0, 0).\n| | | |\n\nticTacToe.move(0, 2, 2); // return 0 (no one wins)\n|X| |O|\n| | | |    // Player 2 makes a move at (0, 2).\n| | | |\n\nticTacToe.move(2, 2, 1); // return 0 (no one wins)\n|X| |O|\n| | | |    // Player 1 makes a move at (2, 2).\n| | |X|\n\nticTacToe.move(1, 1, 2); // return 0 (no one wins)\n|X| |O|\n| |O| |    // Player 2 makes a move at (1, 1).\n| | |X|\n\nticTacToe.move(2, 0, 1); // return 0 (no one wins)\n|X| |O|\n| |O| |    // Player 1 makes a move at (2, 0).\n|X| |X|\n\nticTacToe.move(1, 0, 2); // return 0 (no one wins)\n|X| |O|\n|O|O| |    // Player 2 makes a move at (1, 0).\n|X| |X|\n\nticTacToe.move(2, 1, 1); // return 1 (player 1 wins)\n|X| |O|\n|O|O| |    // Player 1 makes a move at (2, 1).\n|X|X|X|\n\n**Constraints:**\n\n*   `2 <= n <= 100`\n*   player is `1` or `2`.\n*   `0 <= row, col < n`\n*   `(row, col)` are **unique** for each different call to `move`.\n*   At most `n2` calls will be made to `move`.\n\n**Follow-up:** Could you do better than `O(n2)` per `move()` operation?", "entry_point": "design_tic_tac_toe", "canonical_solutions": {"python": "class TicTacToe:\n    def __init__(self, n: int):\n        self.rows, self.cols = [0] * n, [0] * n\n        self.diagonal = self.anti_diagonal = self.n = n\n\n    def move(self, row: int, col: int, player: int) -> int:\n        to_add = 1 if player == 1 else -1\n\n        self.rows[row] += to_add\n        self.cols[col] += to_add\n\n        if row == col:\n            self.diagonal += to_add\n        if row + col == self.n - 1:\n            self.anti_diagonal += to_add\n\n        if (abs(self.rows[row]) == self.n or abs(self.cols[col]) == self.n\n                or abs(self.diagonal) == self.n or abs(self.anti_diagonal) == self.n):\n            return player\n\n        return 0", "java": "class TicTacToe {\n    int[] rows, cols;\n    int diagonal, anti_diagonal, n;\n\n    public TicTacToe(int n) {\n        this.n = n;\n        rows = new int[n];\n        cols = new int[n];\n        diagonal = 0;\n        anti_diagonal = 0;\n    }\n\n    public int move(int row, int col, int player) {\n        int toAdd = (player == 1) ? 1 : -1;\n\n        rows[row] += toAdd;\n        cols[col] += toAdd;\n\n        if (row == col) diagonal += toAdd;\n        if (row + col == n - 1) anti_diagonal += toAdd;\n\n        if (Math.abs(rows[row]) == n || \n            Math.abs(cols[col]) == n || \n            Math.abs(diagonal) == n || \n            Math.abs(anti_diagonal) == n)\n            return player;\n\n        return 0;\n    }\n}", "cpp": "class TicTacToe {\npublic:\n    vector<int> rows, cols;\n    int diagonal, anti_diagonal, n;\n    \n    TicTacToe(int n) {\n        this->n = n;\n        rows = vector<int>(n, 0);\n        cols = vector<int>(n, 0);\n        diagonal = 0;\n        anti_diagonal = 0;\n    }\n\n    int move(int row, int col, int player) {\n        int toAdd = (player == 1) ? 1 : -1;\n        \n        rows[row] += toAdd;\n        cols[col] += toAdd;\n        \n        if (row == col) diagonal += toAdd;\n        if (row + col == n - 1) anti_diagonal += toAdd;\n\n        if (abs(rows[row]) == n || \n            abs(cols[col]) == n || \n            abs(diagonal) == n || \n            abs(anti_diagonal) == n)\n            return player;\n\n        return 0;\n    }\n};", "javascript": "class TicTacToe {\n    constructor(n) {\n        this.rows = new Array(n).fill(0);\n        this.cols = new Array(n).fill(0);\n        this.diagonal = 0;\n        this.anti_diagonal = 0;\n        this.n = n;\n    }\n\n    move(row, col, player) {\n        const toAdd = player === 1 ? 1 : -1;\n\n        this.rows[row] += toAdd;\n        this.cols[col] += toAdd;\n\n        if (row === col) this.diagonal += toAdd;\n        if (row + col === this.n - 1) this.anti_diagonal += toAdd;\n\n        if (Math.abs(this.rows[row]) === this.n || \n            Math.abs(this.cols[col]) === this.n || \n            Math.abs(this.diagonal) === this.n || \n            Math.abs(this.anti_diagonal) === this.n)\n            return player;\n\n        return 0;\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/349", "prompt": "Given two integer arrays `nums1` and `nums2`, return _an array of their intersection_. Each element in the result must be **unique** and you may return the result in **any order**.\n\n**Example 1:**\n\n**Input:** nums1 = \\[1,2,2,1\\], nums2 = \\[2,2\\]\n**Output:** \\[2\\]\n\n**Example 2:**\n\n**Input:** nums1 = \\[4,9,5\\], nums2 = \\[9,4,9,8,4\\]\n**Output:** \\[9,4\\]\n**Explanation:** \\[4,9\\] is also accepted.\n\n**Constraints:**\n\n*   `1 <= nums1.length, nums2.length <= 1000`\n*   `0 <= nums1[i], nums2[i] <= 1000`", "entry_point": "intersection_of_two_arrays", "canonical_solutions": {"python": "def intersection(nums1, nums2):\n    set1 = set(nums1)\n    result = set1.intersection(nums2)\n    return list(result)", "java": "import java.util.HashSet;\nimport java.util.Set;\n\npublic int[] intersection(int[] nums1, int[] nums2) {\n    Set<Integer> set1 = new HashSet<>();\n    for (int num : nums1) {\n        set1.add(num);\n    }\n    \n    Set<Integer> resultSet = new HashSet<>();\n    for (int num : nums2) {\n        if (set1.contains(num)) {\n            resultSet.add(num);\n        }\n    }\n    \n    int[] result = new int[resultSet.size()];\n    int i = 0;\n    for (int num : resultSet) {\n        result[i++] = num;\n    }\n    return result;\n}", "cpp": "#include <vector>\n#include <set>\n\nstd::vector<int> intersection(std::vector<int>& nums1, std::vector<int>& nums2) {\n    std::set<int> set1(nums1.begin(), nums1.end());\n    std::set<int> result;\n    for (int num : nums2) {\n        if (set1.count(num)) {\n            result.insert(num);\n        }\n    }\n    return std::vector<int>(result.begin(), result.end());\n}", "javascript": "function intersection(nums1, nums2) {\n    const set1 = new Set(nums1);\n    const resultSet = new Set();\n\n    for (const num of nums2) {\n        if (set1.has(num)) {\n            resultSet.add(num);\n        }\n    }\n\n    return Array.from(resultSet);\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/350", "prompt": "Given two integer arrays `nums1` and `nums2`, return _an array of their intersection_. Each element in the result must appear as many times as it shows in both arrays and you may return the result in **any order**.\n\n**Example 1:**\n\n**Input:** nums1 = \\[1,2,2,1\\], nums2 = \\[2,2\\]\n**Output:** \\[2,2\\]\n\n**Example 2:**\n\n**Input:** nums1 = \\[4,9,5\\], nums2 = \\[9,4,9,8,4\\]\n**Output:** \\[4,9\\]\n**Explanation:** \\[9,4\\] is also accepted.\n\n**Constraints:**\n\n*   `1 <= nums1.length, nums2.length <= 1000`\n*   `0 <= nums1[i], nums2[i] <= 1000`\n\n**Follow up:**\n\n*   What if the given array is already sorted? How would you optimize your algorithm?\n*   What if `nums1`'s size is small compared to `nums2`'s size? Which algorithm is better?\n*   What if elements of `nums2` are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?", "entry_point": "intersection_of_two_arrays_ii", "canonical_solutions": {"python": "def intersect(nums1, nums2):\n    count_map = {}\n    result = []\n    \n    for num in nums1:\n        count_map[num] = count_map.get(num, 0) + 1\n    \n    for num in nums2:\n        if count_map.get(num, 0) > 0:\n            result.append(num)\n            count_map[num] -= 1\n\n    return result", "java": "import java.util.ArrayList;\nimport java.util.HashMap;\n\npublic int[] intersect(int[] nums1, int[] nums2) {\n    HashMap<Integer, Integer> countMap = new HashMap<>();\n    ArrayList<Integer> result = new ArrayList<>();\n    \n    for (int num : nums1) {\n        countMap.put(num, countMap.getOrDefault(num, 0) + 1);\n    }\n    \n    for (int num : nums2) {\n        if (countMap.getOrDefault(num, 0) > 0) {\n            result.add(num);\n            countMap.put(num, countMap.get(num) - 1);\n        }\n    }\n\n    return result.stream().mapToInt(i -> i).toArray();\n}", "cpp": "#include <vector>\n#include <unordered_map>\n\nstd::vector<int> intersect(std::vector<int>& nums1, std::vector<int>& nums2) {\n    std::unordered_map<int, int> count_map;\n    std::vector<int> result;\n    \n    for (int num : nums1) {\n        count_map[num]++;\n    }\n    \n    for (int num : nums2) {\n        if (count_map[num] > 0) {\n            result.push_back(num);\n            count_map[num]--;\n        }\n    }\n\n    return result;\n}", "javascript": "function intersect(nums1, nums2) {\n    const countMap = {};\n    const result = [];\n    \n    for (const num of nums1) {\n        countMap[num] = (countMap[num] || 0) + 1;\n    }\n    \n    for (const num of nums2) {\n        if (countMap[num] > 0) {\n            result.push(num);\n            countMap[num]--;\n        }\n    }\n\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/351", "prompt": "Android devices have a special lock screen with a `3 x 3` grid of dots. Users can set an \"unlock pattern \" by connecting the dots in a specific sequence, forming a series of joined line segments where each segment's endpoints are two consecutive dots in the sequence. A sequence of `k` dots is a **valid** unlock pattern if both of the following are true:\n\n*   All the dots in the sequence are **distinct**.\n*   If the line segment connecting two consecutive dots in the sequence passes through the **center** of any other dot, the other dot **must have previously appeared** in the sequence. No jumps through the center non-selected dots are allowed.\n    *   For example, connecting dots `2` and `9` without dots `5` or `6` appearing beforehand is valid because the line from dot `2` to dot `9` does not pass through the center of either dot `5` or `6`.\n    *   However, connecting dots `1` and `3` without dot `2` appearing beforehand is invalid because the line from dot `1` to dot `3` passes through the center of dot `2`.\n\nHere are some example valid and invalid unlock patterns:\n\n*   The 1st pattern `[4,1,3,6]` is invalid because the line connecting dots `1` and `3` pass through dot `2`, but dot `2` did not previously appear in the sequence.\n*   The 2nd pattern `[4,1,9,2]` is invalid because the line connecting dots `1` and `9` pass through dot `5`, but dot `5` did not previously appear in the sequence.\n*   The 3rd pattern `[2,4,1,3,6]` is valid because it follows the conditions. The line connecting dots `1` and `3` meets the condition because dot `2` previously appeared in the sequence.\n*   The 4th pattern `[6,5,4,1,9,2]` is valid because it follows the conditions. The line connecting dots `1` and `9` meets the condition because dot `5` previously appeared in the sequence.\n\nGiven two integers `m` and `n`, return _the **number of unique and valid unlock patterns** of the Android grid lock screen that consist of **at least**_ `m` _keys and **at most**_ `n` _keys._\n\nTwo unlock patterns are considered **unique** if there is a dot in one sequence that is not in the other, or the order of the dots is different.\n\n**Example 1:**\n\n**Input:** m = 1, n = 1\n**Output:** 9\n\n**Example 2:**\n\n**Input:** m = 1, n = 2\n**Output:** 65\n\n**Constraints:**\n\n*   `1 <= m, n <= 9`", "entry_point": "android_unlock_patterns", "canonical_solutions": {"python": "def numberOfPatterns(m: int, n: int) -> int:\n    def dfs(curr, remaining):\n        if remaining < 0:\n            return 0\n        if remaining == 0:\n            return 1\n\n        visited[curr] = True\n        cnt = 0\n        for next in range(1, 10):\n            if not visited[next] and (jumps[curr][next] == 0 or visited[jumps[curr][next]]):\n                cnt += dfs(next, remaining - 1)\n        visited[curr] = False\n\n        return cnt\n\n    jumps = [[0] * 10 for _ in range(10)]\n    jumps[1][3] = jumps[3][1] = 2\n    jumps[1][7] = jumps[7][1] = 4\n    jumps[3][9] = jumps[9][3] = 6\n    jumps[7][9] = jumps[9][7] = 8\n    jumps[1][9] = jumps[9][1] = jumps[2][8] = jumps[8][2] = jumps[3][7] = jumps[7][3] = jumps[4][6] = jumps[6][4] = 5\n\n    visited = [False] * 10\n\n    cnt = 0\n    for i in range(m, n + 1):\n        cnt += dfs(1, i - 1) * 4  # 1, 3, 7, 9\n        cnt += dfs(2, i - 1) * 4  # 2, 4, 6, 8\n        cnt += dfs(5, i - 1)      # 5\n\n    return cnt", "java": "public int numberOfPatterns(int m, int n) {\n    int[][] jumps = new int[10][10];\n    jumps[1][3] = jumps[3][1] = 2;\n    jumps[1][7] = jumps[7][1] = 4;\n    jumps[3][9] = jumps[9][3] = 6;\n    jumps[7][9] = jumps[9][7] = 8;\n    jumps[1][9] = jumps[9][1] = jumps[2][8] = jumps[8][2] = jumps[3][7] = jumps[7][3] = jumps[4][6] = jumps[6][4] = 5;\n\n    boolean[] visited = new boolean[10];\n\n    int cnt = 0;\n    for (int i = m; i <= n; ++i) {\n        cnt += dfs(jumps, visited, 1, i - 1) * 4; // 1, 3, 7, 9\n        cnt += dfs(jumps, visited, 2, i - 1) * 4; // 2, 4, 6, 8\n        cnt += dfs(jumps, visited, 5, i - 1);     // 5\n    }\n\n    return cnt;\n}\n\nprivate int dfs(int[][] jumps, boolean[] visited, int curr, int remaining) {\n    if (remaining < 0) return 0;\n    if (remaining == 0) return 1;\n\n    visited[curr] = true;\n    int cnt = 0;\n    for (int next = 1; next <= 9; ++next) {\n        if (!visited[next] && (jumps[curr][next] == 0 || visited[jumps[curr][next]])) {\n            cnt += dfs(jumps, visited, next, remaining - 1);\n        }\n    }\n    visited[curr] = false;\n\n    return cnt;\n}", "cpp": "int numberOfPatterns(int m, int n) {\n    const vector<vector<int>> jumps(10, vector<int>(10, 0));\n    jumps[1][3] = jumps[3][1] = 2;\n    jumps[1][7] = jumps[7][1] = 4;\n    jumps[3][9] = jumps[9][3] = 6;\n    jumps[7][9] = jumps[9][7] = 8;\n    jumps[1][9] = jumps[9][1] = jumps[2][8] = jumps[8][2] = jumps[3][7] = jumps[7][3] = jumps[4][6] = jumps[6][4] = 5;\n\n    vector<bool> visited(10, false);\n\n    int cnt = 0;\n    for (int i = m; i <= n; ++i) {\n        cnt += dfs(jumps, visited, 1, i - 1) * 4; // 1, 3, 7, 9\n        cnt += dfs(jumps, visited, 2, i - 1) * 4; // 2, 4, 6, 8\n        cnt += dfs(jumps, visited, 5, i - 1);     // 5\n    }\n\n    return cnt;\n}\n\nint dfs(const vector<vector<int>>& jumps, vector<bool>& visited, int curr, int remaining) {\n    if (remaining < 0) return 0;\n    if (remaining == 0) return 1;\n\n    visited[curr] = true;\n    int cnt = 0;\n    for (int next = 1; next <= 9; ++next) {\n        if (!visited[next] && (jumps[curr][next] == 0 || visited[jumps[curr][next]])) {\n            cnt += dfs(jumps, visited, next, remaining - 1);\n        }\n    }\n    visited[curr] = false;\n\n    return cnt;\n}", "javascript": "var numberOfPatterns = function(m, n) {\n    const jumps = Array.from({length: 10}, () => Array(10).fill(0));\n    jumps[1][3] = jumps[3][1] = 2;\n    jumps[1][7] = jumps[7][1] = 4;\n    jumps[3][9] = jumps[9][3] = 6;\n    jumps[7][9] = jumps[9][7] = 8;\n    jumps[1][9] = jumps[9][1] = jumps[2][8] = jumps[8][2] = jumps[3][7] = jumps[7][3] = jumps[4][6] = jumps[6][4] = 5;\n\n    const visited = Array(10).fill(false);\n\n    let cnt = 0;\n    for (let i = m; i <= n; ++i) {\n        cnt += dfs(jumps, visited, 1, i - 1) * 4; // 1, 3, 7, 9\n        cnt += dfs(jumps, visited, 2, i - 1) * 4; // 2, 4, 6, 8\n        cnt += dfs(jumps, visited, 5, i - 1);     // 5\n    }\n\n    return cnt;\n};\n\nfunction dfs(jumps, visited, curr, remaining) {\n    if (remaining < 0) return 0;\n    if (remaining === 0) return 1;\n\n    visited[curr] = true;\n    let cnt = 0;\n    for (let next = 1; next <= 9; ++next) {\n        if (!visited[next] && (jumps[curr][next] === 0 || visited[jumps[curr][next]])) {\n            cnt += dfs(jumps, visited, next, remaining - 1);\n        }\n    }\n    visited[curr] = false;\n\n    return cnt;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/352", "prompt": "Given a data stream input of non-negative integers `a1, a2, ..., an`, summarize the numbers seen so far as a list of disjoint intervals.\n\nImplement the `SummaryRanges` class:\n\n*   `SummaryRanges()` Initializes the object with an empty stream.\n*   `void addNum(int value)` Adds the integer `value` to the stream.\n*   `int[][] getIntervals()` Returns a summary of the integers in the stream currently as a list of disjoint intervals `[starti, endi]`. The answer should be sorted by `starti`.\n\n**Example 1:**\n\n**Input**\n\\[ \"SummaryRanges \",  \"addNum \",  \"getIntervals \",  \"addNum \",  \"getIntervals \",  \"addNum \",  \"getIntervals \",  \"addNum \",  \"getIntervals \",  \"addNum \",  \"getIntervals \"\\]\n\\[\\[\\], \\[1\\], \\[\\], \\[3\\], \\[\\], \\[7\\], \\[\\], \\[2\\], \\[\\], \\[6\\], \\[\\]\\]\n**Output**\n\\[null, null, \\[\\[1, 1\\]\\], null, \\[\\[1, 1\\], \\[3, 3\\]\\], null, \\[\\[1, 1\\], \\[3, 3\\], \\[7, 7\\]\\], null, \\[\\[1, 3\\], \\[7, 7\\]\\], null, \\[\\[1, 3\\], \\[6, 7\\]\\]\\]\n\n**Explanation**\nSummaryRanges summaryRanges = new SummaryRanges();\nsummaryRanges.addNum(1);      // arr = \\[1\\]\nsummaryRanges.getIntervals(); // return \\[\\[1, 1\\]\\]\nsummaryRanges.addNum(3);      // arr = \\[1, 3\\]\nsummaryRanges.getIntervals(); // return \\[\\[1, 1\\], \\[3, 3\\]\\]\nsummaryRanges.addNum(7);      // arr = \\[1, 3, 7\\]\nsummaryRanges.getIntervals(); // return \\[\\[1, 1\\], \\[3, 3\\], \\[7, 7\\]\\]\nsummaryRanges.addNum(2);      // arr = \\[1, 2, 3, 7\\]\nsummaryRanges.getIntervals(); // return \\[\\[1, 3\\], \\[7, 7\\]\\]\nsummaryRanges.addNum(6);      // arr = \\[1, 2, 3, 6, 7\\]\nsummaryRanges.getIntervals(); // return \\[\\[1, 3\\], \\[6, 7\\]\\]\n\n**Constraints:**\n\n*   `0 <= value <= 104`\n*   At most `3 * 104` calls will be made to `addNum` and `getIntervals`.\n*   At most `102` calls will be made to `getIntervals`.\n\n**Follow up:** What if there are lots of merges and the number of disjoint intervals is small compared to the size of the data stream?", "entry_point": "data_stream_as_disjoint_intervals", "canonical_solutions": {"python": "from collections import OrderedDict\n\nclass SummaryRanges:\n\n    def __init__(self):\n        self.intervals = OrderedDict()\n\n    def addNum(self, val: int) -> None:\n        if not self.intervals or next(iter(self.intervals)) > val + 1:\n            self.intervals[val] = val\n        else:\n            keys = list(self.intervals.keys())\n            idx = bisect_left(keys, val)\n            if idx > 0 and keys[idx - 1] <= val <= self.intervals[keys[idx - 1]]:\n                pass\n            elif idx < len(keys) and val + 1 == keys[idx]:\n                self.intervals[val] = self.intervals[keys[idx]]\n                del self.intervals[keys[idx]]\n            else:\n                self.intervals[val] = val\n\n    def getIntervals(self):\n        return list(self.intervals.items())", "java": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.TreeMap;\n\npublic class SummaryRanges {\n\n    private TreeMap<Integer, Integer> intervals = new TreeMap<>();\n\n    public void addNum(int val) {\n        if (intervals.isEmpty() || intervals.firstKey() > val + 1) {\n            intervals.put(val, val);\n            return;\n        }\n        Integer lower = intervals.lowerKey(val);\n        Integer upper = intervals.higherKey(val);\n        if (lower != null && intervals.get(lower) + 1 == val) {\n            intervals.put(lower, intervals.get(lower) + 1);\n\n            if (upper != null && val + 1 == upper) {\n                intervals.put(lower, intervals.get(upper));\n                intervals.remove(upper);\n            }\n        } else if (upper != null && val + 1 == upper) {\n            intervals.put(val, intervals.get(upper));\n            intervals.remove(upper);\n        } else {\n            intervals.put(val, val);\n        }\n    }\n\n    public List<List<Integer>> getIntervals() {\n        List<List<Integer>> result = new ArrayList<>();\n        for (Integer key : intervals.keySet()) {\n            List<Integer> range = new ArrayList<>();\n            range.add(key);\n            range.add(intervals.get(key));\n            result.add(range);\n        }\n        return result;\n    }\n}", "cpp": "#include <map>\n\nclass SummaryRanges {\npublic:\n    void addNum(int val) {\n        if (intervals.empty() || intervals.begin()->first > val + 1) {\n            intervals[val] = val;\n        } else {\n            auto it = intervals.lower_bound(val);\n            auto left = prev(it), right = it;\n            \n            if (left != intervals.end() && left->second + 1 == val) {\n                left->second++;\n                if (right != intervals.end() && val + 1 == right->first) {\n                    left->second = right->second;\n                    intervals.erase(right);\n                }\n            } else if (right != intervals.end() && val + 1 == right->first) {\n                intervals[val] = right->second;\n                intervals.erase(right);\n            } else {\n                intervals[val] = val;\n            }\n        }\n    }\n\n    vector<vector<int>> getIntervals() {\n        vector<vector<int>> result;\n        for (const auto& interval : intervals) {\n            result.push_back({interval.first, interval.second});\n        }\n        return result;\n    }\n\nprivate:\n    map<int, int> intervals;\n};", "javascript": "class SummaryRanges {\n    constructor() {\n        this.intervals = new Map();\n    }\n\n    addNum(val) {\n        if (!this.intervals.size || [...this.intervals.keys()][0] > val + 1) {\n            this.intervals.set(val, val);\n        } else {\n            let keys = [...this.intervals.keys()];\n            let index = keys.findIndex(key => key > val);\n\n            if (index > 0 && keys[index - 1] <= val && val <= this.intervals.get(keys[index - 1])) {\n                return;\n            } else if (index !== -1 && val + 1 === keys[index]) {\n                this.intervals.set(val, this.intervals.get(keys[index]));\n                this.intervals.delete(keys[index]);\n            } else {\n                this.intervals.set(val, val);\n            }\n        }\n    }\n\n    getIntervals() {\n        return [...this.intervals.entries()].map(([start, end]) => [start, end]);\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/353", "prompt": "Design a [Snake game](https://en.wikipedia.org/wiki/Snake_(video_game)) that is played on a device with screen size `height x width`. [Play the game online](http://patorjk.com/games/snake/) if you are not familiar with the game.\n\nThe snake is initially positioned at the top left corner `(0, 0)` with a length of `1` unit.\n\nYou are given an array `food` where `food[i] = (ri, ci)` is the row and column position of a piece of food that the snake can eat. When a snake eats a piece of food, its length and the game's score both increase by `1`.\n\nEach piece of food appears one by one on the screen, meaning the second piece of food will not appear until the snake eats the first piece of food.\n\nWhen a piece of food appears on the screen, it is **guaranteed** that it will not appear on a block occupied by the snake.\n\nThe game is over if the snake goes out of bounds (hits a wall) or if its head occupies a space that its body occupies **after** moving (i.e. a snake of length 4 cannot run into itself).\n\nImplement the `SnakeGame` class:\n\n*   `SnakeGame(int width, int height, int[][] food)` Initializes the object with a screen of size `height x width` and the positions of the `food`.\n*   `int move(String direction)` Returns the score of the game after applying one `direction` move by the snake. If the game is over, return `-1`.\n\n**Example 1:**\n\n**Input**\n\\[ \"SnakeGame \",  \"move \",  \"move \",  \"move \",  \"move \",  \"move \",  \"move \"\\]\n\\[\\[3, 2, \\[\\[1, 2\\], \\[0, 1\\]\\]\\], \\[ \"R \"\\], \\[ \"D \"\\], \\[ \"R \"\\], \\[ \"U \"\\], \\[ \"L \"\\], \\[ \"U \"\\]\\]\n**Output**\n\\[null, 0, 0, 1, 1, 2, -1\\]\n\n**Explanation**\nSnakeGame snakeGame = new SnakeGame(3, 2, \\[\\[1, 2\\], \\[0, 1\\]\\]);\nsnakeGame.move( \"R \"); // return 0\nsnakeGame.move( \"D \"); // return 0\nsnakeGame.move( \"R \"); // return 1, snake eats the first piece of food. The second piece of food appears at (0, 1).\nsnakeGame.move( \"U \"); // return 1\nsnakeGame.move( \"L \"); // return 2, snake eats the second food. No more food appears.\nsnakeGame.move( \"U \"); // return -1, game over because snake collides with border\n\n**Constraints:**\n\n*   `1 <= width, height <= 104`\n*   `1 <= food.length <= 50`\n*   `food[i].length == 2`\n*   `0 <= ri < height`\n*   `0 <= ci < width`\n*   `direction.length == 1`\n*   `direction` is `'U'`, `'D'`, `'L'`, or `'R'`.\n*   At most `104` calls will be made to `move`.", "entry_point": "design_snake_game", "canonical_solutions": {"python": "from collections import deque\n\nclass SnakeGame:\n    def __init__(self, width: int, height: int, food: List[List[int]]):\n        self.width = width\n        self.height = height\n        self.food = food\n        self.pos = 0\n        self.score = 0\n        self.snake = deque([(0, 0)])\n        self.occupied = {(0, 0)}\n        self.dx = {'U': -1, 'D': 1, 'L': 0, 'R': 0}\n        self.dy = {'U': 0, 'D': 0, 'L': -1, 'R': 1}\n\n    def move(self, direction: str) -> int:\n        new_x = self.snake[-1][0] + self.dx[direction]\n        new_y = self.snake[-1][1] + self.dy[direction]\n\n        if new_x < 0 or new_x >= self.height or new_y < 0 or new_y >= self.width:\n            return -1\n\n        new_head = (new_x, new_y)\n        tail = self.snake.popleft()\n\n        if self.pos < len(self.food) and self.food[self.pos] == list(new_head):\n            self.score += 1\n            self.pos += 1\n        else:\n            self.occupied.remove(tail)\n\n        if new_head in self.occupied:\n            return -1\n\n        self.snake.append(new_head)\n        self.occupied.add(new_head)\n        return self.score", "java": "import java.util.*;\n\nclass SnakeGame {\n    private int width, height, pos, score;\n    private int[][] food;\n    private LinkedList<int[]> snake;\n    private Set<String> occupied;\n\n    public SnakeGame(int width, int height, int[][] food) {\n        this.width = width;\n        this.height = height;\n        this.food = food;\n        pos = 0;\n        score = 0;\n        snake = new LinkedList<>();\n        occupied = new HashSet<>();\n        snake.add(new int[]{0, 0});\n        occupied.add(\"0_0\");\n    }\n\n    public int move(String direction) {\n        int newX = snake.peekLast()[0] + dx.get(direction);\n        int newY = snake.peekLast()[1] + dy.get(direction);\n\n        if (newX < 0 || newX >= height || newY < 0 || newY >= width) {\n            return -1;\n        }\n\n        int[] newHead = new int[]{newX, newY};\n        int[] tail = snake.poll();\n\n        if (pos < food.length && food[pos][0] == newX && food[pos][1] == newY) {\n            score++;\n            pos++;\n        } else {\n            occupied.remove(tail[0] + \"_\" + tail[1]);\n        }\n\n        if (occupied.contains(newX + \"_\" + newY)) {\n            return -1;\n        }\n\n        snake.add(newHead);\n        occupied.add(newX + \"_\" + newY);\n        return score;\n    }\n\n    private static final Map<String, Integer> dx = Map.of(\"U\", -1, \"D\", 1, \"L\", 0, \"R\", 0);\n    private static final Map<String, Integer> dy = Map.of(\"U\", 0, \"D\", 0, \"L\", -1, \"R\", 1);\n}", "cpp": "#include <list>\n#include <unordered_set>\n#include <vector>\n\nclass SnakeGame {\npublic:\n    SnakeGame(int width, int height, std::vector<std::vector<int>>& food)\n        : width(width), height(height), food(food), pos(0), score(0) {\n        snake.push_back({0, 0});\n        occupied.insert(0);\n    }\n\n    int move(std::string direction) {\n        int new_x = snake.back().first + dx[direction];\n        int new_y = snake.back().second + dy[direction];\n\n        if (new_x < 0 || new_x >= height || new_y < 0 || new_y >= width) {\n            return -1;\n        }\n\n        std::pair<int, int> new_head = std::make_pair(new_x, new_y);\n        std::pair<int, int> tail = snake.front();\n\n        if (pos < food.size() && food[pos][0] == new_x && food[pos][1] == new_y) {\n            score++;\n            pos++;\n        } else {\n            snake.pop_front();\n            occupied.erase(tail.first * width + tail.second);\n        }\n\n        if (occupied.count(new_head.first * width + new_head.second)) {\n            return -1;\n        }\n\n        snake.push_back(new_head);\n        occupied.insert(new_head.first * width + new_head.second);\n        return score;\n    }\n\nprivate:\n    int width;\n    int height;\n    std::vector<std::vector<int>> food;\n    int pos;\n    int score;\n    std::list<std::pair<int, int>> snake;\n    std::unordered_set<int> occupied;\n    std::unordered_map<std::string, int> dx = {{\"U\", -1}, {\"D\", 1}, {\"L\", 0}, {\"R\", 0}};\n    std::unordered_map<std::string, int> dy = {{\"U\", 0}, {\"D\", 0}, {\"L\", -1}, {\"R\", 1}};\n};", "javascript": "class SnakeGame {\n    constructor(width, height, food) {\n        this.width = width;\n        this.height = height;\n        this.food = food;\n        this.pos = 0;\n        this.score = 0;\n        this.snake = [[0, 0]];\n        this.occupied = new Set(['0_0']);\n        this.dx = {'U': -1, 'D': 1, 'L': 0, 'R': 0};\n        this.dy = {'U': 0, 'D': 0, 'L': -1, 'R': 1};\n    }\n\n    move(direction) {\n        let newX = this.snake[this.snake.length - 1][0] + this.dx[direction];\n        let newY = this.snake[this.snake.length - 1][1] + this.dy[direction];\n\n        if (newX < 0 || newX >= this.height || newY < 0 || newY >= this.width) {\n            return -1;\n        }\n\n        let newHead = [newX, newY];\n        let tail = this.snake.shift();\n\n        if (this.pos < this.food.length && this.food[this.pos][0] === newX && this.food[this.pos][1] === newY) {\n            this.score++;\n            this.pos++;\n        } else {\n            this.occupied.delete(tail[0] + '_' + tail[1]);\n        }\n\n        if (this.occupied.has(newX + '_' + newY)) {\n            return -1;\n        }\n\n        this.snake.push(newHead);\n        this.occupied.add(newX + '_' + newY);\n        return this.score;\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/354", "prompt": "You are given a 2D array of integers `envelopes` where `envelopes[i] = [wi, hi]` represents the width and the height of an envelope.\n\nOne envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.\n\nReturn _the maximum number of envelopes you can Russian doll (i.e., put one inside the other)_.\n\n**Note:** You cannot rotate an envelope.\n\n**Example 1:**\n\n**Input:** envelopes = \\[\\[5,4\\],\\[6,4\\],\\[6,7\\],\\[2,3\\]\\]\n**Output:** 3\n**Explanation:** The maximum number of envelopes you can Russian doll is `3` (\\[2,3\\] => \\[5,4\\] => \\[6,7\\]).\n\n**Example 2:**\n\n**Input:** envelopes = \\[\\[1,1\\],\\[1,1\\],\\[1,1\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= envelopes.length <= 105`\n*   `envelopes[i].length == 2`\n*   `1 <= wi, hi <= 105`", "entry_point": "russian_doll_envelopes", "canonical_solutions": {"python": "from bisect import bisect_left\n\ndef max_envelopes(envelopes):\n    envelopes.sort(key=lambda x: (x[0], -x[1]))\n    dp = []\n    \n    for _, h in envelopes:\n        idx = bisect_left(dp, h)\n        if idx == len(dp):\n            dp.append(h)\n        else:\n            dp[idx] = h\n\n    return len(dp)", "java": "import java.util.Arrays;\nimport java.util.Comparator;\n\npublic int maxEnvelopes(int[][] envelopes) {\n    Arrays.sort(envelopes, new Comparator<int[]>() {\n        public int compare(int[] a, int[] b) {\n            return a[0] == b[0] ? b[1] - a[1] : a[0] - b[0];\n        }\n    });\n\n    int[] dp = new int[envelopes.length];\n    int len = 0;\n    for (int[] envelope : envelopes) {\n        int idx = Arrays.binarySearch(dp, 0, len, envelope[1]);\n        if (idx < 0) {\n            idx = -(idx + 1);\n        }\n        dp[idx] = envelope[1];\n        if (idx == len) {\n            len++;\n        }\n    }\n\n    return len;\n}", "cpp": "#include <vector>\n#include <algorithm>\n\nint maxEnvelopes(std::vector<std::vector<int>>& envelopes) {\n    std::sort(envelopes.begin(), envelopes.end(), [](const std::vector<int>& a, const std::vector<int>& b) {\n        return a[0] == b[0] ? a[1] > b[1] : a[0] < b[0];\n    });\n    \n    std::vector<int> dp;\n    for (const auto& envelope : envelopes) {\n        auto it = std::lower_bound(dp.begin(), dp.end(), envelope[1]);\n        if (it == dp.end()) {\n            dp.push_back(envelope[1]);\n        } else {\n            *it = envelope[1];\n        }\n    }\n    \n    return dp.size();\n}", "javascript": "function maxEnvelopes(envelopes) {\n    envelopes.sort((a, b) => a[0] === b[0] ? b[1] - a[1] : a[0] - b[0]);\n    const dp = [];\n\n    for (const envelope of envelopes) {\n        const idx = lowerBound(dp, envelope[1]);\n        if (idx === dp.length) {\n            dp.push(envelope[1]);\n        } else {\n            dp[idx] = envelope[1];\n        }\n    }\n\n    return dp.length;\n\n    function lowerBound(arr, target) {\n        let low = 0, high = arr.length;\n        while (low < high) {\n            const mid = Math.floor((low + high) / 2);\n            if (arr[mid] < target) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return low;\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/355", "prompt": "Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the `10` most recent tweets in the user's news feed.\n\nImplement the `Twitter` class:\n\n*   `Twitter()` Initializes your twitter object.\n*   `void postTweet(int userId, int tweetId)` Composes a new tweet with ID `tweetId` by the user `userId`. Each call to this function will be made with a unique `tweetId`.\n*   `List getNewsFeed(int userId)` Retrieves the `10` most recent tweet IDs in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be **ordered from most recent to least recent**.\n*   `void follow(int followerId, int followeeId)` The user with ID `followerId` started following the user with ID `followeeId`.\n*   `void unfollow(int followerId, int followeeId)` The user with ID `followerId` started unfollowing the user with ID `followeeId`.\n\n**Example 1:**\n\n**Input**\n\\[ \"Twitter \",  \"postTweet \",  \"getNewsFeed \",  \"follow \",  \"postTweet \",  \"getNewsFeed \",  \"unfollow \",  \"getNewsFeed \"\\]\n\\[\\[\\], \\[1, 5\\], \\[1\\], \\[1, 2\\], \\[2, 6\\], \\[1\\], \\[1, 2\\], \\[1\\]\\]\n**Output**\n\\[null, null, \\[5\\], null, null, \\[6, 5\\], null, \\[5\\]\\]\n\n**Explanation**\nTwitter twitter = new Twitter();\ntwitter.postTweet(1, 5); // User 1 posts a new tweet (id = 5).\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> \\[5\\]. return \\[5\\]\ntwitter.follow(1, 2);    // User 1 follows user 2.\ntwitter.postTweet(2, 6); // User 2 posts a new tweet (id = 6).\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 2 tweet ids -> \\[6, 5\\]. Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.\ntwitter.unfollow(1, 2);  // User 1 unfollows user 2.\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> \\[5\\], since user 1 is no longer following user 2.\n\n**Constraints:**\n\n*   `1 <= userId, followerId, followeeId <= 500`\n*   `0 <= tweetId <= 104`\n*   All the tweets have **unique** IDs.\n*   At most `3 * 104` calls will be made to `postTweet`, `getNewsFeed`, `follow`, and `unfollow`.", "entry_point": "design_twitter", "canonical_solutions": {"python": "from collections import defaultdict\nfrom typing import List\n\nclass Twitter:\n\n    class Tweet:\n        def __init__(self, time, tweetId):\n            self.time = time\n            self.tweetId = tweetId\n\n    def __init__(self):\n        self.tweets = defaultdict(list)\n        self.following = defaultdict(set)\n        self.timeStamp = 0\n\n    def postTweet(self, userId: int, tweetId: int) -> None:\n        self.tweets[userId].append(self.Tweet(self.timeStamp, tweetId))\n        self.timeStamp += 1\n\n    def getNewsFeed(self, userId: int) -> List[int]:\n        feed = self.tweets[userId][:]\n        for user in self.following[userId]:\n            feed.extend(self.tweets[user])\n\n        feed.sort(key=lambda x: x.time, reverse=True)\n        return [t.tweetId for t in feed[:10]]\n\n    def follow(self, followerId: int, followeeId: int) -> None:\n        if followerId != followeeId:\n            self.following[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        self.following[followerId].discard(followeeId)", "java": "import java.util.*;\n\nclass Twitter {\n    class Tweet {\n        int time;\n        int tweetId;\n\n        Tweet(int t, int id) {\n            time = t;\n            tweetId = id;\n        }\n    }\n\n    private Map<Integer, List<Tweet>> tweets;\n    private Map<Integer, Set<Integer>> following;\n    private int timeStamp;\n\n    public Twitter() {\n        tweets = new HashMap<>();\n        following = new HashMap<>();\n        timeStamp = 0;\n    }\n\n    public void postTweet(int userId, int tweetId) {\n        tweets.putIfAbsent(userId, new ArrayList<>());\n        tweets.get(userId).add(new Tweet(timeStamp++, tweetId));\n    }\n\n    public List<Integer> getNewsFeed(int userId) {\n        List<Tweet> feed = new ArrayList<>();\n        if (tweets.containsKey(userId)) {\n            feed.addAll(tweets.get(userId));\n        }\n        if (following.containsKey(userId)) {\n            for (int user : following.get(userId)) {\n                if (tweets.containsKey(user)) {\n                    feed.addAll(tweets.get(user));\n                }\n            }\n        }\n\n        feed.sort((a, b) -> b.time - a.time);\n\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < feed.size() && i < 10; ++i) {\n            result.add(feed.get(i).tweetId);\n        }\n        return result;\n    }\n\n    public void follow(int followerId, int followeeId) {\n        if (followerId != followeeId) {\n            following.putIfAbsent(followerId, new HashSet<>());\n            following.get(followerId).add(followeeId);\n        }\n    }\n\n    public void unfollow(int followerId, int followeeId) {\n        if (following.containsKey(followerId)) {\n            following.get(followerId).remove(followeeId);\n        }\n    }\n}", "cpp": "#include <list>\n#include <unordered_map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Twitter {\npublic:\n    class Tweet {\n    public:\n        int time;\n        int tweetId;\n        Tweet(int t, int id) : time(t), tweetId(id) {}\n    };\n\n    unordered_map<int, vector<Tweet>> tweets;\n    unordered_map<int, unordered_set<int>> following;\n    int timeStamp;\n\n    Twitter() {\n        timeStamp = 0;\n    }\n\n    void postTweet(int userId, int tweetId) {\n        tweets[userId].emplace_back(timeStamp++, tweetId);\n    }\n\n    vector<int> getNewsFeed(int userId) {\n        vector<Tweet*> feed;\n        for (Tweet& t : tweets[userId]) {\n            feed.push_back(&t);\n        }\n        for (int user : following[userId]) {\n            for (Tweet& t : tweets[user]) {\n                feed.push_back(&t);\n            }\n        }\n        \n        sort(feed.begin(), feed.end(), [](Tweet* a, Tweet* b) {\n            return a->time > b->time;\n        });\n\n        vector<int> result;\n        for (int i = 0; i < feed.size() && i < 10; ++i) {\n            result.push_back(feed[i]->tweetId);\n        }\n        return result;\n    }\n\n    void follow(int followerId, int followeeId) {\n        if (followerId != followeeId) {\n            following[followerId].insert(followeeId);\n        }\n    }\n\n    void unfollow(int followerId, int followeeId) {\n        following[followerId].erase(followeeId);\n    }\n};", "javascript": "class Twitter {\n    constructor() {\n        this.tweets = {};\n        this.following = {};\n        this.timeStamp = 0;\n    }\n\n    postTweet(userId, tweetId) {\n        if (!this.tweets[userId]) {\n            this.tweets[userId] = [];\n        }\n        this.tweets[userId].push({ time: this.timeStamp++, tweetId });\n    }\n\n    getNewsFeed(userId) {\n        let feed = this.tweets[userId] ? [...this.tweets[userId]] : [];\n        if (this.following[userId]) {\n            for (const user of this.following[userId]) {\n                if (this.tweets[user]) {\n                    feed.push(...this.tweets[user]);\n                }\n            }\n        }\n\n        feed.sort((a, b) => b.time - a.time);\n\n        return feed.slice(0, 10).map(tweet => tweet.tweetId);\n    }\n\n    follow(followerId, followeeId) {\n        if (followerId !== followeeId) {\n            if (!this.following[followerId]) {\n                this.following[followerId] = new Set();\n            }\n            this.following[followerId].add(followeeId);\n        }\n    }\n\n    unfollow(followerId, followeeId) {\n        if (this.following[followerId]) {\n            this.following[followerId].delete(followeeId);\n        }\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/356", "prompt": "Given `n` points on a 2D plane, find if there is such a line parallel to the y-axis that reflects the given points symmetrically.\n\nIn other words, answer whether or not if there exists a line that after reflecting all points over the given line, the original points' set is the same as the reflected ones.\n\n**Note** that there can be repeated points.\n\n**Example 1:**\n\n**Input:** points = \\[\\[1,1\\],\\[-1,1\\]\\]\n**Output:** true\n**Explanation:** We can choose the line x = 0.\n\n**Example 2:**\n\n**Input:** points = \\[\\[1,1\\],\\[-1,-1\\]\\]\n**Output:** false\n**Explanation:** We can't choose a line.\n\n**Constraints:**\n\n*   `n == points.length`\n*   `1 <= n <= 104`\n*   `-108 <= points[i][j] <= 108`\n\n**Follow up:** Could you do better than `O(n2)`?", "entry_point": "line_reflection", "canonical_solutions": {"python": "def isReflected(points):\n    min_x = min(point[0] for point in points)\n    max_x = max(point[0] for point in points)\n    point_set = {(point[0], point[1]) for point in points}\n    \n    sum_x = min_x + max_x\n    for point in points:\n        if (sum_x - point[0], point[1]) not in point_set:\n            return False\n\n    return True", "java": "public boolean isReflected(int[][] points) {\n    int minX = Integer.MAX_VALUE;\n    int maxX = Integer.MIN_VALUE;\n    Set<String> pointSet = new HashSet<>();\n\n    for (int[] point : points) {\n        minX = Math.min(minX, point[0]);\n        maxX = Math.max(maxX, point[0]);\n        pointSet.add(point[0] + \",\" + point[1]);\n    }\n\n    int sum = minX + maxX;\n    for (int[] point : points) {\n        if (!pointSet.contains((sum - point[0]) + \",\" + point[1])) {\n            return false;\n        }\n    }\n\n    return true;\n}", "cpp": "bool isReflected(vector<vector<int>>& points) {\n    int minX = INT_MAX;\n    int maxX = INT_MIN;\n\n    unordered_set<string> pointSet;\n    for(const auto& point : points) {\n        minX = min(minX, point[0]);\n        maxX = max(maxX, point[0]);\n        pointSet.insert(to_string(point[0]) + \",\" + to_string(point[1]));\n    }\n\n    int sum = minX + maxX;\n    for(const auto& point : points) {\n        if(!pointSet.count(to_string(sum - point[0]) + \",\" + to_string(point[1]))) {\n            return false;\n        }\n    }\n\n    return true;\n}", "javascript": "function isReflected(points) {\n    let minX = Infinity;\n    let maxX = -Infinity;\n    const pointSet = new Set();\n\n    for (const point of points) {\n        minX = Math.min(minX, point[0]);\n        maxX = Math.max(maxX, point[0]);\n        pointSet.add(point[0] + \",\" + point[1]);\n    }\n\n    const sum = minX + maxX;\n    for (const point of points) {\n        if (!pointSet.has((sum - point[0]) + \",\" + point[1])) {\n            return false;\n        }\n    }\n\n    return true;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/357", "prompt": "Given an integer `n`, return the count of all numbers with unique digits, `x`, where `0 <= x < 10n`.\n\n**Example 1:**\n\n**Input:** n = 2\n**Output:** 91\n**Explanation:** The answer should be the total numbers in the range of 0 <= x < 100, excluding 11,22,33,44,55,66,77,88,99\n\n**Example 2:**\n\n**Input:** n = 0\n**Output:** 1\n\n**Constraints:**\n\n*   `0 <= n <= 8`", "entry_point": "count_numbers_with_unique_digits", "canonical_solutions": {"python": "def countNumbersWithUniqueDigits(n):\n    if n == 0:\n        return 1\n    \n    total = 10\n    unique_digits = 9\n    current_available_digits = 9\n    \n    while n > 1 and current_available_digits > 0:\n        unique_digits *= current_available_digits\n        total += unique_digits\n        current_available_digits -= 1\n        n -= 1\n        \n    return total", "java": "public int countNumbersWithUniqueDigits(int n) {\n    if (n == 0) return 1;\n\n    int total = 10;\n    int uniqueDigits = 9;\n    int currentAvailableDigits = 9;\n\n    while (n-- > 1 && currentAvailableDigits > 0) {\n        uniqueDigits *= currentAvailableDigits;\n        total += uniqueDigits;\n        currentAvailableDigits--;\n    }\n\n    return total;\n}", "cpp": "int countNumbersWithUniqueDigits(int n) {\n    if (n == 0) return 1;\n    \n    int total = 10;\n    int uniqueDigits = 9;\n    int currentAvailableDigits = 9;\n    \n    while(n-- > 1 && currentAvailableDigits > 0) {\n        uniqueDigits *= currentAvailableDigits;\n        total += uniqueDigits;\n        currentAvailableDigits--;\n    }\n    \n    return total;\n}", "javascript": "function countNumbersWithUniqueDigits(n) {\n    if (n === 0) return 1;\n\n    let total = 10;\n    let uniqueDigits = 9;\n    let currentAvailableDigits = 9;\n\n    while (n-- > 1 && currentAvailableDigits > 0) {\n        uniqueDigits *= currentAvailableDigits;\n        total += uniqueDigits;\n        currentAvailableDigits--;\n    }\n\n    return total;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/358", "prompt": "Given a string `s` and an integer `k`, rearrange `s` such that the same characters are **at least** distance `k` from each other. If it is not possible to rearrange the string, return an empty string `\" \"`.\n\n**Example 1:**\n\n**Input:** s =  \"aabbcc \", k = 3\n**Output:**  \"abcabc \"\n**Explanation:** The same letters are at least a distance of 3 from each other.\n\n**Example 2:**\n\n**Input:** s =  \"aaabc \", k = 3\n**Output:**  \" \"\n**Explanation:** It is not possible to rearrange the string.\n\n**Example 3:**\n\n**Input:** s =  \"aaadbbcc \", k = 2\n**Output:**  \"abacabcd \"\n**Explanation:** The same letters are at least a distance of 2 from each other.\n\n**Constraints:**\n\n*   `1 <= s.length <= 3 * 105`\n*   `s` consists of only lowercase English letters.\n*   `0 <= k <= s.length`", "entry_point": "rearrange_string_k_distance_apart", "canonical_solutions": {"python": "import heapq\nfrom collections import Counter\n\ndef rearrange_string(s, k):\n    if k == 0:\n        return s\n\n    counter = Counter(s)\n    max_heap = [(-count, char) for char, count in counter.items()]\n    heapq.heapify(max_heap)\n\n    result = []\n    while max_heap:\n        temp = []\n\n        for _ in range(k):\n            if not max_heap:\n                break\n\n            count, char = heapq.heappop(max_heap)\n            result.append(char)\n\n            if count + 1 < 0:\n                temp.append((count + 1, char))\n\n        for item in temp:\n            heapq.heappush(max_heap, item)\n\n        if not max_heap:\n            break\n\n        if len(result) < len(s):\n            result.extend([' '] * (k - len(temp)))\n\n    if len(result) < len(s):\n        return \"\"\n    return \"\".join(result)", "java": "import java.util.*;\n\npublic class Solution {\n    public String rearrangeString(String s, int k) {\n        if (k == 0) return s;\n\n        Map<Character, Integer> freqMap = new HashMap<>();\n        for (char c : s.toCharArray()) {\n            freqMap.put(c, freqMap.getOrDefault(c, 0) + 1);\n        }\n\n        PriorityQueue<Map.Entry<Character, Integer>> maxHeap =\n                new PriorityQueue<>((a, b) -> b.getValue() - a.getValue());\n        maxHeap.addAll(freqMap.entrySet());\n\n        StringBuilder result = new StringBuilder();\n        while (!maxHeap.isEmpty()) {\n            List<Map.Entry<Character, Integer>> temp = new ArrayList<>();\n\n            for (int i = 0; i < k && !maxHeap.isEmpty(); i++) {\n                Map.Entry<Character, Integer> curr = maxHeap.poll();\n\n                result.append(curr.getKey());\n                if (curr.getValue() - 1 > 0) {\n                    curr.setValue(curr.getValue() - 1);\n                    temp.add(curr);\n                }\n            }\n\n            maxHeap.addAll(temp);\n\n            if (maxHeap.isEmpty()) break;\n            if (result.length() < s.length()) {\n                int spaces = k - temp.size();\n                while (spaces-- > 0) result.append(\" \");\n            }\n        }\n\n        if (result.length() < s.length()) return \"\";\n        return result.toString();\n    }\n}", "cpp": "#include <queue>\n#include <unordered_map>\n#include <string>\nusing namespace std;\n\nstring rearrangeString(string s, int k) {\n    if (k == 0) return s;\n    \n    unordered_map<char, int> freq;\n    for (char c : s) {\n        freq[c]++;\n    }\n    \n    priority_queue<pair<int, char>> max_heap;\n    for (const auto& kv : freq) {\n        max_heap.emplace(kv.second, kv.first);\n    }\n    \n    string result;\n    while (!max_heap.empty()) {\n        vector<pair<int, char>> temp;\n        \n        for (int i = 0; i < k && !max_heap.empty(); ++i) {\n            auto curr = max_heap.top();\n            max_heap.pop();\n            \n            result += curr.second;\n            if (--curr.first > 0) {\n                temp.push_back(curr);\n            }\n        }\n        \n        for (const auto& entry : temp) {\n            max_heap.push(entry);\n        }\n        \n        if (max_heap.empty()) break;\n        if (result.length() < s.length()) result.append(k - temp.size(), ' ');\n    }\n    \n    if (result.length() < s.length()) return \"\";\n    return result;\n}", "javascript": "function rearrangeString(s, k) {\n  if (k === 0) return s;\n\n  const freqMap = new Map();\n  for (const c of s) {\n    freqMap.set(c, (freqMap.get(c) || 0) + 1);\n  }\n\n  const maxHeap = Array.from(freqMap.entries()).sort((a, b) => b[1] - a[1]);\n\n  let result = '';\n  while (maxHeap.length) {\n    const temp = [];\n\n    for (let i = 0; i < k && maxHeap.length > 0; i++) {\n      const curr = maxHeap.shift();\n\n      result += curr[0];\n      if (curr[1] - 1 > 0) {\n        temp.push([curr[0], curr[1] - 1]);\n      }\n    }\n\n    maxHeap.unshift(...temp.sort((a, b) => b[1] - a[1]));\n\n    if (!maxHeap.length) break;\n    if (result.length < s.length) {\n      result += \" \".repeat(k - temp.length);\n    }\n  }\n\n  if (result.length < s.length) return \"\";\n  return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/359", "prompt": "Design a logger system that receives a stream of messages along with their timestamps. Each **unique** message should only be printed **at most every 10 seconds** (i.e. a message printed at timestamp `t` will prevent other identical messages from being printed until timestamp `t + 10`).\n\nAll messages will come in chronological order. Several messages may arrive at the same timestamp.\n\nImplement the `Logger` class:\n\n*   `Logger()` Initializes the `logger` object.\n*   `bool shouldPrintMessage(int timestamp, string message)` Returns `true` if the `message` should be printed in the given `timestamp`, otherwise returns `false`.\n\n**Example 1:**\n\n**Input**\n\\[ \"Logger \",  \"shouldPrintMessage \",  \"shouldPrintMessage \",  \"shouldPrintMessage \",  \"shouldPrintMessage \",  \"shouldPrintMessage \",  \"shouldPrintMessage \"\\]\n\\[\\[\\], \\[1,  \"foo \"\\], \\[2,  \"bar \"\\], \\[3,  \"foo \"\\], \\[8,  \"bar \"\\], \\[10,  \"foo \"\\], \\[11,  \"foo \"\\]\\]\n**Output**\n\\[null, true, true, false, false, false, true\\]\n\n**Explanation**\nLogger logger = new Logger();\nlogger.shouldPrintMessage(1,  \"foo \");  // return true, next allowed timestamp for  \"foo \" is 1 + 10 = 11\nlogger.shouldPrintMessage(2,  \"bar \");  // return true, next allowed timestamp for  \"bar \" is 2 + 10 = 12\nlogger.shouldPrintMessage(3,  \"foo \");  // 3 < 11, return false\nlogger.shouldPrintMessage(8,  \"bar \");  // 8 < 12, return false\nlogger.shouldPrintMessage(10,  \"foo \"); // 10 < 11, return false\nlogger.shouldPrintMessage(11,  \"foo \"); // 11 >= 11, return true, next allowed timestamp for  \"foo \" is 11 + 10 = 21\n\n**Constraints:**\n\n*   `0 <= timestamp <= 109`\n*   Every `timestamp` will be passed in non-decreasing order (chronological order).\n*   `1 <= message.length <= 30`\n*   At most `104` calls will be made to `shouldPrintMessage`.", "entry_point": "logger_rate_limiter", "canonical_solutions": {"python": "class Logger:\n    def __init__(self):\n        self.message_timestamps = {}\n\n    def shouldPrintMessage(self, timestamp: int, message: str) -> bool:\n        if message not in self.message_timestamps or timestamp - self.message_timestamps[message] >= 10:\n            self.message_timestamps[message] = timestamp\n            return True\n        return False", "java": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Logger {\n    private Map<String, Integer> messageTimestamps;\n\n    public Logger() {\n        messageTimestamps = new HashMap<>();\n    }\n\n    public boolean shouldPrintMessage(int timestamp, String message) {\n        if (!messageTimestamps.containsKey(message) || timestamp - messageTimestamps.get(message) >= 10) {\n            messageTimestamps.put(message, timestamp);\n            return true;\n        }\n        return false;\n    }\n}", "cpp": "#include <unordered_map>\n#include <string>\nusing namespace std;\n\nclass Logger {\npublic:\n    unordered_map<string, int> message_timestamps;\n\n    Logger() {\n    }\n    \n    bool shouldPrintMessage(int timestamp, string message) {\n        if (!message_timestamps.count(message) || timestamp - message_timestamps[message] >= 10) {\n            message_timestamps[message] = timestamp;\n            return true;\n        }\n        return false;\n    }\n};", "javascript": "class Logger {\n    constructor() {\n        this.messageTimestamps = {};\n    }\n\n    shouldPrintMessage(timestamp, message) {\n        if (!this.messageTimestamps.hasOwnProperty(message) || timestamp - this.messageTimestamps[message] >= 10) {\n            this.messageTimestamps[message] = timestamp;\n            return true;\n        }\n        return false;\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/360", "prompt": "Given a **sorted** integer array `nums` and three integers `a`, `b` and `c`, apply a quadratic function of the form `f(x) = ax2 + bx + c` to each element `nums[i]` in the array, and return _the array in a sorted order_.\n\n**Example 1:**\n\n**Input:** nums = \\[-4,-2,2,4\\], a = 1, b = 3, c = 5\n**Output:** \\[3,9,15,33\\]\n\n**Example 2:**\n\n**Input:** nums = \\[-4,-2,2,4\\], a = -1, b = 3, c = 5\n**Output:** \\[-23,-5,1,7\\]\n\n**Constraints:**\n\n*   `1 <= nums.length <= 200`\n*   `-100 <= nums[i], a, b, c <= 100`\n*   `nums` is sorted in **ascending** order.\n\n**Follow up:** Could you solve it in `O(n)` time?", "entry_point": "sort_transformed_array", "canonical_solutions": {"python": "def sort_transformed_array(nums, a, b, c):\n    result = [0] * len(nums)\n    i, j = 0, len(nums) - 1\n    index = len(nums) - 1 if a >= 0 else 0\n    \n    while i <= j:\n        left = nums[i] * nums[i] * a + nums[i] * b + c\n        right = nums[j] * nums[j] * a + nums[j] * b + c\n        \n        if a >= 0:\n            if left >= right:\n                result[index] = left\n                index -= 1\n                i += 1\n            else:\n                result[index] = right\n                index -= 1\n                j -= 1\n        else:\n            if left <= right:\n                result[index] = left\n                index += 1\n                i += 1\n            else:\n                result[index] = right\n                index += 1\n                j -= 1\n    return result", "java": "public int[] sortTransformedArray(int[] nums, int a, int b, int c) {\n    int[] result = new int[nums.length];\n    int i = 0, j = nums.length - 1, index = (a >= 0) ? nums.length - 1 : 0;\n    \n    while (i <= j) {\n        int left = nums[i] * nums[i] * a + nums[i] * b + c;\n        int right = nums[j] * nums[j] * a + nums[j] * b + c;\n        \n        if (a >= 0) {\n            if (left >= right) {\n                result[index--] = left;\n                i++;\n            } else {\n                result[index--] = right;\n                j--;\n            }\n        } else {\n            if (left <= right) {\n                result[index++] = left;\n                i++;\n            } else {\n                result[index++] = right;\n                j--;\n            }\n        }\n    }\n    return result;\n}", "cpp": "vector<int> sortTransformedArray(vector<int>& nums, int a, int b, int c) {\n    vector<int> result(nums.size());\n    int i = 0, j = nums.size() - 1, index = (a >= 0) ? nums.size() - 1 : 0;\n    \n    while (i <= j) {\n        int left = nums[i] * nums[i] * a + nums[i] * b + c;\n        int right = nums[j] * nums[j] * a + nums[j] * b + c;\n        \n        if (a >= 0) {\n            if (left >= right) {\n                result[index--] = left;\n                i++;\n            } else {\n                result[index--] = right;\n                j--;\n            }\n        } else {\n            if (left <= right) {\n                result[index++] = left;\n                i++;\n            } else {\n                result[index++] = right;\n                j--;\n            }\n        }\n    }\n    return result;\n}", "javascript": "function sortTransformedArray(nums, a, b, c) {\n    let result = new Array(nums.length);\n    let i = 0, j = nums.length - 1;\n    let index = (a >= 0) ? nums.length - 1 : 0;\n    \n    while (i <= j) {\n        let left = nums[i] * nums[i] * a + nums[i] * b + c;\n        let right = nums[j] * nums[j] * a + nums[j] * b + c;\n        \n        if (a >= 0) {\n            if (left >= right) {\n                result[index--] = left;\n                i++;\n            } else {\n                result[index--] = right;\n                j--;\n            }\n        } else {\n            if (left <= right) {\n                result[index++] = left;\n                i++;\n            } else {\n                result[index++] = right;\n                j--;\n            }\n        }\n    }\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/361", "prompt": "Given an `m x n` matrix `grid` where each cell is either a wall `'W'`, an enemy `'E'` or empty `'0'`, return _the maximum enemies you can kill using one bomb_. You can only place the bomb in an empty cell.\n\nThe bomb kills all the enemies in the same row and column from the planted point until it hits the wall since it is too strong to be destroyed.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[ \"0 \", \"E \", \"0 \", \"0 \"\\],\\[ \"E \", \"0 \", \"W \", \"E \"\\],\\[ \"0 \", \"E \", \"0 \", \"0 \"\\]\\]\n**Output:** 3\n\n**Example 2:**\n\n**Input:** grid = \\[\\[ \"W \", \"W \", \"W \"\\],\\[ \"0 \", \"0 \", \"0 \"\\],\\[ \"E \", \"E \", \"E \"\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 500`\n*   `grid[i][j]` is either `'W'`, `'E'`, or `'0'`.", "entry_point": "bomb_enemy", "canonical_solutions": {"python": "def maxKilledEnemies(grid):\n    if not grid: return 0\n    m, n, result, rowhits = len(grid), len(grid[0]), 0, 0\n    colhits = [0] * n\n    for i in range(m):\n        for j in range(n):\n            if j == 0 or grid[i][j - 1] == 'W':\n                rowhits = 0\n                k = j\n                while k < n and grid[i][k] != 'W':\n                    rowhits += grid[i][k] == 'E'\n                    k += 1\n            if i == 0 or grid[i - 1][j] == 'W':\n                colhits[j] = 0\n                k = i\n                while k < m and grid[k][j] != 'W':\n                    colhits[j] += grid[k][j] == 'E'\n                    k += 1\n            if grid[i][j] == '0':\n                result = max(result, rowhits + colhits[j])\n    return result", "java": "public int maxKilledEnemies(char[][] grid) {\n    if (grid.length == 0) return 0;\n    int m = grid.length, n = grid[0].length, result = 0, rowhits;\n    int[] colhits = new int[n];\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (j == 0 || grid[i][j-1] == 'W') {\n                rowhits = 0;\n                for (int k = j; k < n && grid[i][k] != 'W'; k++)\n                    rowhits += grid[i][k] == 'E' ? 1 : 0;\n            }\n            if (i == 0 || grid[i-1][j] == 'W') {\n                colhits[j] = 0;\n                for (int k = i; k < m && grid[k][j] != 'W'; k++)\n                    colhits[j] += grid[k][j] == 'E' ? 1 : 0;\n            }\n            if (grid[i][j] == '0') result = Math.max(result, rowhits + colhits[j]);\n        }\n    }\n    return result;\n}", "cpp": "int maxKilledEnemies(vector<vector<char>>& grid) {\n    if (grid.empty()) return 0;\n    int m = grid.size(), n = grid[0].size(), result = 0, rowhits = 0;\n    vector<int> colhits(n, 0);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (j == 0 || grid[i][j - 1] == 'W') {\n                rowhits = 0;\n                for (int k = j; k < n && grid[i][k] != 'W'; k++)\n                    rowhits += grid[i][k] == 'E';\n            }\n            if (i == 0 || grid[i - 1][j] == 'W') {\n                colhits[j] = 0;\n                for (int k = i; k < m && grid[k][j] != 'W'; k++)\n                    colhits[j] += grid[k][j] == 'E';\n            }\n            if (grid[i][j] == '0') result = max(result, rowhits + colhits[j]);\n        }\n    }\n    return result;\n}", "javascript": "function maxKilledEnemies(grid) {\n    if (!grid.length) return 0;\n    let m = grid.length, n = grid[0].length, result = 0, rowhits;\n    let colhits = new Array(n).fill(0);\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (j === 0 || grid[i][j - 1] === 'W') {\n                rowhits = 0;\n                for (let k = j; k < n && grid[i][k] !== 'W'; k++)\n                    rowhits += grid[i][k] === 'E' ? 1 : 0;\n            }\n            if (i === 0 || grid[i - 1][j] === 'W') {\n                colhits[j] = 0;\n                for (let k = i; k < m && grid[k][j] !== 'W'; k++)\n                    colhits[j] += grid[k][j] === 'E' ? 1 : 0;\n            }\n            if (grid[i][j] === '0') result = Math.max(result, rowhits + colhits[j]);\n        }\n    }\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/362", "prompt": "Design a hit counter which counts the number of hits received in the past `5` minutes (i.e., the past `300` seconds).\n\nYour system should accept a `timestamp` parameter (**in seconds** granularity), and you may assume that calls are being made to the system in chronological order (i.e., `timestamp` is monotonically increasing). Several hits may arrive roughly at the same time.\n\nImplement the `HitCounter` class:\n\n*   `HitCounter()` Initializes the object of the hit counter system.\n*   `void hit(int timestamp)` Records a hit that happened at `timestamp` (**in seconds**). Several hits may happen at the same `timestamp`.\n*   `int getHits(int timestamp)` Returns the number of hits in the past 5 minutes from `timestamp` (i.e., the past `300` seconds).\n\n**Example 1:**\n\n**Input**\n\\[ \"HitCounter \",  \"hit \",  \"hit \",  \"hit \",  \"getHits \",  \"hit \",  \"getHits \",  \"getHits \"\\]\n\\[\\[\\], \\[1\\], \\[2\\], \\[3\\], \\[4\\], \\[300\\], \\[300\\], \\[301\\]\\]\n**Output**\n\\[null, null, null, null, 3, null, 4, 3\\]\n\n**Explanation**\nHitCounter hitCounter = new HitCounter();\nhitCounter.hit(1);       // hit at timestamp 1.\nhitCounter.hit(2);       // hit at timestamp 2.\nhitCounter.hit(3);       // hit at timestamp 3.\nhitCounter.getHits(4);   // get hits at timestamp 4, return 3.\nhitCounter.hit(300);     // hit at timestamp 300.\nhitCounter.getHits(300); // get hits at timestamp 300, return 4.\nhitCounter.getHits(301); // get hits at timestamp 301, return 3.\n\n**Constraints:**\n\n*   `1 <= timestamp <= 2 * 109`\n*   All the calls are being made to the system in chronological order (i.e., `timestamp` is monotonically increasing).\n*   At most `300` calls will be made to `hit` and `getHits`.\n\n**Follow up:** What if the number of hits per second could be huge? Does your design scale?", "entry_point": "design_hit_counter", "canonical_solutions": {"python": "from collections import deque\n\nclass HitCounter:\n\n    def __init__(self):\n        self.queue = deque()\n\n    def hit(self, timestamp: int) -> None:\n        self.queue.append(timestamp)\n\n    def getHits(self, timestamp: int) -> int:\n        while self.queue and self.queue[0] <= timestamp - 300:\n            self.queue.popleft()\n        return len(self.queue)", "java": "import java.util.LinkedList;\nimport java.util.Queue;\n\npublic class HitCounter {\n    private Queue<Integer> queue;\n\n    public HitCounter() {\n        queue = new LinkedList<>();\n    }\n\n    public void hit(int timestamp) {\n        queue.offer(timestamp);\n    }\n\n    public int getHits(int timestamp) {\n        while (!queue.isEmpty() && queue.peek() <= (timestamp - 300)) {\n            queue.poll();\n        }\n        return queue.size();\n    }\n}", "cpp": "#include <queue>\n\nclass HitCounter {\npublic:\n    HitCounter() {}\n\n    void hit(int timestamp) {\n        q.push(timestamp);\n    }\n\n    int getHits(int timestamp) {\n        while (!q.empty() && q.front() <= (timestamp - 300)) {\n            q.pop();\n        }\n        return q.size();\n    }\n\nprivate:\n    std::queue<int> q;\n};", "javascript": "class HitCounter {\n  constructor() {\n    this.queue = [];\n  }\n\n  hit(timestamp) {\n    this.queue.push(timestamp);\n  }\n\n  getHits(timestamp) {\n    while (this.queue.length > 0 && this.queue[0] <= timestamp - 300) {\n      this.queue.shift();\n    }\n    return this.queue.length;\n  }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/363", "prompt": "Given an `m x n` matrix `matrix` and an integer `k`, return _the max sum of a rectangle in the matrix such that its sum is no larger than_ `k`.\n\nIt is **guaranteed** that there will be a rectangle with a sum no larger than `k`.\n\n**Example 1:**\n\n**Input:** matrix = \\[\\[1,0,1\\],\\[0,-2,3\\]\\], k = 2\n**Output:** 2\n**Explanation:** Because the sum of the blue rectangle \\[\\[0, 1\\], \\[-2, 3\\]\\] is 2, and 2 is the max number no larger than k (k = 2).\n\n**Example 2:**\n\n**Input:** matrix = \\[\\[2,2,-1\\]\\], k = 3\n**Output:** 3\n\n**Constraints:**\n\n*   `m == matrix.length`\n*   `n == matrix[i].length`\n*   `1 <= m, n <= 100`\n*   `-100 <= matrix[i][j] <= 100`\n*   `-105 <= k <= 105`\n\n**Follow up:** What if the number of rows is much larger than the number of columns?", "entry_point": "max_sum_of_rectangle_no_larger_than_k", "canonical_solutions": {"python": "from sortedcontainers import SortedList\n\ndef maxSumSubmatrix(matrix, k):\n    rows = len(matrix)\n    cols = len(matrix[0])\n    max_sum = float('-inf')\n\n    for l in range(cols):\n        sums = [0] * rows\n        for r in range(l, cols):\n            for i in range(rows):\n                sums[i] += matrix[i][r]\n\n            sorted_sums = SortedList()\n            sorted_sums.add(0)\n            curr_sum = 0\n            for sum in sums:\n                curr_sum += sum\n                it = sorted_sums.bisect_left(curr_sum - k)\n                if it != len(sorted_sums):\n                    max_sum = max(max_sum, curr_sum - sorted_sums[it])\n                sorted_sums.add(curr_sum)\n\n    return max_sum", "java": "import java.util.TreeSet;\n\npublic int maxSumSubmatrix(int[][] matrix, int k) {\n    int rows = matrix.length;\n    int cols = matrix[0].length;\n    int maxSum = Integer.MIN_VALUE;\n\n    for (int l = 0; l < cols; ++l) {\n        int[] sums = new int[rows];\n        for (int r = l; r < cols; ++r) {\n            for (int i = 0; i < rows; ++i) {\n                sums[i] += matrix[i][r];\n            }\n\n            TreeSet<Integer> sortedSums = new TreeSet<>();\n            sortedSums.add(0);\n            int currSum = 0;\n            for (int sum : sums) {\n                currSum += sum;\n                Integer it = sortedSums.ceiling(currSum - k);\n                if (it != null)\n                    maxSum = Math.max(maxSum, currSum - it);\n                sortedSums.add(currSum);\n            }\n        }\n    }\n\n    return maxSum;\n}", "cpp": "#include <vector>\n#include <set>\n\nint maxSumSubmatrix(std::vector<std::vector<int>>& matrix, int k) {\n    int rows = matrix.size();\n    int cols = matrix[0].size();\n    int maxSum = INT_MIN;\n\n    for (int l = 0; l < cols; ++l) {\n        std::vector<int> sums(rows, 0);\n        for (int r = l; r < cols; ++r) {\n            for (int i = 0; i < rows; ++i) {\n                sums[i] += matrix[i][r];\n            }\n\n            std::set<int> sortedSums;\n            sortedSums.insert(0);\n            int currSum = 0;\n            for (int sum : sums) {\n                currSum += sum;\n                auto it = sortedSums.lower_bound(currSum - k);\n                if (it != sortedSums.end())\n                    maxSum = std::max(maxSum, currSum - *it);\n                sortedSums.insert(currSum);\n            }\n        }\n    }\n\n    return maxSum;\n}", "javascript": "function maxSumSubmatrix(matrix, k) {\n    const rows = matrix.length;\n    const cols = matrix[0].length;\n    let maxSum = -Infinity;\n\n    function lowerBound(arr, target) {\n        let l = 0;\n        let r = arr.length;\n        while (l < r) {\n            const mid = Math.floor((l + r) / 2);\n            if (arr[mid] >= target) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return l;\n    }\n\n    for (let l = 0; l < cols; ++l) {\n        const sums = Array(rows).fill(0);\n        for (let r = l; r < cols; ++r) {\n            for (let i = 0; i < rows; ++i) {\n                sums[i] += matrix[i][r];\n            }\n\n            const sortedSums = [0];\n            let currSum = 0;\n            for (const sum of sums) {\n                currSum += sum;\n                const it = lowerBound(sortedSums, currSum - k);\n                if (it < sortedSums.length)\n                    maxSum = Math.max(maxSum, currSum - sortedSums[it]);\n                const insertPosition = lowerBound(sortedSums, currSum);\n                sortedSums.splice(insertPosition, 0, currSum);\n            }\n        }\n    }\n\n    return maxSum;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/364", "prompt": "You are given a nested list of integers `nestedList`. Each element is either an integer or a list whose elements may also be integers or other lists.\n\nThe **depth** of an integer is the number of lists that it is inside of. For example, the nested list `[1,[2,2],[[3],2],1]` has each integer's value set to its **depth**. Let `maxDepth` be the **maximum depth** of any integer.\n\nThe **weight** of an integer is `maxDepth - (the depth of the integer) + 1`.\n\nReturn _the sum of each integer in_ `nestedList` _multiplied by its **weight**_.\n\n**Example 1:**\n\n**Input:** nestedList = \\[\\[1,1\\],2,\\[1,1\\]\\]\n**Output:** 8\n**Explanation:** Four 1's with a weight of 1, one 2 with a weight of 2.\n1\\*1 + 1\\*1 + 2\\*2 + 1\\*1 + 1\\*1 = 8\n\n**Example 2:**\n\n**Input:** nestedList = \\[1,\\[4,\\[6\\]\\]\\]\n**Output:** 17\n**Explanation:** One 1 at depth 3, one 4 at depth 2, and one 6 at depth 1.\n1\\*3 + 4\\*2 + 6\\*1 = 17\n\n**Constraints:**\n\n*   `1 <= nestedList.length <= 50`\n*   The values of the integers in the nested list is in the range `[-100, 100]`.\n*   The maximum **depth** of any integer is less than or equal to `50`.", "entry_point": "nested_list_weight_sum_ii", "canonical_solutions": {"python": "from typing import List, Union\n\nNestedInteger = Union[int, List[Union[int, \"NestedInteger\"]]]\n\ndef depthSumInverse(nestedList: List[NestedInteger]) -> int:\n    max_depth = max_depth_helper(nestedList)\n    return sum_helper(nestedList, max_depth)\n\ndef max_depth_helper(nested_list: List[NestedInteger]) -> int:\n    depth = 1\n    for nested in nested_list:\n        if isinstance(nested, list):\n            depth = max(depth, 1 + max_depth_helper(nested))\n    return depth\n\ndef sum_helper(nested_list: List[NestedInteger], depth: int) -> int:\n    sum = 0\n    for nested in nested_list:\n        if isinstance(nested, int):\n            sum += depth * nested\n        else:\n            sum += sum_helper(nested, depth - 1)\n    return sum", "java": "import java.util.*;\n\npublic int depthSumInverse(List<NestedInteger> nestedList) {\n    int maxDepth = maxDepth(nestedList);\n    return sumHelper(nestedList, maxDepth);\n}\n\nprivate int maxDepth(List<NestedInteger> nestedList) {\n    int depth = 1;\n    for (NestedInteger nested : nestedList) {\n        if (!nested.isInteger()) {\n            depth = Math.max(depth, 1 + maxDepth(nested.getList()));\n        }\n    }\n    return depth;\n}\n\nprivate int sumHelper(List<NestedInteger> nestedList, int depth) {\n    int sum = 0;\n    for (NestedInteger nested : nestedList) {\n        if (nested.isInteger()) {\n            sum += depth * nested.getInteger();\n        } else {\n            sum += sumHelper(nested.getList(), depth - 1);\n        }\n    }\n    return sum;\n}", "cpp": "#include <variant>\n#include <vector>\n\nusing NestedInteger = std::variant<int, std::vector<std::variant<int, std::vector<NestedInteger>>>>;\n\nint sumHelper(NestedInteger& nested, int depth) {\n    int sum = 0;\n    if (auto pInt = std::get_if<int>(&nested)) {\n        sum += depth * (*pInt);\n    } else {\n        auto& list = std::get<std::vector<NestedInteger>>(nested);\n        for (auto& element : list) {\n            sum += sumHelper(element, depth - 1);\n        }\n    }\n    return sum;\n}\n\nint maxDepth(NestedInteger& nested) {\n    if (std::holds_alternative<int>(nested)) return 0;\n    int depth = 1;\n    for (auto& element : std::get<std::vector<NestedInteger>>(nested)) {\n        depth = std::max(depth, 1 + maxDepth(element));\n    }\n    return depth;\n}\n\nint depthSumInverse(std::vector<NestedInteger>& nestedList) {\n    int max_depth = 1;\n    for (auto& nested : nestedList) {\n        max_depth = std::max(max_depth, 1 + maxDepth(nested));\n    }\n    int sum = 0;\n    for (auto& nested : nestedList) {\n        sum += sumHelper(nested, max_depth);\n    }\n    return sum;\n}", "javascript": "function depthSumInverse(nestedList) {\n    function maxDepthHelper(nestedList) {\n        let depth = 1;\n        for (let nested of nestedList) {\n            if (Array.isArray(nested)) {\n                depth = Math.max(depth, 1 + maxDepthHelper(nested));\n            }\n        }\n        return depth;\n    }\n    function sumHelper(nestedList, depth) {\n        let sum = 0;\n        for (let nested of nestedList) {\n            if (typeof nested === \"number\") {\n                sum += depth * nested;\n            } else {\n                sum += sumHelper(nested, depth - 1);\n            }\n        }\n        return sum;\n    }\n    let maxDepth = maxDepthHelper(nestedList);\n    return sumHelper(nestedList, maxDepth);\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/365", "prompt": "You are given two jugs with capacities `jug1Capacity` and `jug2Capacity` liters. There is an infinite amount of water supply available. Determine whether it is possible to measure exactly `targetCapacity` liters using these two jugs.\n\nIf `targetCapacity` liters of water are measurable, you must have `targetCapacity` liters of water contained **within one or both buckets** by the end.\n\nOperations allowed:\n\n*   Fill any of the jugs with water.\n*   Empty any of the jugs.\n*   Pour water from one jug into another till the other jug is completely full, or the first jug itself is empty.\n\n**Example 1:**\n\n**Input:** jug1Capacity = 3, jug2Capacity = 5, targetCapacity = 4\n**Output:** true\n**Explanation:** The famous [Die Hard](https://www.youtube.com/watch?v=BVtQNK_ZUJg&ab_channel=notnek01) example \n\n**Example 2:**\n\n**Input:** jug1Capacity = 2, jug2Capacity = 6, targetCapacity = 5\n**Output:** false\n\n**Example 3:**\n\n**Input:** jug1Capacity = 1, jug2Capacity = 2, targetCapacity = 3\n**Output:** true\n\n**Constraints:**\n\n*   `1 <= jug1Capacity, jug2Capacity, targetCapacity <= 106`", "entry_point": "water_and_jug_problem", "canonical_solutions": {"python": "def canMeasureWater(jug1Capacity, jug2Capacity, targetCapacity):\n    if targetCapacity > jug1Capacity + jug2Capacity:\n        return False\n    if jug1Capacity == targetCapacity or jug2Capacity == targetCapacity or jug1Capacity + jug2Capacity == targetCapacity:\n        return True\n    return targetCapacity % gcd(jug1Capacity, jug2Capacity) == 0\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a", "java": "public boolean canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity) {\n    if (targetCapacity > jug1Capacity + jug2Capacity) return false;\n    if (jug1Capacity == targetCapacity || jug2Capacity == targetCapacity \n        || jug1Capacity + jug2Capacity == targetCapacity) return true;\n    return targetCapacity % gcd(jug1Capacity, jug2Capacity) == 0;\n}\n\nprivate int gcd(int a, int b) {\n    while (b != 0) {\n        int tmp = a % b;\n        a = b;\n        b = tmp;\n    }\n    return a;\n}", "cpp": "bool canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity) {\n    if (targetCapacity > jug1Capacity + jug2Capacity) return false;\n    if (jug1Capacity == targetCapacity || jug2Capacity == targetCapacity \n        || jug1Capacity + jug2Capacity == targetCapacity) return true;\n    return targetCapacity % gcd(jug1Capacity, jug2Capacity) == 0;\n}\n\nint gcd(int a, int b) {\n    while (b) {\n        int tmp = a % b;\n        a = b;\n        b = tmp;\n    }\n    return a;\n}", "javascript": "function canMeasureWater(jug1Capacity, jug2Capacity, targetCapacity) {\n    if (targetCapacity > jug1Capacity + jug2Capacity) return false;\n    if (jug1Capacity == targetCapacity || jug2Capacity == targetCapacity \n        || jug1Capacity + jug2Capacity == targetCapacity) return true;\n    return targetCapacity % gcd(jug1Capacity, jug2Capacity) === 0;\n}\n\nfunction gcd(a, b) {\n    while (b) {\n        let tmp = a % b;\n        a = b;\n        b = tmp;\n    }\n    return a;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/366", "prompt": "Given the `root` of a binary tree, collect a tree's nodes as if you were doing this:\n\n*   Collect all the leaf nodes.\n*   Remove all the leaf nodes.\n*   Repeat until the tree is empty.\n\n**Example 1:**\n\n**Input:** root = \\[1,2,3,4,5\\]\n**Output:** \\[\\[4,5,3\\],\\[2\\],\\[1\\]\\]\nExplanation:\n\\[\\[3,5,4\\],\\[2\\],\\[1\\]\\] and \\[\\[3,4,5\\],\\[2\\],\\[1\\]\\] are also considered correct answers since per each level it does not matter the order on which elements are returned.\n\n**Example 2:**\n\n**Input:** root = \\[1\\]\n**Output:** \\[\\[1\\]\\]\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 100]`.\n*   `-100 <= Node.val <= 100`", "entry_point": "find_leaves_of_binary_tree", "canonical_solutions": {"python": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef find_leaves(node, result, level):\n    if not node:\n        return -1\n    left_level = find_leaves(node.left, result, level + 1)\n    right_level = find_leaves(node.right, result, level + 1)\n    level = max(left_level, right_level) + 1\n    if len(result) <= level:\n        result.append([])\n    result[level].append(node.val)\n    return level\n\ndef findLeaves(root):\n    result = []\n    find_leaves(root, result, 0)\n    return result", "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\npublic List<List<Integer>> findLeaves(TreeNode root) {\n    List<List<Integer>> result = new ArrayList<>();\n    findLeaves(root, result, 0);\n    return result;\n}\n\nprivate int findLeaves(TreeNode node, List<List<Integer>> result, int level) {\n    if (node == null) return -1;\n    int leftLevel = findLeaves(node.left, result, level + 1);\n    int rightLevel = findLeaves(node.right, result, level + 1);\n    level = Math.max(leftLevel, rightLevel) + 1;\n    if (result.size() <= level) result.add(new ArrayList<>());\n    result.get(level).add(node.val);\n    return level;\n}", "cpp": "#include <vector>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nvoid findLeaves(TreeNode* node, std::vector<std::vector<int>>& result, int& level) {\n    if (!node) return;\n    if (!node->left && !node->right) {\n        if (result.size() <= level) {\n            result.push_back(std::vector<int>());\n        }\n        result[level].push_back(node->val);\n        node = nullptr;\n        return;\n    }\n    level++;\n    findLeaves(node->left, result, level);\n    findLeaves(node->right, result, level);\n    level--;\n}\n\nstd::vector<std::vector<int>> findLeaves(TreeNode* root) {\n    std::vector<std::vector<int>> result;\n    int level = 0;\n    while (root) {\n        findLeaves(root, result, level);\n        if (!root->left && !root->right) root = nullptr;\n    }\n    return result;\n}", "javascript": "class TreeNode {\n    constructor(val = 0, left = null, right = null){\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction findLeaves(root) {\n    const result = [];\n    findLeavesHelper(root, result, 0);\n    return result;\n}\n\nfunction findLeavesHelper(node, result, level) {\n    if (node === null) return -1;\n    const leftLevel = findLeavesHelper(node.left, result, level + 1);\n    const rightLevel = findLeavesHelper(node.right, result, level + 1);\n    level = Math.max(leftLevel, rightLevel) + 1;\n    if (result.length <= level) result.push([]);\n    result[level].push(node.val);\n    return level;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/367", "prompt": "Given a positive integer num, return `true` _if_ `num` _is a perfect square or_ `false` _otherwise_.\n\nA **perfect square** is an integer that is the square of an integer. In other words, it is the product of some integer with itself.\n\nYou must not use any built-in library function, such as `sqrt`.\n\n**Example 1:**\n\n**Input:** num = 16\n**Output:** true\n**Explanation:** We return true because 4 \\* 4 = 16 and 4 is an integer.\n\n**Example 2:**\n\n**Input:** num = 14\n**Output:** false\n**Explanation:** We return false because 3.742 \\* 3.742 = 14 and 3.742 is not an integer.\n\n**Constraints:**\n\n*   `1 <= num <= 231 - 1`", "entry_point": "valid_perfect_square", "canonical_solutions": {"python": "def is_perfect_square(num: int) -> bool:\n    if num < 2:\n        return True\n    left, right = 2, num // 2\n    while left <= right:\n        mid = left + (right - left) // 2\n        square = mid * mid\n        if square == num:\n            return True\n        if square > num:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return False", "java": "boolean isPerfectSquare(int num) {\n    if (num < 2) return true;\n    long left = 2, right = num / 2, mid, square;\n    while (left <= right) {\n        mid = left + (right - left) / 2;\n        square = mid * mid;\n        if (square == num) return true;\n        if (square > num) right = mid - 1;\n        else left = mid + 1;\n    }\n    return false;\n}", "cpp": "bool isPerfectSquare(int num) {\n    if (num < 2) return true;\n    long long left = 2, right = num / 2, mid, square;\n    while (left <= right) {\n        mid = left + (right - left) / 2;\n        square = mid * mid;\n        if (square == num) return true;\n        if (square > num) right = mid - 1;\n        else left = mid + 1;\n    }\n    return false;\n}", "javascript": "function isPerfectSquare(num) {\n    if (num < 2) return true;\n    let left = 2, right = Math.floor(num / 2), mid, square;\n    while (left <= right) {\n        mid = left + Math.floor((right - left) / 2);\n        square = mid * mid;\n        if (square === num) return true;\n        if (square > num) right = mid - 1;\n        else left = mid + 1;\n    }\n    return false;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/368", "prompt": "Given a set of **distinct** positive integers `nums`, return the largest subset `answer` such that every pair `(answer[i], answer[j])` of elements in this subset satisfies:\n\n*   `answer[i] % answer[j] == 0`, or\n*   `answer[j] % answer[i] == 0`\n\nIf there are multiple solutions, return any of them.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3\\]\n**Output:** \\[1,2\\]\n**Explanation:** \\[1,3\\] is also accepted.\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,4,8\\]\n**Output:** \\[1,2,4,8\\]\n\n**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `1 <= nums[i] <= 2 * 109`\n*   All the integers in `nums` are **unique**.", "entry_point": "largest_divisible_subset", "canonical_solutions": {"python": "def largestDivisibleSubset(nums):\n    nums.sort()\n    n = len(nums)\n    count = [1] * n\n    prev = [-1] * n\n\n    max_idx = 0\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] % nums[j] == 0 and count[i] < count[j] + 1:\n                count[i] = count[j] + 1\n                prev[i] = j\n        if count[max_idx] < count[i]:\n            max_idx = i\n\n    res = []\n    i = max_idx\n    while i >= 0:\n        res.append(nums[i])\n        i = prev[i]\n\n    return res", "java": "import java.util.*;\n\npublic List<Integer> largestDivisibleSubset(int[] nums) {\n    Arrays.sort(nums);\n    int n = nums.length;\n    int[] count = new int[n];\n    int[] prev = new int[n];\n    int max_idx = 0;\n    Arrays.fill(prev, -1);\n    Arrays.fill(count, 1);\n\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            if (nums[i] % nums[j] == 0 && count[i] < count[j] + 1) {\n                count[i] = count[j] + 1;\n                prev[i] = j;\n            }\n        }\n        if (count[max_idx] < count[i]) max_idx = i;\n    }\n\n    List<Integer> res = new ArrayList<>();\n    for (int i = max_idx; i >= 0; i = prev[i]) {\n        res.add(nums[i]);\n    }\n\n    return res;\n}", "cpp": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> largestDivisibleSubset(vector<int>& nums) {\n    sort(nums.begin(), nums.end());\n    int n = nums.size();\n    vector<int> count(n, 1), prev(n, -1), res;\n    int max_idx = 0;\n\n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (nums[i] % nums[j] == 0 && count[i] < count[j] + 1) {\n                count[i] = count[j] + 1;\n                prev[i] = j;\n            }\n        }\n        if (count[max_idx] < count[i]) max_idx = i;\n    }\n\n    for (int i = max_idx; i >= 0; i = prev[i]) {\n        res.push_back(nums[i]);\n    }\n\n    return res;\n}", "javascript": "function largestDivisibleSubset(nums) {\n    nums.sort((a, b) => a - b);\n    const n = nums.length;\n    const count = new Array(n).fill(1);\n    const prev = new Array(n).fill(-1);\n    let max_idx = 0;\n\n    for (let i = 1; i < n; i++) {\n        for (let j = 0; j < i; j++) {\n            if (nums[i] % nums[j] === 0 && count[i] < count[j] + 1) {\n                count[i] = count[j] + 1;\n                prev[i] = j;\n            }\n        }\n        if (count[max_idx] < count[i]) {\n            max_idx = i;\n        }\n    }\n\n    const res = [];\n    for (let i = max_idx; i >= 0; i = prev[i]) {\n        res.push(nums[i]);\n    }\n\n    return res;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/369", "prompt": "Given a non-negative integer represented as a linked list of digits, _plus one to the integer_.\n\nThe digits are stored such that the most significant digit is at the `head` of the list.\n\n**Example 1:**\n\n**Input:** head = \\[1,2,3\\]\n**Output:** \\[1,2,4\\]\n\n**Example 2:**\n\n**Input:** head = \\[0\\]\n**Output:** \\[1\\]\n\n**Constraints:**\n\n*   The number of nodes in the linked list is in the range `[1, 100]`.\n*   `0 <= Node.val <= 9`\n*   The number represented by the linked list does not contain leading zeros except for the zero itself.", "entry_point": "plus_one_linked_list", "canonical_solutions": {"python": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef plusOne(head: ListNode) -> ListNode:\n    def plusOneDfs(node):\n        if not node:\n            return 1\n        carry = plusOneDfs(node.next)\n        if carry + node.val == 10:\n            node.val = 0\n            return 1\n        else:\n            node.val += carry\n            return 0\n\n    if not head:\n        return head\n    carry = plusOneDfs(head)\n    if carry == 1:\n        new_head = ListNode(1)\n        new_head.next = head\n        return new_head\n    return head", "java": "public class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) { val = x; }\n}\n\npublic ListNode plusOne(ListNode head) {\n    if (head == null) return head;\n    int carry = plusOneDfs(head);\n    if (carry == 1) {\n        ListNode newHead = new ListNode(1);\n        newHead.next = head;\n        return newHead;\n    }\n    return head;\n}\n\nprivate int plusOneDfs(ListNode node) {\n    if (node == null) return 1;\n    int carry = plusOneDfs(node.next);\n    if (carry + node.val == 10) {\n        node.val = 0;\n        return 1;\n    } else {\n        node.val += carry;\n        return 0;\n    }\n}", "cpp": "struct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nListNode* plusOne(ListNode* head) {\n    if (head == NULL) return head;\n    if (plusOneDfs(head) == 1) {\n        ListNode* newHead = new ListNode(1);\n        newHead->next = head;\n        return newHead;\n    }\n    return head;\n}\n\nint plusOneDfs(ListNode* node) {\n    if (node == NULL) return 1;\n    int carry = plusOneDfs(node->next);\n    if (carry + node->val == 10) {\n        node->val = 0;\n        return 1;\n    } else {\n        node->val += carry;\n        return 0;\n    }\n}", "javascript": "class ListNode {\n    constructor(val = 0, next = null) {\n        this.val = val;\n        this.next = next;\n    }\n}\n\nfunction plusOne(head) {\n    function plusOneDfs(node) {\n        if (!node) return 1;\n        const carry = plusOneDfs(node.next);\n        if (carry + node.val === 10) {\n            node.val = 0;\n            return 1;\n        } else {\n            node.val += carry;\n            return 0;\n        }\n    }\n\n    if (!head) return head;\n    const carry = plusOneDfs(head);\n    if (carry === 1) {\n        const newHead = new ListNode(1);\n        newHead.next = head;\n        return newHead;\n    }\n    return head;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/370", "prompt": "You are given an integer `length` and an array `updates` where `updates[i] = [startIdxi, endIdxi, inci]`.\n\nYou have an array `arr` of length `length` with all zeros, and you have some operation to apply on `arr`. In the `ith` operation, you should increment all the elements `arr[startIdxi], arr[startIdxi + 1], ..., arr[endIdxi]` by `inci`.\n\nReturn `arr` _after applying all the_ `updates`.\n\n**Example 1:**\n\n**Input:** length = 5, updates = \\[\\[1,3,2\\],\\[2,4,3\\],\\[0,2,-2\\]\\]\n**Output:** \\[-2,0,3,5,3\\]\n\n**Example 2:**\n\n**Input:** length = 10, updates = \\[\\[2,4,6\\],\\[5,6,8\\],\\[1,9,-4\\]\\]\n**Output:** \\[0,-4,2,2,2,4,4,-4,-4,-4\\]\n\n**Constraints:**\n\n*   `1 <= length <= 105`\n*   `0 <= updates.length <= 104`\n*   `0 <= startIdxi <= endIdxi < length`\n*   `-1000 <= inci <= 1000`", "entry_point": "range_addition", "canonical_solutions": {"python": "def get_updated_array(length, updates):\n    arr = [0] * length\n\n    for start, end, inc in updates:\n        arr[start] += inc\n        if end + 1 < length:\n            arr[end + 1] -= inc\n\n    for i in range(1, length):\n        arr[i] += arr[i - 1]\n\n    return arr", "java": "public int[] getUpdatedArray(int length, int[][] updates) {\n    int[] arr = new int[length];\n\n    for (int[] update : updates) {\n        arr[update[0]] += update[2];\n        if (update[1] + 1 < length) {\n            arr[update[1] + 1] -= update[2];\n        }\n    }\n    \n    for (int i = 1; i < length; i++) {\n        arr[i] += arr[i - 1];\n    }\n    \n    return arr;\n}", "cpp": "#include <vector>\nusing namespace std;\n\nvector<int> getUpdatedArray(int length, vector<vector<int>>& updates) {\n    vector<int> arr(length, 0);\n\n    for (const auto& update : updates) {\n        arr[update[0]] += update[2];\n        if (update[1] + 1 < length) {\n            arr[update[1] + 1] -= update[2];\n        }\n    }\n    \n    for (int i = 1; i < length; i++) {\n        arr[i] += arr[i - 1];\n    }\n    \n    return arr;\n}", "javascript": "function getUpdatedArray(length, updates) {\n    const arr = new Array(length).fill(0);\n\n    for (const [start, end, inc] of updates) {\n        arr[start] += inc;\n        if (end + 1 < length) {\n            arr[end + 1] -= inc;\n        }\n    }\n\n    for (let i = 1; i < length; i++) {\n        arr[i] += arr[i - 1];\n    }\n\n    return arr;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/371", "prompt": "Given two integers `a` and `b`, return _the sum of the two integers without using the operators_ `+` _and_ `-`.\n\n**Example 1:**\n\n**Input:** a = 1, b = 2\n**Output:** 3\n\n**Example 2:**\n\n**Input:** a = 2, b = 3\n**Output:** 5\n\n**Constraints:**\n\n*   `-1000 <= a, b <= 1000`", "entry_point": "sum_of_two_integers", "canonical_solutions": {"python": "def add(a, b):\n    MAX = 0x7FFFFFFF\n    MASK = 0xFFFFFFFF\n    while b:\n        a, b = (a ^ b) & MASK, ((a & b) << 1) & MASK\n    return a if a <= MAX else ~(a ^ MASK)", "java": "public int add(int a, int b) {\n    while (b != 0) {\n        int carry = a & b;\n        a = a ^ b;\n        b = carry << 1;\n    }\n    return a;\n}", "cpp": "int add(int a, int b) {\n    while (b != 0) {\n        int carry = a & b;\n        a = a ^ b;\n        b = carry << 1;\n    }\n    return a;\n}", "javascript": "function add(a, b) {\n    while (b) {\n        let carry = a & b;\n        a = a ^ b;\n        b = carry << 1;\n    }\n    return a;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/372", "prompt": "Your task is to calculate `ab` mod `1337` where `a` is a positive integer and `b` is an extremely large positive integer given in the form of an array.\n\n**Example 1:**\n\n**Input:** a = 2, b = \\[3\\]\n**Output:** 8\n\n**Example 2:**\n\n**Input:** a = 2, b = \\[1,0\\]\n**Output:** 1024\n\n**Example 3:**\n\n**Input:** a = 1, b = \\[4,3,3,8,5,2\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= a <= 231 - 1`\n*   `1 <= b.length <= 2000`\n*   `0 <= b[i] <= 9`\n*   `b` does not contain leading zeros.", "entry_point": "super_pow", "canonical_solutions": {"python": "def powmod(a, b):\n    if b == 0:\n        return 1\n    res = powmod(a, b // 2)\n    return res * res % 1337 * a % 1337 if b % 2 else res * res % 1337\n\ndef superPow(a, b):\n    n = 0\n    for bi in b:\n        n = (n * 10 + bi) % 1140\n    return powmod(a % 1337, n + 1140)", "java": "public int powmod(int a, int b) {\n    if (b == 0) return 1;\n    int res = powmod(a, b / 2);\n    if (b % 2 == 0) return res * res % 1337;\n    return res * res % 1337 * a % 1337;\n}\n\npublic int superPow(int a, int[] b) {\n    int n = 0;\n    for (int bi : b) n = (n * 10 + bi) % 1140;\n    return powmod(a % 1337, n + 1140);\n}", "cpp": "int powmod(int a, int b) {\n    if (b == 0) return 1;\n    int res = powmod(a, b / 2);\n    if (b % 2 == 0) return res * res % 1337;\n    return res * res % 1337 * a % 1337;\n}\n\nint superPow(int a, vector<int>& b) {\n    int n = 0;\n    for (int bi : b) n = (n * 10 + bi) % 1140;\n    return powmod(a % 1337, n + 1140);\n}", "javascript": "function powmod(a, b) {\n    if (b === 0) return 1;\n    const res = powmod(a, Math.floor(b / 2));\n    return b % 2 ? res * res % 1337 * a % 1337 : res * res % 1337;\n}\n\nfunction superPow(a, b) {\n    let n = 0;\n    for (const bi of b) n = (n * 10 + bi) % 1140;\n    return powmod(a % 1337, n + 1140);\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/373", "prompt": "You are given two integer arrays `nums1` and `nums2` sorted in **ascending order** and an integer `k`.\n\nDefine a pair `(u, v)` which consists of one element from the first array and one element from the second array.\n\nReturn _the_ `k` _pairs_ `(u1, v1), (u2, v2), ..., (uk, vk)` _with the smallest sums_.\n\n**Example 1:**\n\n**Input:** nums1 = \\[1,7,11\\], nums2 = \\[2,4,6\\], k = 3\n**Output:** \\[\\[1,2\\],\\[1,4\\],\\[1,6\\]\\]\n**Explanation:** The first 3 pairs are returned from the sequence: \\[1,2\\],\\[1,4\\],\\[1,6\\],\\[7,2\\],\\[7,4\\],\\[11,2\\],\\[7,6\\],\\[11,4\\],\\[11,6\\]\n\n**Example 2:**\n\n**Input:** nums1 = \\[1,1,2\\], nums2 = \\[1,2,3\\], k = 2\n**Output:** \\[\\[1,1\\],\\[1,1\\]\\]\n**Explanation:** The first 2 pairs are returned from the sequence: \\[1,1\\],\\[1,1\\],\\[1,2\\],\\[2,1\\],\\[1,2\\],\\[2,2\\],\\[1,3\\],\\[1,3\\],\\[2,3\\]\n\n**Example 3:**\n\n**Input:** nums1 = \\[1,2\\], nums2 = \\[3\\], k = 3\n**Output:** \\[\\[1,3\\],\\[2,3\\]\\]\n**Explanation:** All possible pairs are returned from the sequence: \\[1,3\\],\\[2,3\\]\n\n**Constraints:**\n\n*   `1 <= nums1.length, nums2.length <= 105`\n*   `-109 <= nums1[i], nums2[i] <= 109`\n*   `nums1` and `nums2` both are sorted in **ascending order**.\n*   `1 <= k <= 104`", "entry_point": "find_k_pairs_with_smallest_sums", "canonical_solutions": {"python": "import heapq\n\ndef kSmallestPairs(nums1, nums2, k):\n    if not nums1 or not nums2:\n        return []\n    \n    heap = [(nums1[i] + nums2[0], i, 0) for i in range(min(k, len(nums1)))]\n    heapq.heapify(heap)\n    result = []\n\n    while k > 0 and heap:\n        s, i, j = heapq.heappop(heap)\n        result.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n        k -= 1\n\n    return result", "java": "public List<int[]> kSmallestPairs(int[] nums1, int[] nums2, int k) {\n    PriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) -> (a[0] + a[1]) - (b[0] + b[1]));\n    List<int[]> result = new ArrayList<>();\n\n    if (nums1.length == 0 || nums2.length == 0 || k == 0) {\n        return result;\n    }\n\n    for (int i = 0; i < nums1.length && i < k; i++) {\n        minHeap.offer(new int[]{nums1[i], nums2[0], 0});\n    }\n\n    while (k-- > 0 && !minHeap.isEmpty()) {\n        int[] curr = minHeap.poll();\n        result.add(new int[]{curr[0], curr[1]});\n        if (curr[2] == nums2.length - 1) {\n            continue;\n        }\n        minHeap.offer(new int[]{curr[0], nums2[curr[2] + 1], curr[2] + 1});\n    }\n\n    return result;\n}", "cpp": "vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\n    auto comp = [&nums1, &nums2](pair<int, int> a, pair<int, int> b) {\n        return nums1[a.first] + nums2[a.second] > nums1[b.first] + nums2[b.second];\n    };\n    priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(comp)> min_heap(comp);\n    vector<vector<int>> result;\n\n    if (nums1.empty() || nums2.empty()) return result;\n\n    for (int i = 0; i < nums1.size(); ++i) {\n        min_heap.emplace(i, 0);\n    }\n\n    while (k-- && !min_heap.empty()) {\n        auto curr = min_heap.top();\n        min_heap.pop();\n        result.push_back({nums1[curr.first], nums2[curr.second]});\n        if (curr.second + 1 < nums2.size()) {\n            min_heap.emplace(curr.first, curr.second + 1);\n        }\n    }\n    return result;\n}", "javascript": "function kSmallestPairs(nums1, nums2, k) {\n    const minHeap = new PriorityQueue(k, (a, b) => a[0] + a[1] - (b[0] + b[1]));\n    const result = [];\n\n    if (nums1.length === 0 || nums2.length === 0 || k === 0) {\n        return result;\n    }\n\n    for (let i = 0; i < nums1.length && i < k; i++) {\n        minHeap.offer([nums1[i], nums2[0], 0]);\n    }\n\n    while (k-- > 0 && !minHeap.isEmpty()) {\n        const curr = minHeap.poll();\n        result.push([curr[0], curr[1]]);\n        if (curr[2] === nums2.length - 1) {\n            continue;\n        }\n        minHeap.offer([curr[0], nums2[curr[2] + 1], curr[2] + 1]);\n    }\n\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/374", "prompt": "We are playing the Guess Game. The game is as follows:\n\nI pick a number from `1` to `n`. You have to guess which number I picked.\n\nEvery time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.\n\nYou call a pre-defined API `int guess(int num)`, which returns three possible results:\n\n*   `-1`: Your guess is higher than the number I picked (i.e. `num > pick`).\n*   `1`: Your guess is lower than the number I picked (i.e. `num < pick`).\n*   `0`: your guess is equal to the number I picked (i.e. `num == pick`).\n\nReturn _the number that I picked_.\n\n**Example 1:**\n\n**Input:** n = 10, pick = 6\n**Output:** 6\n\n**Example 2:**\n\n**Input:** n = 1, pick = 1\n**Output:** 1\n\n**Example 3:**\n\n**Input:** n = 2, pick = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= n <= 231 - 1`\n*   `1 <= pick <= n`", "entry_point": "guess_number_higher_or_lower", "canonical_solutions": {"python": "def guessNumber(n):\n    low, high = 1, n\n    while low <= high:\n        mid = low + (high - low) // 2\n        result = guess(mid)\n        if result == 0:\n            return mid\n        elif result < 0:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return -1", "java": "public int guessNumber(int n) {\n    int low = 1, high = n;\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n        int result = guess(mid);\n        if (result == 0) {\n            return mid;\n        } else if (result < 0) {\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n    return -1;\n}", "cpp": "int guessNumber(int n) {\n    int low = 1, high = n;\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n        int result = guess(mid);\n        if (result == 0) {\n            return mid;\n        } else if (result < 0) {\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n    return -1;\n}", "javascript": "function guessNumber(n) {\n    let low = 1, high = n;\n    while (low <= high) {\n        let mid = Math.floor(low + (high - low) / 2);\n        let result = guess(mid);\n        if (result === 0) {\n            return mid;\n        } else if (result < 0) {\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n    return -1;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/375", "prompt": "We are playing the Guessing Game. The game will work as follows:\n\n1.  I pick a number between `1` and `n`.\n2.  You guess a number.\n3.  If you guess the right number, **you win the game**.\n4.  If you guess the wrong number, then I will tell you whether the number I picked is **higher or lower**, and you will continue guessing.\n5.  Every time you guess a wrong number `x`, you will pay `x` dollars. If you run out of money, **you lose the game**.\n\nGiven a particular `n`, return _the minimum amount of money you need to **guarantee a win regardless of what number I pick**_.\n\n**Example 1:**\n\n**Input:** n = 10\n**Output:** 16\n**Explanation:** The winning strategy is as follows:\n- The range is \\[1,10\\]. Guess 7.\n    - If this is my number, your total is $0. Otherwise, you pay $7.\n    - If my number is higher, the range is \\[8,10\\]. Guess 9.\n        - If this is my number, your total is $7. Otherwise, you pay $9.\n        - If my number is higher, it must be 10. Guess 10. Your total is $7 + $9 = $16.\n        - If my number is lower, it must be 8. Guess 8. Your total is $7 + $9 = $16.\n    - If my number is lower, the range is \\[1,6\\]. Guess 3.\n        - If this is my number, your total is $7. Otherwise, you pay $3.\n        - If my number is higher, the range is \\[4,6\\]. Guess 5.\n            - If this is my number, your total is $7 + $3 = $10. Otherwise, you pay $5.\n            - If my number is higher, it must be 6. Guess 6. Your total is $7 + $3 + $5 = $15.\n            - If my number is lower, it must be 4. Guess 4. Your total is $7 + $3 + $5 = $15.\n        - If my number is lower, the range is \\[1,2\\]. Guess 1.\n            - If this is my number, your total is $7 + $3 = $10. Otherwise, you pay $1.\n            - If my number is higher, it must be 2. Guess 2. Your total is $7 + $3 + $1 = $11.\nThe worst case in all these scenarios is that you pay $16. Hence, you only need $16 to guarantee a win.\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** 0\n**Explanation:** There is only one possible number, so you can guess 1 and not have to pay anything.\n\n**Example 3:**\n\n**Input:** n = 2\n**Output:** 1\n**Explanation:** There are two possible numbers, 1 and 2.\n- Guess 1.\n    - If this is my number, your total is $0. Otherwise, you pay $1.\n    - If my number is higher, it must be 2. Guess 2. Your total is $1.\nThe worst case is that you pay $1.\n\n**Constraints:**\n\n*   `1 <= n <= 200`", "entry_point": "guess_number_higher_or_lower_ii", "canonical_solutions": {"python": "def getMoneyAmount(n: int) -> int:\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, 0, -1):\n        for j in range(i + 1, n + 1):\n            min_cost = float(\"inf\")\n            for k in range(i, j):\n                cost = k + max(dp[i][k - 1], dp[k + 1][j])\n                min_cost = min(min_cost, cost)\n            dp[i][j] = min_cost\n    return dp[1][n]", "java": "public int getMoneyAmount(int n) {\n    int[][] dp = new int[n + 1][n + 1];\n    for (int i = n - 1; i >= 1; i--) {\n        for (int j = i + 1; j <= n; j++) {\n            int min_cost = Integer.MAX_VALUE;\n            for (int k = i; k < j; k++) {\n                int cost = k + Math.max(dp[i][k - 1], dp[k + 1][j]);\n                min_cost = Math.min(min_cost, cost);\n            }\n            dp[i][j] = min_cost;\n        }\n    }\n    return dp[1][n];\n}", "cpp": "int getMoneyAmount(int n) {\n    vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\n    for (int i = n - 1; i >= 1; i--) {\n        for (int j = i + 1; j <= n; j++) {\n            int min_cost = INT_MAX;\n            for (int k = i; k < j; k++) {\n                int cost = k + max(dp[i][k - 1], dp[k + 1][j]);\n                min_cost = min(min_cost, cost);\n            }\n            dp[i][j] = min_cost;\n        }\n    }\n    return dp[1][n];\n}", "javascript": "function getMoneyAmount(n) {\n    const dp = Array.from(Array(n + 1), () => Array(n + 1).fill(0));\n    for (let i = n - 1; i >= 1; i--) {\n        for (let j = i + 1; j <= n; j++) {\n            let min_cost = Infinity;\n            for (let k = i; k < j; k++) {\n                const cost = k + Math.max(dp[i][k - 1], dp[k + 1][j]);\n                min_cost = Math.min(min_cost, cost);\n            }\n            dp[i][j] = min_cost;\n        }\n    }\n    return dp[1][n];\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/376", "prompt": "A **wiggle sequence** is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences.\n\n*   For example, `[1, 7, 4, 9, 2, 5]` is a **wiggle sequence** because the differences `(6, -3, 5, -7, 3)` alternate between positive and negative.\n*   In contrast, `[1, 4, 7, 2, 5]` and `[1, 7, 4, 5, 5]` are not wiggle sequences. The first is not because its first two differences are positive, and the second is not because its last difference is zero.\n\nA **subsequence** is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.\n\nGiven an integer array `nums`, return _the length of the longest **wiggle subsequence** of_ `nums`.\n\n**Example 1:**\n\n**Input:** nums = \\[1,7,4,9,2,5\\]\n**Output:** 6\n**Explanation:** The entire sequence is a wiggle sequence with differences (6, -3, 5, -7, 3).\n\n**Example 2:**\n\n**Input:** nums = \\[1,17,5,10,13,15,10,5,16,8\\]\n**Output:** 7\n**Explanation:** There are several subsequences that achieve this length.\nOne is \\[1, 17, 10, 13, 10, 16, 8\\] with differences (16, -7, 3, -3, 6, -8).\n\n**Example 3:**\n\n**Input:** nums = \\[1,2,3,4,5,6,7,8,9\\]\n**Output:** 2\n\n**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `0 <= nums[i] <= 1000`\n\n**Follow up:** Could you solve this in `O(n)` time?", "entry_point": "wiggle_subsequence", "canonical_solutions": {"python": "def wiggleMaxLength(nums):\n    if len(nums) < 2:\n        return len(nums)\n\n    up, down = 1, 1\n    for i in range(1, len(nums)):\n        if nums[i] > nums[i - 1]:\n            up = down + 1\n        elif nums[i] < nums[i - 1]:\n            down = up + 1\n    return max(up, down)", "java": "public int wiggleMaxLength(int[] nums) {\n    int len = nums.length;\n    if (len < 2) return len;\n\n    int up = 1, down = 1;\n    for (int i = 1; i < len; ++i) {\n        if (nums[i] > nums[i - 1])\n            up = down + 1;\n        else if (nums[i] < nums[i - 1])\n            down = up + 1;\n    }\n    return Math.max(up, down);\n}", "cpp": "int wiggleMaxLength(vector<int>& nums) {\n    int len = nums.size();\n    if (len < 2) return len;\n\n    int up = 1, down = 1;\n    for (int i = 1; i < len; ++i) {\n        if (nums[i] > nums[i - 1])\n            up = down + 1;\n        else if (nums[i] < nums[i - 1])\n            down = up + 1;\n    }\n    return max(up, down);\n}", "javascript": "function wiggleMaxLength(nums) {\n    let len = nums.length;\n    if (len < 2) return len;\n\n    let up = 1, down = 1;\n    for (let i = 1; i < len; ++i) {\n        if (nums[i] > nums[i - 1])\n            up = down + 1;\n        else if (nums[i] < nums[i - 1])\n            down = up + 1;\n    }\n    return Math.max(up, down);\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/377", "prompt": "Given an array of **distinct** integers `nums` and a target integer `target`, return _the number of possible combinations that add up to_ `target`.\n\nThe test cases are generated so that the answer can fit in a **32-bit** integer.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3\\], target = 4\n**Output:** 7\n**Explanation:**\nThe possible combination ways are:\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\nNote that different sequences are counted as different combinations.\n\n**Example 2:**\n\n**Input:** nums = \\[9\\], target = 3\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= nums.length <= 200`\n*   `1 <= nums[i] <= 1000`\n*   All the elements of `nums` are **unique**.\n*   `1 <= target <= 1000`\n\n**Follow up:** What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers?", "entry_point": "combination_sum_iv", "canonical_solutions": {"python": "def combination_sum(nums, target):\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for num in nums:\n        for i in range(num, target + 1):\n            dp[i] += dp[i - num]\n\n    return dp[target]", "java": "public int combinationSum(int[] nums, int target) {\n    int[] dp = new int[target + 1];\n    dp[0] = 1;\n\n    for(int num : nums) {\n        for(int i = num; i <= target; i++) {\n            dp[i] += dp[i - num];\n        }\n    }\n\n    return dp[target];\n}", "cpp": "#include <vector>\nusing namespace std;\n\nint combinationSum(vector<int>& nums, int target) {\n    vector<int> dp(target + 1, 0);\n    dp[0] = 1;\n    \n    for(int num : nums) {\n        for(int i = num; i <= target; i++) {\n            dp[i] += dp[i - num];\n        }\n    }\n    \n    return dp[target];\n}", "javascript": "function combinationSum(nums, target) {\n    let dp = new Array(target + 1).fill(0);\n    dp[0] = 1;\n\n    for(let num of nums) {\n        for(let i = num; i <= target; i++) {\n            dp[i] += dp[i - num];\n        }\n    }\n\n    return dp[target];\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/378", "prompt": "Given an `n x n` `matrix` where each of the rows and columns is sorted in ascending order, return _the_ `kth` _smallest element in the matrix_.\n\nNote that it is the `kth` smallest element **in the sorted order**, not the `kth` **distinct** element.\n\nYou must find a solution with a memory complexity better than `O(n2)`.\n\n**Example 1:**\n\n**Input:** matrix = \\[\\[1,5,9\\],\\[10,11,13\\],\\[12,13,15\\]\\], k = 8\n**Output:** 13\n**Explanation:** The elements in the matrix are \\[1,5,9,10,11,12,13,**13**,15\\], and the 8th smallest number is 13\n\n**Example 2:**\n\n**Input:** matrix = \\[\\[-5\\]\\], k = 1\n**Output:** -5\n\n**Constraints:**\n\n*   `n == matrix.length == matrix[i].length`\n*   `1 <= n <= 300`\n*   `-109 <= matrix[i][j] <= 109`\n*   All the rows and columns of `matrix` are **guaranteed** to be sorted in **non-decreasing order**.\n*   `1 <= k <= n2`\n\n**Follow up:**\n\n*   Could you solve the problem with a constant memory (i.e., `O(1)` memory complexity)?\n*   Could you solve the problem in `O(n)` time complexity? The solution may be too advanced for an interview but you may find reading [this paper](http://www.cse.yorku.ca/~andy/pubs/X+Y.pdf) fun.", "entry_point": "kth_smallest_element_in_a_sorted_matrix", "canonical_solutions": {"python": "import heapq\n\ndef kthSmallest(matrix, k):\n    n = len(matrix)\n    min_heap = []\n\n    for i in range(n):\n        heapq.heappush(min_heap, (matrix[i][0], i, 0))\n\n    while k > 1:\n        val, row, col = heapq.heappop(min_heap)\n\n        if col + 1 < n:\n            heapq.heappush(min_heap, (matrix[row][col + 1], row, col + 1))\n\n        k -= 1\n\n    return min_heap[0][0]", "java": "import java.util.PriorityQueue;\n\npublic int kthSmallest(int[][] matrix, int k) {\n    int n = matrix.length;\n    PriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) -> a[0] - b[0]);\n\n    for (int i = 0; i < n; i++) {\n        minHeap.offer(new int[]{matrix[i][0], i, 0});\n    }\n\n    while (--k > 0) {\n        int[] element = minHeap.poll();\n        int row = element[1];\n        int col = element[2];\n\n        if (col + 1 < n) {\n            minHeap.offer(new int[]{matrix[row][col + 1], row, col + 1});\n        }\n    }\n\n    return minHeap.peek()[0];\n}", "cpp": "#include <queue>\n#include <vector>\n\nint kthSmallest(std::vector<std::vector<int>>& matrix, int k) {\n    int n = matrix.size();\n    std::priority_queue<std::pair<int, std::pair<int, int>>, std::vector<std::pair<int, std::pair<int, int>>>, std::greater<>> min_heap;\n\n    for (int i = 0; i < n; ++i) {\n        min_heap.emplace(matrix[i][0], std::make_pair(i, 0));\n    }\n\n    while (--k) {\n        auto [val, pos] = min_heap.top();\n        min_heap.pop();\n\n        if (++pos.second < n) {\n            min_heap.emplace(matrix[pos.first][pos.second], pos);\n        }\n    }\n\n    return min_heap.top().first;\n}", "javascript": "function kthSmallest(matrix, k) {\n    const n = matrix.length;\n    const minHeap = [];\n\n    for (let i = 0; i < n; i++) {\n        minHeap.push({ value: matrix[i][0], row: i, col: 0 });\n    }\n\n    minHeap.sort((a, b) => a.value - b.value);\n\n    while (--k) {\n        const { value, row, col } = minHeap.shift();\n\n        if (col + 1 < n) {\n            const newVal = { value: matrix[row][col + 1], row: row, col: col + 1 };\n            insertSorted(minHeap, newVal, (a, b) => a.value - b.value);\n        }\n    }\n\n    return minHeap[0].value;\n}\n\nfunction insertSorted(arr, item, comparator) {\n    const insertIndex = arr.findIndex((el) => comparator(el, item) > 0);\n\n    if (insertIndex === -1) {\n        arr.push(item);\n    } else {\n        arr.splice(insertIndex, 0, item);\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/379", "prompt": "Design a phone directory that initially has `maxNumbers` empty slots that can store numbers. The directory should store numbers, check if a certain slot is empty or not, and empty a given slot.\n\nImplement the `PhoneDirectory` class:\n\n*   `PhoneDirectory(int maxNumbers)` Initializes the phone directory with the number of available slots `maxNumbers`.\n*   `int get()` Provides a number that is not assigned to anyone. Returns `-1` if no number is available.\n*   `bool check(int number)` Returns `true` if the slot `number` is available and `false` otherwise.\n*   `void release(int number)` Recycles or releases the slot `number`.\n\n**Example 1:**\n\n**Input**\n\\[ \"PhoneDirectory \",  \"get \",  \"get \",  \"check \",  \"get \",  \"check \",  \"release \",  \"check \"\\]\n\\[\\[3\\], \\[\\], \\[\\], \\[2\\], \\[\\], \\[2\\], \\[2\\], \\[2\\]\\]\n**Output**\n\\[null, 0, 1, true, 2, false, null, true\\]\n\n**Explanation**\nPhoneDirectory phoneDirectory = new PhoneDirectory(3);\nphoneDirectory.get();      // It can return any available phone number. Here we assume it returns 0.\nphoneDirectory.get();      // Assume it returns 1.\nphoneDirectory.check(2);   // The number 2 is available, so return true.\nphoneDirectory.get();      // It returns 2, the only number that is left.\nphoneDirectory.check(2);   // The number 2 is no longer available, so return false.\nphoneDirectory.release(2); // Release number 2 back to the pool.\nphoneDirectory.check(2);   // Number 2 is available again, return true.\n\n**Constraints:**\n\n*   `1 <= maxNumbers <= 104`\n*   `0 <= number < maxNumbers`\n*   At most `2 * 104` calls will be made to `get`, `check`, and `release`.", "entry_point": "design_phone_directory", "canonical_solutions": {"python": "from collections import deque\n\nclass PhoneDirectory:\n    def __init__(self, maxNumbers: int):\n        self.available = [True] * maxNumbers\n        self.released = deque()\n    \n    def get(self) -> int:\n        if self.released:\n            number = self.released.popleft()\n            self.available[number] = False\n            return number\n        for i in range(len(self.available)):\n            if self.available[i]:\n                self.available[i] = False\n                return i\n        return -1\n    \n    def check(self, number: int) -> bool:\n        return self.available[number]\n    \n    def release(self, number: int) -> None:\n        if not self.available[number]:\n            self.available[number] = True\n            self.released.append(number)", "java": "import java.util.*;\n\nclass PhoneDirectory {\n    boolean[] available;\n    Queue<Integer> released;\n\n    public PhoneDirectory(int maxNumbers) {\n        available = new boolean[maxNumbers];\n        Arrays.fill(available, true);\n        released = new LinkedList<>();\n    }\n    \n    public int get() {\n        if (!released.isEmpty()) {\n            int number = released.poll();\n            available[number] = false;\n            return number;\n        }\n        for (int i = 0; i < available.length; i++) {\n            if (available[i]) {\n                available[i] = false;\n                return i;\n            }\n        }\n        return -1;\n    }\n    \n    public boolean check(int number) {\n        return available[number];\n    }\n    \n    public void release(int number) {\n        if (!available[number]) {\n            available[number] = true;\n            released.offer(number);\n        }\n    }\n}", "cpp": "class PhoneDirectory {\n    vector<bool> available;\n    queue<int> released;\npublic:\n    PhoneDirectory(int maxNumbers): available(maxNumbers, true) {}\n    \n    int get() {\n        if(!released.empty()) {\n            int number = released.front();\n            released.pop();\n            available[number] = false;\n            return number;\n        }\n        for(int i = 0; i < available.size(); i++) {\n            if(available[i]) {\n                available[i] = false;\n                return i;\n            }\n        }\n        return -1;\n    }\n    \n    bool check(int number) {\n        return available[number];\n    }\n    \n    void release(int number) {\n        if(!available[number]) {\n            available[number] = true;\n            released.push(number);\n        }\n    }\n};", "javascript": "class PhoneDirectory {\n    constructor(maxNumbers) {\n        this.available = new Array(maxNumbers).fill(true);\n        this.released = [];\n    }\n    \n    get() {\n        if (this.released.length > 0) {\n            let number = this.released.shift();\n            this.available[number] = false;\n            return number;\n        }\n        for (let i = 0; i < this.available.length; i++) {\n            if (this.available[i]) {\n                this.available[i] = false;\n                return i;\n            }\n        }\n        return -1;\n    }\n    \n    check(number) {\n        return this.available[number];\n    }\n    \n    release(number) {\n        if (!this.available[number]) {\n            this.available[number] = true;\n            this.released.push(number);\n        }\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/380", "prompt": "Implement the `RandomizedSet` class:\n\n*   `RandomizedSet()` Initializes the `RandomizedSet` object.\n*   `bool insert(int val)` Inserts an item `val` into the set if not present. Returns `true` if the item was not present, `false` otherwise.\n*   `bool remove(int val)` Removes an item `val` from the set if present. Returns `true` if the item was present, `false` otherwise.\n*   `int getRandom()` Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the **same probability** of being returned.\n\nYou must implement the functions of the class such that each function works in **average** `O(1)` time complexity.\n\n**Example 1:**\n\n**Input**\n\\[ \"RandomizedSet \",  \"insert \",  \"remove \",  \"insert \",  \"getRandom \",  \"remove \",  \"insert \",  \"getRandom \"\\]\n\\[\\[\\], \\[1\\], \\[2\\], \\[2\\], \\[\\], \\[1\\], \\[2\\], \\[\\]\\]\n**Output**\n\\[null, true, false, true, 2, true, false, 2\\]\n\n**Explanation**\nRandomizedSet randomizedSet = new RandomizedSet();\nrandomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.\nrandomizedSet.remove(2); // Returns false as 2 does not exist in the set.\nrandomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains \\[1,2\\].\nrandomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.\nrandomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains \\[2\\].\nrandomizedSet.insert(2); // 2 was already in the set, so return false.\nrandomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.\n\n**Constraints:**\n\n*   `-231 <= val <= 231 - 1`\n*   At most `2 *` `105` calls will be made to `insert`, `remove`, and `getRandom`.\n*   There will be **at least one** element in the data structure when `getRandom` is called.", "entry_point": "insert_delete_getrandom_o1", "canonical_solutions": {"python": "import random\n\nclass RandomizedSet:\n    def __init__(self):\n        self.index_map = {}\n        self.nums = []\n\n    def insert(self, val: int) -> bool:\n        if val in self.index_map:\n            return False\n\n        self.index_map[val] = len(self.nums)\n        self.nums.append(val)\n        return True\n\n    def remove(self, val: int) -> bool:\n        if val not in self.index_map:\n            return False\n\n        last = self.nums[-1]\n        self.index_map[last] = self.index_map[val]\n        self.nums[self.index_map[val]] = last\n\n        self.nums.pop()\n        del self.index_map[val]\n        return True\n\n    def getRandom(self) -> int:\n        return self.nums[random.randint(0, len(self.nums) - 1)]", "java": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Random;\n\npublic class RandomizedSet {\n    private Map<Integer, Integer> indexMap;\n    private List<Integer> nums;\n    private Random rand;\n\n    public RandomizedSet() {\n        indexMap = new HashMap<>();\n        nums = new ArrayList<>();\n        rand = new Random();\n    }\n\n    public boolean insert(int val) {\n        if (indexMap.containsKey(val)) return false;\n\n        indexMap.put(val, nums.size());\n        nums.add(val);\n        return true;\n    }\n\n    public boolean remove(int val) {\n        if (!indexMap.containsKey(val)) return false;\n\n        int last = nums.get(nums.size() - 1);\n        indexMap.put(last, indexMap.get(val));\n        nums.set(indexMap.get(val), last);\n\n        nums.remove(nums.size() - 1);\n        indexMap.remove(val);\n        return true;\n    }\n\n    public int getRandom() {\n        return nums.get(rand.nextInt(nums.size()));\n    }\n}", "cpp": "#include <unordered_map>\n#include <vector>\n#include <random>\n\nclass RandomizedSet {\n    std::unordered_map<int, int> index_map;\n    std::vector<int> nums;\npublic:\n    bool insert(int val) {\n        if (index_map.count(val)) return false;\n\n        index_map[val] = nums.size();\n        nums.push_back(val);\n        return true;\n    }\n\n    bool remove(int val) {\n        if (!index_map.count(val)) return false;\n\n        int last = nums.back();\n        index_map[last] = index_map[val];\n        nums[index_map[val]] = last;\n\n        nums.pop_back();\n        index_map.erase(val);\n        return true;\n    }\n\n    int getRandom() {\n        return nums[rand() % nums.size()];\n    }\n};", "javascript": "class RandomizedSet {\n    constructor() {\n        this.indexMap = new Map();\n        this.nums = [];\n    }\n\n    insert(val) {\n        if (this.indexMap.has(val)) return false;\n\n        this.indexMap.set(val, this.nums.length);\n        this.nums.push(val);\n        return true;\n    }\n\n    remove(val) {\n        if (!this.indexMap.has(val)) return false;\n\n        const last = this.nums[this.nums.length - 1];\n        this.indexMap.set(last, this.indexMap.get(val));\n        this.nums[this.indexMap.get(val)] = last;\n\n        this.nums.pop();\n        this.indexMap.delete(val);\n        return true;\n    }\n\n    getRandom() {\n        return this.nums[Math.floor(Math.random() * this.nums.length)];\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/381", "prompt": "`RandomizedCollection` is a data structure that contains a collection of numbers, possibly duplicates (i.e., a multiset). It should support inserting and removing specific elements and also reporting a random element.\n\nImplement the `RandomizedCollection` class:\n\n*   `RandomizedCollection()` Initializes the empty `RandomizedCollection` object.\n*   `bool insert(int val)` Inserts an item `val` into the multiset, even if the item is already present. Returns `true` if the item is not present, `false` otherwise.\n*   `bool remove(int val)` Removes an item `val` from the multiset if present. Returns `true` if the item is present, `false` otherwise. Note that if `val` has multiple occurrences in the multiset, we only remove one of them.\n*   `int getRandom()` Returns a random element from the current multiset of elements. The probability of each element being returned is **linearly related** to the number of the same values the multiset contains.\n\nYou must implement the functions of the class such that each function works on **average** `O(1)` time complexity.\n\n**Note:** The test cases are generated such that `getRandom` will only be called if there is **at least one** item in the `RandomizedCollection`.\n\n**Example 1:**\n\n**Input**\n\\[ \"RandomizedCollection \",  \"insert \",  \"insert \",  \"insert \",  \"getRandom \",  \"remove \",  \"getRandom \"\\]\n\\[\\[\\], \\[1\\], \\[1\\], \\[2\\], \\[\\], \\[1\\], \\[\\]\\]\n**Output**\n\\[null, true, false, true, 2, true, 1\\]\n\n**Explanation**\nRandomizedCollection randomizedCollection = new RandomizedCollection();\nrandomizedCollection.insert(1);   // return true since the collection does not contain 1.\n                                  // Inserts 1 into the collection.\nrandomizedCollection.insert(1);   // return false since the collection contains 1.\n                                  // Inserts another 1 into the collection. Collection now contains \\[1,1\\].\nrandomizedCollection.insert(2);   // return true since the collection does not contain 2.\n                                  // Inserts 2 into the collection. Collection now contains \\[1,1,2\\].\nrandomizedCollection.getRandom(); // getRandom should:\n                                  // - return 1 with probability 2/3, or\n                                  // - return 2 with probability 1/3.\nrandomizedCollection.remove(1);   // return true since the collection contains 1.\n                                  // Removes 1 from the collection. Collection now contains \\[1,2\\].\nrandomizedCollection.getRandom(); // getRandom should return 1 or 2, both equally likely.\n\n**Constraints:**\n\n*   `-231 <= val <= 231 - 1`\n*   At most `2 * 105` calls **in total** will be made to `insert`, `remove`, and `getRandom`.\n*   There will be **at least one** element in the data structure when `getRandom` is called.", "entry_point": "insert_delete_getrandom_o1_duplicates_allowed", "canonical_solutions": {"python": "import random\nfrom collections import defaultdict\n\nclass RandomizedCollection:\n    def __init__(self):\n        self.indices = defaultdict(set)\n        self.nums = []\n\n    def insert(self, val):\n        self.nums.append(val)\n        self.indices[val].add(len(self.nums) - 1)\n        return len(self.indices[val]) == 1\n\n    def remove(self, val):\n        if not self.indices[val]:\n            return False\n\n        idx = self.indices[val].pop()\n        if idx < len(self.nums) - 1:\n            last = self.nums[-1]\n            self.nums[idx] = last\n            self.indices[last].remove(len(self.nums) - 1)\n            self.indices[last].add(idx)\n        self.nums.pop()\n        return True\n\n    def getRandom(self):\n        return self.nums[random.randint(0, len(self.nums) - 1)]", "java": "import java.util.*;\n\nclass RandomizedCollection {\n    Map<Integer, Set<Integer>> indices;\n    List<Integer> nums;\n\n    public RandomizedCollection() {\n        indices = new HashMap<>();\n        nums = new ArrayList<>();\n    }\n    \n    public boolean insert(int val) {\n        nums.add(val);\n        indices.putIfAbsent(val, new HashSet<>());\n        indices.get(val).add(nums.size() - 1);\n        return indices.get(val).size() == 1;\n    }\n    \n    public boolean remove(int val) {\n        if (!indices.containsKey(val) || indices.get(val).isEmpty()) return false;\n        int idx = indices.get(val).iterator().next();\n        indices.get(val).remove(idx);\n\n        if (idx < nums.size() - 1) {\n            int last = nums.get(nums.size() - 1);\n            nums.set(idx, last);\n            indices.get(last).remove(nums.size() - 1);\n            indices.get(last).add(idx);\n        }\n        nums.remove(nums.size() - 1);\n        return true;\n    }\n    \n    public int getRandom() {\n        int index = (int) (Math.random() * nums.size());\n        return nums.get(index);\n    }\n}", "cpp": "#include <unordered_map>\n#include <vector>\n#include <random>\n\nclass RandomizedCollection {\npublic:\n    unordered_map<int, unordered_set<int>> indices;\n    vector<int> nums;\n    \n    bool insert(int val) {\n        nums.push_back(val);\n        indices[val].insert(nums.size() - 1);\n        return indices[val].size() == 1;\n    }\n    \n    bool remove(int val) {\n        if (!indices[val].size()) return false;\n        int idx = *indices[val].begin();\n        indices[val].erase(idx);\n        if (idx < nums.size() - 1) {\n            int last = nums.back();\n            nums[idx] = last;\n            indices[last].erase(nums.size() - 1);\n            indices[last].insert(idx);\n        }\n        nums.pop_back();\n        return true;\n    }\n    \n    int getRandom() {\n        return nums[rand() % nums.size()];\n    }\n};", "javascript": "class RandomizedCollection {\n    constructor() {\n        this.indices = new Map();\n        this.nums = [];\n    }\n\n    insert(val) {\n        this.nums.push(val);\n        if (!this.indices.has(val)) this.indices.set(val, new Set());\n        this.indices.get(val).add(this.nums.length - 1);\n        return this.indices.get(val).size === 1;\n    }\n\n    remove(val) {\n        if (!this.indices.has(val) || this.indices.get(val).size === 0) return false;\n        const idx = this.indices.get(val).values().next().value;\n        this.indices.get(val).delete(idx);\n\n        if (idx < this.nums.length - 1) {\n            const last = this.nums[this.nums.length - 1];\n            this.nums[idx] = last;\n            this.indices.get(last).delete(this.nums.length - 1);\n            this.indices.get(last).add(idx);\n        }\n        this.nums.pop();\n        return true;\n    }\n\n    getRandom() {\n        const index = Math.floor(Math.random() * this.nums.length);\n        return this.nums[index];\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/382", "prompt": "Given a singly linked list, return a random node's value from the linked list. Each node must have the **same probability** of being chosen.\n\nImplement the `Solution` class:\n\n*   `Solution(ListNode head)` Initializes the object with the head of the singly-linked list `head`.\n*   `int getRandom()` Chooses a node randomly from the list and returns its value. All the nodes of the list should be equally likely to be chosen.\n\n**Example 1:**\n\n**Input**\n\\[ \"Solution \",  \"getRandom \",  \"getRandom \",  \"getRandom \",  \"getRandom \",  \"getRandom \"\\]\n\\[\\[\\[1, 2, 3\\]\\], \\[\\], \\[\\], \\[\\], \\[\\], \\[\\]\\]\n**Output**\n\\[null, 1, 3, 2, 2, 3\\]\n\n**Explanation**\nSolution solution = new Solution(\\[1, 2, 3\\]);\nsolution.getRandom(); // return 1\nsolution.getRandom(); // return 3\nsolution.getRandom(); // return 2\nsolution.getRandom(); // return 2\nsolution.getRandom(); // return 3\n// getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning.\n\n**Constraints:**\n\n*   The number of nodes in the linked list will be in the range `[1, 104]`.\n*   `-104 <= Node.val <= 104`\n*   At most `104` calls will be made to `getRandom`.\n\n**Follow up:**\n\n*   What if the linked list is extremely large and its length is unknown to you?\n*   Could you solve this efficiently without using extra space?", "entry_point": "linked_list_random_node", "canonical_solutions": {"python": "import random\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def __init__(self, head: ListNode):\n        self.head = head\n\n    def getRandom(self) -> int:\n        current, result = self.head, 0\n        for i, node in enumerate(self.iterate_nodes(current)):\n            if random.randint(0, i) == 0:\n                result = node.val\n        return result\n\n    def iterate_nodes(self, current):\n        while current:\n            yield current\n            current = current.next", "java": "import java.util.Random;\n\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) { val = x; }\n}\n\npublic class Solution {\n    ListNode head;\n    Random random;\n\n    public Solution(ListNode head) {\n        this.head = head;\n        random = new Random();\n    }\n\n    public int getRandom() {\n        ListNode current = head;\n        int result = current.val, i;\n        for (i = 1; current != null; i++) {\n            if (random.nextInt(i) == 0) {\n                result = current.val;\n            }\n            current = current.next;\n        }\n        return result;\n    }\n}", "cpp": "#include <cstdlib>\n#include <ctime>\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nclass Solution {\npublic:\n    ListNode* head;\n\n    Solution(ListNode* _head) {\n        head = _head;\n        srand(time(0));\n    }\n\n    int getRandom() {\n        int result;\n        ListNode* current = head;\n        for (int i = 1; current; ++i) {\n            if (rand() % i == 0) {\n                result = current->val;\n            }\n            current = current->next;\n        }\n        return result;\n    }\n};", "javascript": "class ListNode {\n    constructor(val, next = null) {\n        this.val = val;\n        this.next = next;\n    }\n}\n\nclass Solution {\n    constructor(head) {\n        this.head = head;\n    }\n\n    getRandom() {\n        let current = this.head;\n        let result = current.val;\n        for (let i = 1; current !== null; i++) {\n            if (Math.floor(Math.random() * i) === 0) {\n                result = current.val;\n            }\n            current = current.next;\n        }\n        return result;\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/383", "prompt": "Given two strings `ransomNote` and `magazine`, return `true` _if_ `ransomNote` _can be constructed by using the letters from_ `magazine` _and_ `false` _otherwise_.\n\nEach letter in `magazine` can only be used once in `ransomNote`.\n\n**Example 1:**\n\n**Input:** ransomNote = \"a\", magazine = \"b\"\n**Output:** false\n\n**Example 2:**\n\n**Input:** ransomNote = \"aa\", magazine = \"ab\"\n**Output:** false\n\n**Example 3:**\n\n**Input:** ransomNote = \"aa\", magazine = \"aab\"\n**Output:** true\n\n**Constraints:**\n\n*   `1 <= ransomNote.length, magazine.length <= 105`\n*   `ransomNote` and `magazine` consist of lowercase English letters.", "entry_point": "ransom_note", "canonical_solutions": {"python": "def can_construct(ransom_note, magazine):\n    letter_count = {}\n    \n    for c in magazine:\n        letter_count[c] = letter_count.get(c, 0) + 1\n        \n    for c in ransom_note:\n        if c not in letter_count or letter_count[c] == 0:\n            return False\n        letter_count[c] -= 1\n        \n    return True", "java": "import java.util.HashMap;\n\npublic boolean canConstruct(String ransomNote, String magazine) {\n    HashMap<Character, Integer> letterCount = new HashMap<>();\n    \n    for (char c : magazine.toCharArray()) {\n        letterCount.put(c, letterCount.getOrDefault(c, 0) + 1);\n    }\n    \n    for (char c : ransomNote.toCharArray()) {\n        if (!letterCount.containsKey(c) || letterCount.get(c) == 0) {\n            return false;\n        }\n        letterCount.put(c, letterCount.get(c) - 1);\n    }\n\n    return true;\n}", "cpp": "#include <string>\n#include <unordered_map>\n\nbool canConstruct(std::string ransomNote, std::string magazine) {\n    std::unordered_map<char, int> letterCount;\n    for (char c : magazine) {\n        letterCount[c]++;\n    }\n    \n    for (char c : ransomNote) {\n        if (letterCount[c] == 0) {\n            return false;\n        }\n        letterCount[c]--;\n    }\n\n    return true;\n}", "javascript": "function canConstruct(ransomNote, magazine) {\n    let letterCount = new Map();\n    \n    for (const c of magazine) {\n        letterCount.set(c, (letterCount.get(c) || 0) + 1);\n    }\n    \n    for (const c of ransomNote) {\n        if (!letterCount.has(c) || letterCount.get(c) === 0) {\n            return false;\n        }\n        letterCount.set(c, letterCount.get(c) - 1);\n    }\n\n    return true;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/384", "prompt": "Given an integer array `nums`, design an algorithm to randomly shuffle the array. All permutations of the array should be **equally likely** as a result of the shuffling.\n\nImplement the `Solution` class:\n\n*   `Solution(int[] nums)` Initializes the object with the integer array `nums`.\n*   `int[] reset()` Resets the array to its original configuration and returns it.\n*   `int[] shuffle()` Returns a random shuffling of the array.\n\n**Example 1:**\n\n**Input**\n\\[ \"Solution \",  \"shuffle \",  \"reset \",  \"shuffle \"\\]\n\\[\\[\\[1, 2, 3\\]\\], \\[\\], \\[\\], \\[\\]\\]\n**Output**\n\\[null, \\[3, 1, 2\\], \\[1, 2, 3\\], \\[1, 3, 2\\]\\]\n\n**Explanation**\nSolution solution = new Solution(\\[1, 2, 3\\]);\nsolution.shuffle();    // Shuffle the array \\[1,2,3\\] and return its result.\n                       // Any permutation of \\[1,2,3\\] must be equally likely to be returned.\n                       // Example: return \\[3, 1, 2\\]\nsolution.reset();      // Resets the array back to its original configuration \\[1,2,3\\]. Return \\[1, 2, 3\\]\nsolution.shuffle();    // Returns the random shuffling of array \\[1,2,3\\]. Example: return \\[1, 3, 2\\]\n\n**Constraints:**\n\n*   `1 <= nums.length <= 50`\n*   `-106 <= nums[i] <= 106`\n*   All the elements of `nums` are **unique**.\n*   At most `104` calls **in total** will be made to `reset` and `shuffle`.", "entry_point": "shuffle_an_array", "canonical_solutions": {"python": "import random\n\nclass Solution:\n    def __init__(self, nums):\n        self.original = nums\n\n    def reset(self):\n        return self.original\n\n    def shuffle(self):\n        shuffled = self.original[:]\n        for i in range(len(shuffled) - 1, 0, -1):\n            j = random.randint(0, i)\n            shuffled[i], shuffled[j] = shuffled[j], shuffled[i]\n        return shuffled", "java": "import java.util.Random;\nimport java.util.Arrays;\n\nclass Solution {\n    private int[] original;\n    private Random rand;\n    \n    public Solution(int[] nums) {\n        original = nums;\n        rand = new Random();\n    }\n    \n    public int[] reset() {\n        return original;\n    }\n    \n    public int[] shuffle() {\n        int[] shuffled = Arrays.copyOf(original, original.length);\n        for (int i = shuffled.length - 1; i > 0; i--) {\n            int j = rand.nextInt(i + 1);\n            int temp = shuffled[i];\n            shuffled[i] = shuffled[j];\n            shuffled[j] = temp;\n        }\n        return shuffled;\n    }\n}", "cpp": "#include <algorithm>\n#include <vector>\n#include <ctime>\n\nclass Solution {\npublic:\n    Solution(std::vector<int>& nums) {\n        original = nums;\n        srand(time(0));\n    }\n    \n    std::vector<int> reset() {\n        return original;\n    }\n    \n    std::vector<int> shuffle() {\n        std::vector<int> shuffled = original;\n        for (int i = shuffled.size() - 1; i > 0; i--) {\n            int j = rand() % (i + 1);\n            std::swap(shuffled[i], shuffled[j]);\n        }\n        return shuffled;\n    }\nprivate:\n    std::vector<int> original;\n};", "javascript": "class Solution {\n    constructor(nums) {\n        this.original = nums;\n    }\n    \n    reset() {\n        return this.original;\n    }\n    \n    shuffle() {\n        let shuffled = [...this.original];\n        for (let i = shuffled.length - 1; i > 0; i--) {\n            let j = Math.floor(Math.random() * (i + 1));\n            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n        }\n        return shuffled;\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/385", "prompt": "Given a string s represents the serialization of a nested list, implement a parser to deserialize it and return _the deserialized_ `NestedInteger`.\n\nEach element is either an integer or a list whose elements may also be integers or other lists.\n\n**Example 1:**\n\n**Input:** s =  \"324 \"\n**Output:** 324\n**Explanation:** You should return a NestedInteger object which contains a single integer 324.\n\n**Example 2:**\n\n**Input:** s =  \"\\[123,\\[456,\\[789\\]\\]\\] \"\n**Output:** \\[123,\\[456,\\[789\\]\\]\\]\n**Explanation:** Return a NestedInteger object containing a nested list with 2 elements:\n1. An integer containing value 123.\n2. A nested list containing two elements:\n    i.  An integer containing value 456.\n    ii. A nested list with one element:\n         a. An integer containing value 789\n\n**Constraints:**\n\n*   `1 <= s.length <= 5 * 104`\n*   `s` consists of digits, square brackets `\"[] \"`, negative sign `'-'`, and commas `','`.\n*   `s` is the serialization of valid `NestedInteger`.\n*   All the values in the input are in the range `[-106, 106]`.", "entry_point": "mini_parser", "canonical_solutions": {"python": "class NestedInteger:\n    def __init__(self, value=None):\n        pass\n\n    def add(self, ni):\n        pass\n\ndef deserialize(s: str) -> NestedInteger:\n    if s[0] != '[':\n        return NestedInteger(int(s))\n\n    stack = []\n    curr, start = None, 0\n\n    for i, c in enumerate(s):\n        if c == '[':\n            if curr:\n                stack.append(curr)\n            curr = NestedInteger()\n            start = i + 1\n        elif c == ',' or c == ']':\n            if i > start:\n                curr.add(NestedInteger(int(s[start:i])))\n            start = i + 1\n\n            if c == ']' and stack:\n                popped = stack.pop()\n                popped.add(curr)\n                curr = popped\n\n    return curr", "java": "import java.util.*;\n\nclass NestedInteger {\n    NestedInteger() {}\n    NestedInteger(int value) {}\n    void add(NestedInteger ni) {}\n}\n\npublic class Solution {\n    public NestedInteger deserialize(String s) {\n        if (s.charAt(0) != '[') {\n            return new NestedInteger(Integer.parseInt(s));\n        }\n\n        Stack<NestedInteger> stack = new Stack<>();\n        NestedInteger curr = null;\n        int start = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c == '[') {\n                if (curr != null) {\n                    stack.push(curr);\n                }\n                curr = new NestedInteger();\n                start = i + 1;\n            } else if (c == ',' || c == ']') {\n                if (i > start) {\n                    curr.add(new NestedInteger(Integer.parseInt(s.substring(start, i))));\n                }\n                start = i + 1;\n\n                if (c == ']' && !stack.isEmpty()) {\n                    NestedInteger pop = stack.pop();\n                    pop.add(curr);\n                    curr = pop;\n                }\n            }\n        }\n        return curr;\n    }\n}", "cpp": "#include <string>\n#include <sstream>\nusing namespace std;\n\nclass NestedInteger {\npublic:\n    NestedInteger() {}\n    NestedInteger(int value) {}\n    void add(const NestedInteger& ni) {}\n};\n\nNestedInteger deserialize(string s);\n\nNestedInteger deserializeHelper(istringstream& ss) {\n    int num;\n    if (ss >> num)\n        return NestedInteger(num);\n\n    ss.clear();\n    ss.get();\n    NestedInteger list;\n    while (ss.peek() != ']') {\n        list.add(deserializeHelper(ss));\n        if (ss.peek() == ',')\n            ss.get();\n    }\n    ss.get();\n    return list;\n}\n\nNestedInteger deserialize(string s) {\n    istringstream ss(s);\n    return deserializeHelper(ss);\n}", "javascript": "class NestedInteger {\n    constructor(value) {\n        this.value = value;\n        this.list = [];\n    }\n\n    add(ni) {\n        this.list.push(ni);\n    }\n}\n\nfunction deserialize(s) {\n    if (s[0] !== '[') {\n        return new NestedInteger(parseInt(s));\n    }\n\n    let stack = [];\n    let curr = null;\n    let start = 0;\n\n    for (let i = 0; i < s.length; i++) {\n        let c = s[i];\n        if (c === '[') {\n            if (curr !== null) {\n                stack.push(curr);\n            }\n            curr = new NestedInteger();\n            start = i + 1;\n        } else if (c === ',' || c === ']') {\n            if (i > start) {\n                curr.add(new NestedInteger(parseInt(s.substring(start, i))));\n            }\n            start = i + 1;\n\n            if (c === ']' && stack.length > 0) {\n                let popped = stack.pop();\n                popped.add(curr);\n                curr = popped;\n            }\n        }\n    }\n    return curr;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/386", "prompt": "Given an integer `n`, return all the numbers in the range `[1, n]` sorted in lexicographical order.\n\nYou must write an algorithm that runs in `O(n)` time and uses `O(1)` extra space.\n\n**Example 1:**\n\n**Input:** n = 13\n**Output:** \\[1,10,11,12,13,2,3,4,5,6,7,8,9\\]\n\n**Example 2:**\n\n**Input:** n = 2\n**Output:** \\[1,2\\]\n\n**Constraints:**\n\n*   `1 <= n <= 5 * 104`", "entry_point": "lexicographical_numbers", "canonical_solutions": {"python": "def lexicographical_order_helper(current, n, result):\n    if current > n:\n        return\n\n    result.append(current)\n    for i in range(10):\n        lexicographical_order_helper(current * 10 + i, n, result)\n\ndef lexical_order(n):\n    result = []\n    for i in range(1, 10):\n        lexicographical_order_helper(i, n, result)\n    return result", "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic static void lexicographicalOrderHelper(int current, int n, List<Integer> result) {\n    if (current > n) return;\n\n    result.add(current);\n    for (int i = 0; i <= 9; ++i) {\n        lexicographicalOrderHelper(current * 10 + i, n, result);\n    }\n}\n\npublic static List<Integer> lexicalOrder(int n) {\n    List<Integer> result = new ArrayList<>();\n    for (int i = 1; i <= 9; ++i) {\n        lexicographicalOrderHelper(i, n, result);\n    }\n    return result;\n}", "cpp": "#include <vector>\n#include <string>\n\nvoid lexicographicalOrderHelper(int current, int n, std::vector<int>& result) {\n    if (current > n) return;\n\n    result.push_back(current);\n    for (int i = 0; i <= 9; ++i) {\n        lexicographicalOrderHelper(current * 10 + i, n, result);\n    }\n}\n\nstd::vector<int> lexicalOrder(int n) {\n    std::vector<int> result;\n    for (int i = 1; i <= 9; ++i) {\n        lexicographicalOrderHelper(i, n, result);\n    }\n    return result;\n}", "javascript": "function lexicographicalOrderHelper(current, n, result) {\n    if (current > n) return;\n\n    result.push(current);\n    for (let i = 0; i <= 9; ++i) {\n        lexicographicalOrderHelper(current * 10 + i, n, result);\n    }\n}\n\nfunction lexicalOrder(n) {\n    let result = [];\n    for (let i = 1; i <= 9; ++i) {\n        lexicographicalOrderHelper(i, n, result);\n    }\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/387", "prompt": "Given a string `s`, _find the first non-repeating character in it and return its index_. If it does not exist, return `-1`.\n\n**Example 1:**\n\n**Input:** s = \"leetcode\"\n**Output:** 0\n\n**Example 2:**\n\n**Input:** s = \"loveleetcode\"\n**Output:** 2\n\n**Example 3:**\n\n**Input:** s = \"aabb\"\n**Output:** -1\n\n**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists of only lowercase English letters.", "entry_point": "first_unique_character_in_a_string", "canonical_solutions": {"python": "def firstUniqChar(s):\n    char_count = {}\n    for c in s:\n        char_count[c] = char_count.get(c, 0) + 1\n    for i in range(len(s)):\n        if char_count[s[i]] == 1:\n            return i\n    return -1", "java": "public int firstUniqChar(String s) {\n    HashMap<Character, Integer> charCount = new HashMap<>();\n    for (char c : s.toCharArray())\n        charCount.put(c, charCount.getOrDefault(c, 0) + 1);\n    for (int i = 0; i < s.length(); i++)\n        if (charCount.get(s.charAt(i)) == 1)\n            return i;\n    return -1;\n}", "cpp": "int firstUniqChar(std::string s) {\n    std::unordered_map<char, int> charCount;\n    for (char c : s)\n        charCount[c]++;\n    for (int i = 0; i < s.length(); i++)\n        if (charCount[s[i]] == 1)\n            return i;\n    return -1;\n}", "javascript": "function firstUniqChar(s) {\n    let charCount = {};\n    for (let c of s)\n        charCount[c] = (charCount[c] || 0) + 1;\n    for (let i = 0; i < s.length; i++)\n        if (charCount[s[i]] === 1)\n            return i;\n    return -1;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/388", "prompt": "Suppose we have a file system that stores both files and directories. An example of one system is represented in the following picture:\n\nHere, we have `dir` as the only directory in the root. `dir` contains two subdirectories, `subdir1` and `subdir2`. `subdir1` contains a file `file1.ext` and subdirectory `subsubdir1`. `subdir2` contains a subdirectory `subsubdir2`, which contains a file `file2.ext`.\n\nIn text form, it looks like this (with \u27f6 representing the tab character):\n\ndir\n\u27f6 subdir1\n\u27f6 \u27f6 file1.ext\n\u27f6 \u27f6 subsubdir1\n\u27f6 subdir2\n\u27f6 \u27f6 subsubdir2\n\u27f6 \u27f6 \u27f6 file2.ext\n\nIf we were to write this representation in code, it will look like this: `\"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext \"`. Note that the `'\\n'` and `'\\t'` are the new-line and tab characters.\n\nEvery file and directory has a unique **absolute path** in the file system, which is the order of directories that must be opened to reach the file/directory itself, all concatenated by `'/'s`. Using the above example, the **absolute path** to `file2.ext` is `\"dir/subdir2/subsubdir2/file2.ext \"`. Each directory name consists of letters, digits, and/or spaces. Each file name is of the form `name.extension`, where `name` and `extension` consist of letters, digits, and/or spaces.\n\nGiven a string `input` representing the file system in the explained format, return _the length of the **longest absolute path** to a **file** in the abstracted file system_. If there is no file in the system, return `0`.\n\n**Note** that the testcases are generated such that the file system is valid and no file or directory name has length 0.\n\n**Example 1:**\n\n**Input:** input =  \"dir\\\\n\\\\tsubdir1\\\\n\\\\tsubdir2\\\\n\\\\t\\\\tfile.ext \"\n**Output:** 20\n**Explanation:** We have only one file, and the absolute path is  \"dir/subdir2/file.ext \" of length 20.\n\n**Example 2:**\n\n**Input:** input =  \"dir\\\\n\\\\tsubdir1\\\\n\\\\t\\\\tfile1.ext\\\\n\\\\t\\\\tsubsubdir1\\\\n\\\\tsubdir2\\\\n\\\\t\\\\tsubsubdir2\\\\n\\\\t\\\\t\\\\tfile2.ext \"\n**Output:** 32\n**Explanation:** We have two files:\n \"dir/subdir1/file1.ext \" of length 21\n \"dir/subdir2/subsubdir2/file2.ext \" of length 32.\nWe return 32 since it is the longest absolute path to a file.\n\n**Example 3:**\n\n**Input:** input =  \"a \"\n**Output:** 0\n**Explanation:** We do not have any files, just a single directory named  \"a \".\n\n**Constraints:**\n\n*   `1 <= input.length <= 104`\n*   `input` may contain lowercase or uppercase English letters, a new line character `'\\n'`, a tab character `'\\t'`, a dot `'.'`, a space `' '`, and digits.\n*   All file and directory names have **positive** length.", "entry_point": "longest_absolute_file_path", "canonical_solutions": {"python": "def length_longest_path(input: str) -> int:\n    dir_length_stack = []\n    max_file_length = 0\n    lines = input.split('\\n')\n\n    for line in lines:\n        level = line.count('\\t')\n        line = line.lstrip('\\t')\n\n        while len(dir_length_stack) > level:\n            dir_length_stack.pop()\n\n        if dir_length_stack:\n            length = dir_length_stack[-1] + len(line) + 1\n        else:\n            length = len(line)\n        dir_length_stack.append(length)\n\n        if '.' in line:\n            max_file_length = max(max_file_length, length)\n            \n    return max_file_length", "java": "import java.util.Stack;\n\npublic int lengthLongestPath(String input) {\n    Stack<Integer> dirLengthStack = new Stack<>();\n    String[] lines = input.split(\"\\n\");\n    int maxFileLength = 0;\n\n    for (String line : lines) {\n        int level = line.lastIndexOf('\\t') + 1;\n        line = line.substring(level);\n\n        while (dirLengthStack.size() > level) {\n            dirLengthStack.pop();\n        }\n\n        int length = (dirLengthStack.isEmpty()) ? line.length() : dirLengthStack.peek() + line.length() + 1;\n        dirLengthStack.push(length);\n\n        if (line.contains(\".\")) {\n            maxFileLength = Math.max(maxFileLength, length);\n        }\n    }\n\n    return maxFileLength;\n}", "cpp": "#include <string>\n#include <sstream>\n#include <vector>\n#include <algorithm>\n\nint lengthLongestPath(std::string input) {\n    std::istringstream ss(input);\n    std::vector<int> dir_length_stack;\n    std::string line;\n    int max_file_length = 0;\n\n    while (std::getline(ss, line, '\\n')) {\n        int level = 0;\n        while (line.find('\\t') != std::string::npos) {\n            line.erase(0, 1);\n            level++;\n        }\n\n        while (dir_length_stack.size() > level)\n            dir_length_stack.pop_back();\n\n        int length;\n        if (dir_length_stack.empty()) {\n            length = line.length();\n        } else {\n            length = dir_length_stack.back() + line.length() + 1;\n        }\n        dir_length_stack.push_back(length);\n\n        if (line.find('.') != std::string::npos) {\n            max_file_length = std::max(max_file_length, length);\n        }\n    }\n\n    return max_file_length;\n}", "javascript": "function lengthLongestPath(input) {\n    const dirLengthStack = [];\n    const lines = input.split('\\n');\n    let maxFileLength = 0;\n\n    for (const line of lines) {\n        const level = (line.match(/\\t/g) || []).length;\n        const lineText = line.replace(/\\t/g, '');\n\n        while (dirLengthStack.length > level)\n            dirLengthStack.pop();\n\n        const length = (dirLengthStack.length === 0) ? lineText.length : (dirLengthStack[dirLengthStack.length - 1] + lineText.length + 1);\n        dirLengthStack.push(length);\n\n        if (lineText.includes('.')) {\n            maxFileLength = Math.max(maxFileLength, length);\n        }\n    }\n\n    return maxFileLength;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/389", "prompt": "You are given two strings `s` and `t`.\n\nString `t` is generated by random shuffling string `s` and then add one more letter at a random position.\n\nReturn the letter that was added to `t`.\n\n**Example 1:**\n\n**Input:** s =  \"abcd \", t =  \"abcde \"\n**Output:**  \"e \"\n**Explanation:** 'e' is the letter that was added.\n\n**Example 2:**\n\n**Input:** s =  \" \", t =  \"y \"\n**Output:**  \"y \"\n\n**Constraints:**\n\n*   `0 <= s.length <= 1000`\n*   `t.length == s.length + 1`\n*   `s` and `t` consist of lowercase English letters.", "entry_point": "find_the_difference", "canonical_solutions": {"python": "def findTheDifference(s: str, t: str) -> str:\n    return chr(sum(ord(c) for c in t) - sum(ord(c) for c in s))", "java": "public char findTheDifference(String s, String t) {\n    int sum_s = 0, sum_t = 0;\n    for(char c : s.toCharArray()) sum_s += c;\n    for(char c : t.toCharArray()) sum_t += c;\n    return (char)(sum_t - sum_s);\n}", "cpp": "char findTheDifference(std::string s, std::string t) {\n    int sum_s = 0, sum_t = 0;\n    for(char c : s) sum_s += c;\n    for(char c : t) sum_t += c;\n    return sum_t - sum_s;\n}", "javascript": "function findTheDifference(s, t) {\n    let sum_s = 0, sum_t = 0;\n    for(let c of s) sum_s += c.charCodeAt(0);\n    for(let c of t) sum_t += c.charCodeAt(0);\n    return String.fromCharCode(sum_t - sum_s);\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/390", "prompt": "You have a list `arr` of all integers in the range `[1, n]` sorted in a strictly increasing order. Apply the following algorithm on `arr`:\n\n*   Starting from left to right, remove the first number and every other number afterward until you reach the end of the list.\n*   Repeat the previous step again, but this time from right to left, remove the rightmost number and every other number from the remaining numbers.\n*   Keep repeating the steps again, alternating left to right and right to left, until a single number remains.\n\nGiven the integer `n`, return _the last number that remains in_ `arr`.\n\n**Example 1:**\n\n**Input:** n = 9\n**Output:** 6\n**Explanation:**\narr = \\[1, 2, 3, 4, 5, 6, 7, 8, 9\\]\narr = \\[2, 4, 6, 8\\]\narr = \\[2, 6\\]\narr = \\[6\\]\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= n <= 109`", "entry_point": "elimination_game", "canonical_solutions": {"python": "def last_remaining(n: int) -> int:\n    direction = True\n    head = 1\n    remaining = n\n    step = 1\n\n    while remaining > 1:\n        if direction or remaining % 2 == 1:\n            head += step\n        remaining //= 2\n        step *= 2\n        direction = not direction\n\n    return head", "java": "public int lastRemaining(int n) {\n    boolean direction = true;\n    int head = 1, remaining = n, step = 1;\n\n    while (remaining > 1) {\n        if (direction || remaining % 2 == 1) {\n            head += step;\n        }\n        remaining /= 2;\n        step *= 2;\n        direction = !direction;\n    }\n\n    return head;\n}", "cpp": "int lastRemaining(int n) {\n    bool direction = true;\n    int head = 1, remaining = n, step = 1;\n\n    while (remaining > 1) {\n        if (direction || remaining % 2 == 1) {\n            head += step;\n        }\n        remaining /= 2;\n        step *= 2;\n        direction = !direction;\n    }\n\n    return head;\n}", "javascript": "function lastRemaining(n) {\n    let direction = true;\n    let head = 1, remaining = n, step = 1;\n\n    while (remaining > 1) {\n        if (direction || remaining % 2 === 1) {\n            head += step;\n        }\n        remaining = Math.floor(remaining / 2);\n        step *= 2;\n        direction = !direction;\n    }\n\n    return head;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/391", "prompt": "Given an array `rectangles` where `rectangles[i] = [xi, yi, ai, bi]` represents an axis-aligned rectangle. The bottom-left point of the rectangle is `(xi, yi)` and the top-right point of it is `(ai, bi)`.\n\nReturn `true` _if all the rectangles together form an exact cover of a rectangular region_.\n\n**Example 1:**\n\n**Input:** rectangles = \\[\\[1,1,3,3\\],\\[3,1,4,2\\],\\[3,2,4,4\\],\\[1,3,2,4\\],\\[2,3,3,4\\]\\]\n**Output:** true\n**Explanation:** All 5 rectangles together form an exact cover of a rectangular region.\n\n**Example 2:**\n\n**Input:** rectangles = \\[\\[1,1,2,3\\],\\[1,3,2,4\\],\\[3,1,4,2\\],\\[3,2,4,4\\]\\]\n**Output:** false\n**Explanation:** Because there is a gap between the two rectangular regions.\n\n**Example 3:**\n\n**Input:** rectangles = \\[\\[1,1,3,3\\],\\[3,1,4,2\\],\\[1,3,2,4\\],\\[2,2,4,4\\]\\]\n**Output:** false\n**Explanation:** Because two of the rectangles overlap with each other.\n\n**Constraints:**\n\n*   `1 <= rectangles.length <= 2 * 104`\n*   `rectangles[i].length == 4`\n*   `-105 <= xi, yi, ai, bi <= 105`", "entry_point": "perfect_rectangle", "canonical_solutions": {"python": "def isRectangleCover(rectangles):\n    area = 0\n    points = set()\n    lx, ly, rx, ry = float('inf'), float('inf'), float('-inf'), float('-inf')\n\n    for rect in rectangles:\n        lx, ly = min(lx, rect[0]), min(ly, rect[1])\n        rx, ry = max(rx, rect[2]), max(ry, rect[3])\n\n        area += (rect[2] - rect[0]) * (rect[3] - rect[1])\n\n        p1, p2, p3, p4 = (rect[0], rect[1]), (rect[0], rect[3]), (rect[2], rect[1]), (rect[2], rect[3])\n\n        points ^= {p1, p2, p3, p4}\n\n    return len(points) == 4 and area == (rx - lx) * (ry - ly) and (lx, ly) in points and \\\n           (lx, ry) in points and (rx, ly) in points and (rx, ry) in points", "java": "import java.util.HashSet;\nimport java.util.Set;\nimport java.awt.Point;\n\npublic class RectCover {\n    public boolean isRectangleCover(int[][] rectangles) {\n        int area = 0;\n        Set<Point> points = new HashSet<>();\n        int lx = Integer.MAX_VALUE, ly = Integer.MAX_VALUE, rx = Integer.MIN_VALUE, ry = Integer.MIN_VALUE;\n\n        for (int[] rect : rectangles) {\n            lx = Math.min(lx, rect[0]);\n            ly = Math.min(ly, rect[1]);\n            rx = Math.max(rx, rect[2]);\n            ry = Math.max(ry, rect[3]);\n\n            area += (rect[2] - rect[0]) * (rect[3] - rect[1]);\n\n            Point p1 = new Point(rect[0], rect[1]);\n            Point p2 = new Point(rect[0], rect[3]);\n            Point p3 = new Point(rect[2], rect[1]);\n            Point p4 = new Point(rect[2], rect[3]);\n\n            if (!points.remove(p1)) points.add(p1);\n            if (!points.remove(p2)) points.add(p2);\n            if (!points.remove(p3)) points.add(p3);\n            if (!points.remove(p4)) points.add(p4);\n        }\n\n        if (points.contains(new Point(lx, ly)) && points.contains(new Point(lx, ry)) &&\n            points.contains(new Point(rx, ly)) && points.contains(new Point(rx, ry)) &&\n            points.size() == 4)\n            return area == (rx - lx) * (ry - ly);\n\n        return false;\n    }\n}", "cpp": "#include <vector>\n#include <set>\n\nbool isRectangleCover(std::vector<std::vector<int>>& rectangles) {\n    int area = 0;\n    std::set<std::pair<int, int>> points;\n    int lx = INT_MAX, ly = INT_MAX, rx = INT_MIN, ry = INT_MIN;\n\n    for (auto& rect : rectangles) {\n        lx = std::min(lx, rect[0]);\n        ly = std::min(ly, rect[1]);\n        rx = std::max(rx, rect[2]);\n        ry = std::max(ry, rect[3]);\n\n        area += (rect[2] - rect[0]) * (rect[3] - rect[1]);\n\n        std::pair<int, int> p1(rect[0], rect[1]);\n        std::pair<int, int> p2(rect[0], rect[3]);\n        std::pair<int, int> p3(rect[2], rect[1]);\n        std::pair<int, int> p4(rect[2], rect[3]);\n\n        if (!points.erase(p1)) points.insert(p1);\n        if (!points.erase(p2)) points.insert(p2);\n        if (!points.erase(p3)) points.insert(p3);\n        if (!points.erase(p4)) points.insert(p4);\n    }\n\n    if (points.count({lx, ly}) && points.count({lx, ry}) &&\n        points.count({rx, ly}) && points.count({rx, ry}) &&\n        points.size() == 4)\n        return area == (rx - lx) * (ry - ly);\n\n    return false;\n}", "javascript": "function isRectangleCover(rectangles) {\n    let area = 0;\n    let points = new Set();\n    let lx = Infinity, ly = Infinity, rx = -Infinity, ry = -Infinity;\n\n    for (let rect of rectangles) {\n        lx = Math.min(lx, rect[0]);\n        ly = Math.min(ly, rect[1]);\n        rx = Math.max(rx, rect[2]);\n        ry = Math.max(ry, rect[3]);\n\n        area += (rect[2] - rect[0]) * (rect[3] - rect[1]);\n\n        let p1 = rect[0] + \",\" + rect[1];\n        let p2 = rect[0] + \",\" + rect[3];\n        let p3 = rect[2] + \",\" + rect[1];\n        let p4 = rect[2] + \",\" + rect[3];\n\n        if (points.has(p1)) points.delete(p1);\n        else points.add(p1);\n        if (points.has(p2)) points.delete(p2);\n        else points.add(p2);\n        if (points.has(p3)) points.delete(p3);\n        else points.add(p3);\n        if (points.has(p4)) points.delete(p4);\n        else points.add(p4);\n    }\n\n    return points.size === 4 &&\n           points.has(lx + \",\" + ly) && points.has(lx + \",\" + ry) &&\n           points.has(rx + \",\" + ly) && points.has(rx + \",\" + ry) &&\n           area === (rx - lx) * (ry - ly);\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/392", "prompt": "Given two strings `s` and `t`, return `true` _if_ `s` _is a **subsequence** of_ `t`_, or_ `false` _otherwise_.\n\nA **subsequence** of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., `\"ace \"` is a subsequence of `\"abcde \"` while `\"aec \"` is not).\n\n**Example 1:**\n\n**Input:** s = \"abc\", t = \"ahbgdc\"\n**Output:** true\n\n**Example 2:**\n\n**Input:** s = \"axc\", t = \"ahbgdc\"\n**Output:** false\n\n**Constraints:**\n\n*   `0 <= s.length <= 100`\n*   `0 <= t.length <= 104`\n*   `s` and `t` consist only of lowercase English letters.\n\n**Follow up:** Suppose there are lots of incoming `s`, say `s1, s2, ..., sk` where `k >= 109`, and you want to check one by one to see if `t` has its subsequence. In this scenario, how would you change your code?", "entry_point": "is_subsequence", "canonical_solutions": {"python": "def is_subsequence(s, t):\n    si, ti = 0, 0\n\n    while si < len(s) and ti < len(t):\n        if s[si] == t[ti]:\n            si += 1\n        ti += 1\n\n    return si == len(s)", "java": "boolean isSubsequence(String s, String t) {\n    int si = 0, ti = 0;\n\n    while (si < s.length() && ti < t.length()) {\n        if (s.charAt(si) == t.charAt(ti))\n            si++;\n        ti++;\n    }\n\n    return si == s.length();\n}", "cpp": "bool isSubsequence(std::string s, std::string t) {\n    int si = 0, ti = 0;\n\n    while (si < s.size() && ti < t.size()) {\n        if (s[si] == t[ti])\n            si++;\n        ti++;\n    }\n\n    return si == s.size();\n}", "javascript": "function isSubsequence(s, t) {\n    let si = 0, ti = 0;\n\n    while (si < s.length && ti < t.length) {\n        if (s[si] === t[ti])\n            si++;\n        ti++;\n    }\n\n    return si === s.length;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/393", "prompt": "Given an integer array `data` representing the data, return whether it is a valid **UTF-8** encoding (i.e. it translates to a sequence of valid UTF-8 encoded characters).\n\nA character in **UTF8** can be from **1 to 4 bytes** long, subjected to the following rules:\n\n1.  For a **1-byte** character, the first bit is a `0`, followed by its Unicode code.\n2.  For an **n-bytes** character, the first `n` bits are all one's, the `n + 1` bit is `0`, followed by `n - 1` bytes with the most significant `2` bits being `10`.\n\nThis is how the UTF-8 encoding would work:\n\n     Number of Bytes   |        UTF-8 Octet Sequence\n                       |              (binary)\n   --------------------+-----------------------------------------\n            1          |   0xxxxxxx\n            2          |   110xxxxx 10xxxxxx\n            3          |   1110xxxx 10xxxxxx 10xxxxxx\n            4          |   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n\n`x` denotes a bit in the binary form of a byte that may be either `0` or `1`.\n\n**Note:** The input is an array of integers. Only the **least significant 8 bits** of each integer is used to store the data. This means each integer represents only 1 byte of data.\n\n**Example 1:**\n\n**Input:** data = \\[197,130,1\\]\n**Output:** true\n**Explanation:** data represents the octet sequence: 11000101 10000010 00000001.\nIt is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.\n\n**Example 2:**\n\n**Input:** data = \\[235,140,4\\]\n**Output:** false\n**Explanation:** data represented the octet sequence: 11101011 10001100 00000100.\nThe first 3 bits are all one's and the 4th bit is 0 means it is a 3-bytes character.\nThe next byte is a continuation byte which starts with 10 and that's correct.\nBut the second continuation byte does not start with 10, so it is invalid.\n\n**Constraints:**\n\n*   `1 <= data.length <= 2 * 104`\n*   `0 <= data[i] <= 255`", "entry_point": "utf_8_validation", "canonical_solutions": {"python": "def validUtf8(data):\n    count = 0\n    for byte in data:\n        if count == 0:\n            if byte >> 5 == 0b110:\n                count = 1\n            elif byte >> 4 == 0b1110:\n                count = 2\n            elif byte >> 3 == 0b11110:\n                count = 3\n            elif byte >> 7:\n                return False\n        else:\n            if byte >> 6 != 0b10:\n                return False\n            count -= 1\n    return count == 0", "java": "public boolean validUtf8(int[] data) {\n    int count = 0;\n    for (int byteValue : data) {\n        if (count == 0) {\n            if ((byteValue >> 5) == 0b110) count = 1;\n            else if ((byteValue >> 4) == 0b1110) count = 2;\n            else if ((byteValue >> 3) == 0b11110) count = 3;\n            else if ((byteValue >> 7) == 1) return false;\n        } else {\n            if ((byteValue >> 6) != 0b10) return false;\n            count--;\n        }\n    }\n    return count == 0;\n}", "cpp": "bool validUtf8(vector<int>& data) {\n    int count = 0;\n    for (int byte : data) {\n        if (count == 0) { \n            if ((byte >> 5) == 0b110) count = 1;\n            else if ((byte >> 4) == 0b1110) count = 2;\n            else if ((byte >> 3) == 0b11110) count = 3;\n            else if ((byte >> 7)) return false; \n        } else { \n            if ((byte >> 6) != 0b10) return false;\n            count--;\n        }\n    }\n    return count == 0;\n}", "javascript": "function validUtf8(data) {\n    let count = 0;\n    for (let byte of data) {\n        if (count === 0) {\n            if (byte >> 5 === 0b110) count = 1;\n            else if (byte >> 4 === 0b1110) count = 2;\n            else if (byte >> 3 === 0b11110) count = 3;\n            else if (byte >> 7) return false;\n        } else {\n            if (byte >> 6 !== 0b10) return false;\n            count--;\n        }\n    }\n    return count === 0;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/394", "prompt": "Given an encoded string, return its decoded string.\n\nThe encoding rule is: `k[encoded_string]`, where the `encoded_string` inside the square brackets is being repeated exactly `k` times. Note that `k` is guaranteed to be a positive integer.\n\nYou may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, `k`. For example, there will not be input like `3a` or `2[4]`.\n\nThe test cases are generated so that the length of the output will never exceed `105`.\n\n**Example 1:**\n\n**Input:** s =  \"3\\[a\\]2\\[bc\\] \"\n**Output:**  \"aaabcbc \"\n\n**Example 2:**\n\n**Input:** s =  \"3\\[a2\\[c\\]\\] \"\n**Output:**  \"accaccacc \"\n\n**Example 3:**\n\n**Input:** s =  \"2\\[abc\\]3\\[cd\\]ef \"\n**Output:**  \"abcabccdcdcdef \"\n\n**Constraints:**\n\n*   `1 <= s.length <= 30`\n*   `s` consists of lowercase English letters, digits, and square brackets `'[]'`.\n*   `s` is guaranteed to be **a valid** input.\n*   All the integers in `s` are in the range `[1, 300]`.", "entry_point": "decode_string", "canonical_solutions": {"python": "def decodeString(s):\n    counts = []\n    results = []\n    current = \"\"\n    ptr = 0\n\n    while ptr < len(s):\n        if s[ptr].isdigit():\n            count = 0\n            while s[ptr].isdigit():\n                count = count * 10 + int(s[ptr])\n                ptr += 1\n            counts.append(count)\n        elif s[ptr] == '[':\n            results.append(current)\n            current = \"\"\n            ptr += 1\n        elif s[ptr] == ']':\n            prev = results.pop()\n            count = counts.pop()\n            current = prev + current * count\n            ptr += 1\n        else:\n            current += s[ptr]\n            ptr += 1\n\n    return current", "java": "import java.util.*;\n\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Integer> counts = new Stack<>();\n        Stack<String> results = new Stack<>();\n        String current = \"\";\n        int ptr = 0;\n\n        while (ptr < s.length()) {\n            if (Character.isDigit(s.charAt(ptr))) {\n                int count = 0;\n                while (Character.isDigit(s.charAt(ptr))) {\n                    count = count * 10 + (s.charAt(ptr) - '0');\n                    ptr++;\n                }\n                counts.push(count);\n            } else if (s.charAt(ptr) == '[') {\n                results.push(current);\n                current = \"\";\n                ptr++;\n            } else if (s.charAt(ptr) == ']') {\n                String prev = results.pop();\n                int count = counts.pop();\n                for (int i = 0; i < count; i++) {\n                    prev += current;\n                }\n                current = prev;\n                ptr++;\n            } else {\n                current += s.charAt(ptr);\n                ptr++;\n            }\n        }\n\n        return current;\n    }\n}", "cpp": "#include <string>\n#include <stack>\n\nstd::string decodeString(const std::string &s) {\n    std::stack<int> counts;\n    std::stack<std::string> results;\n    std::string current;\n    int ptr = 0;\n\n    while (ptr < s.size()) {\n        if (isdigit(s[ptr])) {\n            int count = 0;\n            while (isdigit(s[ptr])) {\n                count = count * 10 + (s[ptr] - '0');\n                ptr++;\n            }\n            counts.push(count);\n        } else if (s[ptr] == '[') {\n            results.push(current);\n            current = \"\";\n            ptr++;\n        } else if (s[ptr] == ']') {\n            std::string prev = results.top();\n            results.pop();\n            int count = counts.top();\n            counts.pop();\n            for (int i = 0; i < count; i++) {\n                prev += current;\n            }\n            current = prev;\n            ptr++;\n        } else {\n            current += s[ptr];\n            ptr++;\n        }\n    }\n\n    return current;\n}", "javascript": "function decodeString(s) {\n    const counts = [];\n    const results = [];\n    let current = \"\";\n    let ptr = 0;\n\n    while (ptr < s.length) {\n        if (s[ptr].match(/\\d/)) {\n            let count = 0;\n            while (s[ptr].match(/\\d/)) {\n                count = count * 10 + parseInt(s[ptr]);\n                ptr++;\n            }\n            counts.push(count);\n        } else if (s[ptr] === '[') {\n            results.push(current);\n            current = \"\";\n            ptr++;\n        } else if (s[ptr] === ']') {\n            const prev = results.pop();\n            const count = counts.pop();\n            for (let i = 0; i < count; i++) {\n                prev += current;\n            }\n            current = prev;\n            ptr++;\n        } else {\n            current += s[ptr];\n            ptr++;\n        }\n    }\n\n    return current;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/395", "prompt": "Given a string `s` and an integer `k`, return _the length of the longest substring of_ `s` _such that the frequency of each character in this substring is greater than or equal to_ `k`.\n\n**Example 1:**\n\n**Input:** s =  \"aaabb \", k = 3\n**Output:** 3\n**Explanation:** The longest substring is  \"aaa \", as 'a' is repeated 3 times.\n\n**Example 2:**\n\n**Input:** s =  \"ababbc \", k = 2\n**Output:** 5\n**Explanation:** The longest substring is  \"ababb \", as 'a' is repeated 2 times and 'b' is repeated 3 times.\n\n**Constraints:**\n\n*   `1 <= s.length <= 104`\n*   `s` consists of only lowercase English letters.\n*   `1 <= k <= 105`", "entry_point": "longest_substring_with_at_least_k_repeating_characters", "canonical_solutions": {"python": "def longestSubstring(s: str, k: int) -> int:\n    if not s or k <= 0:\n        return 0\n\n    char_count = {}\n    for ch in s:\n        char_count[ch] = char_count.get(ch, 0) + 1\n\n    for char, count in char_count.items():\n        if count < k:\n            return max(longestSubstring(sub_s, k) for sub_s in s.split(char))\n    return len(s)", "java": "import java.util.*;\n\npublic int longestSubstring(String s, int k) {\n    if (s == null || s.length() == 0 || k <= 0) return 0;\n\n    Map<Character, Integer> charCount = new HashMap<>();\n    for (char ch : s.toCharArray())\n        charCount.put(ch, charCount.getOrDefault(ch, 0) + 1);\n\n    for (Map.Entry<Character, Integer> entry : charCount.entrySet()) {\n        if (entry.getValue() < k) {\n            int res = 0;\n            for (String str : s.split(Character.toString(entry.getKey())))\n                res = Math.max(res, longestSubstring(str, k));\n            return res;\n        }\n    }\n    return s.length();\n}", "cpp": "#include <string>\n#include <unordered_map>\n#include <algorithm>\n\nint longestSubstring(const std::string& s, int k) {\n    if (s.empty() || k <= 0) return 0;\n\n    std::unordered_map<char, int> char_count;\n    for (char ch : s)\n        char_count[ch]++;\n\n    for (const auto& item : char_count) {\n        if (item.second < k) {\n            int res = 0;\n            for (const std::string& str : split(s, item.first))\n                res = std::max(res, longestSubstring(str, k));\n            return res;\n        }\n    }\n    return s.length();\n}\n\nstd::vector<std::string> split(const std::string& s, char delimiter) {\n    std::vector<std::string> subs;\n    size_t start = 0;\n    size_t end = s.find(delimiter);\n    while (end != std::string::npos) {\n        subs.push_back(s.substr(start, end - start));\n        start = end + 1;\n        end = s.find(delimiter, start);\n    }\n    subs.push_back(s.substr(start));\n    return subs;\n}", "javascript": "function longestSubstring(s, k) {\n    if (!s || k <= 0) return 0;\n\n    const charCount = {};\n    for (const ch of s)\n        charCount[ch] = (charCount[ch] || 0) + 1;\n\n    for (const key in charCount) {\n        if (charCount[key] < k) {\n            let res = 0;\n            for (const subStr of s.split(key))\n                res = Math.max(res, longestSubstring(subStr, k));\n            return res;\n        }\n    }\n    return s.length;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/396", "prompt": "You are given an integer array `nums` of length `n`.\n\nAssume `arrk` to be an array obtained by rotating `nums` by `k` positions clock-wise. We define the **rotation function** `F` on `nums` as follow:\n\n*   `F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1].`\n\nReturn _the maximum value of_ `F(0), F(1), ..., F(n-1)`.\n\nThe test cases are generated so that the answer fits in a **32-bit** integer.\n\n**Example 1:**\n\n**Input:** nums = \\[4,3,2,6\\]\n**Output:** 26\n**Explanation:**\nF(0) = (0 \\* 4) + (1 \\* 3) + (2 \\* 2) + (3 \\* 6) = 0 + 3 + 4 + 18 = 25\nF(1) = (0 \\* 6) + (1 \\* 4) + (2 \\* 3) + (3 \\* 2) = 0 + 4 + 6 + 6 = 16\nF(2) = (0 \\* 2) + (1 \\* 6) + (2 \\* 4) + (3 \\* 3) = 0 + 6 + 8 + 9 = 23\nF(3) = (0 \\* 3) + (1 \\* 2) + (2 \\* 6) + (3 \\* 4) = 0 + 2 + 12 + 12 = 26\nSo the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26.\n\n**Example 2:**\n\n**Input:** nums = \\[100\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 105`\n*   `-100 <= nums[i] <= 100`", "entry_point": "rotate_function", "canonical_solutions": {"python": "def maxRotateFunction(nums):\n    n = len(nums)\n    total_sum = sum(nums)\n    f = sum(i * num for i, num in enumerate(nums))\n\n    max_f = f\n    for i in range(1, n):\n        f += total_sum - n * nums[-i]\n        max_f = max(max_f, f)\n\n    return max_f", "java": "public int maxRotateFunction(int[] nums) {\n    int n = nums.length;\n    int total_sum = 0;\n    int f = 0;\n\n    for (int i = 0; i < n; i++) {\n        total_sum += nums[i];\n        f += i * nums[i];\n    }\n\n    int max_f = f;\n    for (int i = 1; i < n; i++) {\n        f += total_sum - (n * nums[n - i]);\n        max_f = Math.max(max_f, f);\n    }\n\n    return max_f;\n}", "cpp": "int maxRotateFunction(vector<int>& nums) {\n    int n = nums.size();\n    int total_sum = 0;\n    int f = 0;\n\n    for (int i = 0; i < n; i++) {\n        total_sum += nums[i];\n        f += i * nums[i];\n    }\n\n    int max_f = f;\n    for (int i = 1; i < n; i++) {\n        f += total_sum - n * nums[n - i];\n        max_f = max(max_f, f);\n    }\n\n    return max_f;\n}", "javascript": "function maxRotateFunction(nums) {\n    let n = nums.length;\n    let total_sum = nums.reduce((a, b) => a + b, 0);\n    let f = nums.reduce((acc, val, i) => acc + i * val, 0);\n\n    let max_f = f;\n    for (let i = 1; i < n; i++) {\n        f += total_sum - n * nums[n - i];\n        max_f = Math.max(max_f, f);\n    }\n\n    return max_f;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/397", "prompt": "Given a positive integer `n`, you can apply one of the following operations:\n\n1.  If `n` is even, replace `n` with `n / 2`.\n2.  If `n` is odd, replace `n` with either `n + 1` or `n - 1`.\n\nReturn _the minimum number of operations needed for_ `n` _to become_ `1`.\n\n**Example 1:**\n\n**Input:** n = 8\n**Output:** 3\n**Explanation:** 8 -> 4 -> 2 -> 1\n\n**Example 2:**\n\n**Input:** n = 7\n**Output:** 4\n**Explanation:** 7 -> 8 -> 4 -> 2 -> 1\nor 7 -> 6 -> 3 -> 2 -> 1\n\n**Example 3:**\n\n**Input:** n = 4\n**Output:** 2\n\n**Constraints:**\n\n*   `1 <= n <= 231 - 1`", "entry_point": "integer_replacement", "canonical_solutions": {"python": "def min_operations(n):\n    steps = 0\n    while n > 1:\n        n = n // 2 if n % 2 == 0 else n - 1\n        steps += 1\n    return steps", "java": "int minOperations(int n) {\n    int steps = 0;\n    while(n > 1) {\n        n = (n % 2 == 0) ? n / 2 : n - 1;\n        steps++;\n    }\n    return steps;\n}", "cpp": "int minOperations(int n) {\n    int steps = 0;\n    while(n > 1) {\n        n = (n % 2 == 0) ? n / 2 : n - 1;\n        steps++;\n    }\n    return steps;\n}", "javascript": "function minOperations(n) {\n    let steps = 0;\n    while(n > 1) {\n        n = (n % 2 === 0) ? n / 2 : n - 1;\n        steps++;\n    }\n    return steps;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/398", "prompt": "Given an integer array `nums` with possible **duplicates**, randomly output the index of a given `target` number. You can assume that the given target number must exist in the array.\n\nImplement the `Solution` class:\n\n*   `Solution(int[] nums)` Initializes the object with the array `nums`.\n*   `int pick(int target)` Picks a random index `i` from `nums` where `nums[i] == target`. If there are multiple valid i's, then each index should have an equal probability of returning.\n\n**Example 1:**\n\n**Input**\n\\[ \"Solution \",  \"pick \",  \"pick \",  \"pick \"\\]\n\\[\\[\\[1, 2, 3, 3, 3\\]\\], \\[3\\], \\[1\\], \\[3\\]\\]\n**Output**\n\\[null, 4, 0, 2\\]\n\n**Explanation**\nSolution solution = new Solution(\\[1, 2, 3, 3, 3\\]);\nsolution.pick(3); // It should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.\nsolution.pick(1); // It should return 0. Since in the array only nums\\[0\\] is equal to 1.\nsolution.pick(3); // It should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 2 * 104`\n*   `-231 <= nums[i] <= 231 - 1`\n*   `target` is an integer from `nums`.\n*   At most `104` calls will be made to `pick`.", "entry_point": "random_pick_index", "canonical_solutions": {"python": "import random\n\nclass Solution:\n\n    def __init__(self, nums):\n        self.nums = nums\n\n    def pick(self, target):\n        count, res = 0, 0\n        for i, num in enumerate(self.nums):\n            if num == target:\n                count += 1\n                if random.randint(0, count - 1) == 0:\n                    res = i\n        return res", "java": "import java.util.Random;\n\nclass Solution {\n    int[] nums;\n    Random rand;\n    \n    public Solution(int[] nums) {\n        this.nums = nums;\n        this.rand = new Random();\n    }\n    \n    public int pick(int target) {\n        int count = 0, res = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == target) {\n                count++;\n                if (rand.nextInt(count) == 0) {\n                    res = i;\n                }\n            }\n        }\n        return res;\n    }\n}", "cpp": "#include <vector>\n#include <cstdlib>\n\nclass Solution {\npublic:\n    std::vector<int> nums;\n    \n    Solution(std::vector<int>& nums) {\n        this->nums = nums;\n    }\n    \n    int pick(int target) {\n        int count = 0, res = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] == target) {\n                count++;\n                if (std::rand() % count == 0) {\n                    res = i;\n                }\n            }\n        }\n        return res;\n    }\n};", "javascript": "class Solution {\n    constructor(nums) {\n        this.nums = nums;\n    }\n    \n    pick(target) {\n        let count = 0, res = 0;\n        for (let i = 0; i < this.nums.length; i++) {\n            if (this.nums[i] === target) {\n                count++;\n                if (Math.floor(Math.random() * count) === 0) {\n                    res = i;\n                }\n            }\n        }\n        return res;\n    }\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/399", "prompt": "You are given an array of variable pairs `equations` and an array of real numbers `values`, where `equations[i] = [Ai, Bi]` and `values[i]` represent the equation `Ai / Bi = values[i]`. Each `Ai` or `Bi` is a string that represents a single variable.\n\nYou are also given some `queries`, where `queries[j] = [Cj, Dj]` represents the `jth` query where you must find the answer for `Cj / Dj = ?`.\n\nReturn _the answers to all queries_. If a single answer cannot be determined, return `-1.0`.\n\n**Note:** The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.\n\n**Example 1:**\n\n**Input:** equations = \\[\\[ \"a \", \"b \"\\],\\[ \"b \", \"c \"\\]\\], values = \\[2.0,3.0\\], queries = \\[\\[ \"a \", \"c \"\\],\\[ \"b \", \"a \"\\],\\[ \"a \", \"e \"\\],\\[ \"a \", \"a \"\\],\\[ \"x \", \"x \"\\]\\]\n**Output:** \\[6.00000,0.50000,-1.00000,1.00000,-1.00000\\]\n**Explanation:** \nGiven: _a / b = 2.0_, _b / c = 3.0_\nqueries are: _a / c = ?_, _b / a = ?_, _a / e = ?_, _a / a = ?_, _x / x = ?_\nreturn: \\[6.0, 0.5, -1.0, 1.0, -1.0 \\]\n\n**Example 2:**\n\n**Input:** equations = \\[\\[ \"a \", \"b \"\\],\\[ \"b \", \"c \"\\],\\[ \"bc \", \"cd \"\\]\\], values = \\[1.5,2.5,5.0\\], queries = \\[\\[ \"a \", \"c \"\\],\\[ \"c \", \"b \"\\],\\[ \"bc \", \"cd \"\\],\\[ \"cd \", \"bc \"\\]\\]\n**Output:** \\[3.75000,0.40000,5.00000,0.20000\\]\n\n**Example 3:**\n\n**Input:** equations = \\[\\[ \"a \", \"b \"\\]\\], values = \\[0.5\\], queries = \\[\\[ \"a \", \"b \"\\],\\[ \"b \", \"a \"\\],\\[ \"a \", \"c \"\\],\\[ \"x \", \"y \"\\]\\]\n**Output:** \\[0.50000,2.00000,-1.00000,-1.00000\\]\n\n**Constraints:**\n\n*   `1 <= equations.length <= 20`\n*   `equations[i].length == 2`\n*   `1 <= Ai.length, Bi.length <= 5`\n*   `values.length == equations.length`\n*   `0.0 < values[i] <= 20.0`\n*   `1 <= queries.length <= 20`\n*   `queries[i].length == 2`\n*   `1 <= Cj.length, Dj.length <= 5`\n*   `Ai, Bi, Cj, Dj` consist of lower case English letters and digits.", "entry_point": "evaluate_division", "canonical_solutions": {"python": "from collections import defaultdict\n\ndef dfs(s1, s2, graph):\n    if s1 not in graph or s2 not in graph:\n        return -1.0\n    if s1 == s2:\n        return 1.0\n    \n    for neighbor, weight in graph[s1]:\n        if neighbor not in visited:\n            visited.add(neighbor)\n            temp = dfs(neighbor, s2, graph)\n            if temp > 0:\n                return weight * temp\n    return -1.0\n\ndef calcEquation(equations, values, queries):\n    graph = defaultdict(list)\n    for (s1, s2), value in zip(equations, values):\n        graph[s1].append((s2, value))\n        graph[s2].append((s1, 1 / value))\n    \n    ans = []\n    for s1, s2 in queries:\n        visited = set()\n        ans.append(dfs(s1, s2, graph))\n    return ans", "java": "import java.util.*;\n\npublic class Solution {     \n    public double dfs(String s1, String s2, Map<String, List<Pair<String, Double>>> graph) {\n        if (!graph.containsKey(s1) || !graph.containsKey(s2)) return -1.0;\n        if (s1.equals(s2)) return 1.0;\n      \n        for (Pair<String, Double> p : graph.get(s1)) {\n            double temp = dfs(p.getKey(), s2, graph);\n            if (temp > 0) return p.getValue() * temp;\n        }\n        return -1.0;\n    }\n\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\n        Map<String, List<Pair<String, Double>>> graph = new HashMap<>();\n        for (int i = 0; i < equations.size(); i++) {\n            String s1 = equations.get(i).get(0);\n            String s2 = equations.get(i).get(1);\n          \n            if (!graph.containsKey(s1)) graph.put(s1, new ArrayList<>());\n            if (!graph.containsKey(s2)) graph.put(s2, new ArrayList<>());\n\n            graph.get(s1).add(new Pair<>(s2, values[i]));\n            graph.get(s2).add(new Pair<>(s1, 1 / values[i]));\n        }\n\n        double[] ans = new double[queries.size()];\n        for (int i = 0; i < queries.size(); i++) {\n            ans[i] = dfs(queries.get(i).get(0), queries.get(i).get(1), graph);\n        }\n        return ans;\n    }\n}", "cpp": "#include <vector>\n#include <unordered_map>\n#include <string>\n\nusing namespace std;\n  \ndouble dfs(const string& s1, const string& s2, unordered_map<string, vector<pair<string, double>>>& graph) {\n    if (!graph.count(s1) || !graph.count(s2)) return -1.0;\n    if (s1 == s2) return 1.0;\n  \n    for (auto& p : graph[s1]) {\n        double temp = dfs(p.first, s2, graph);\n        if (temp > 0) return p.second * temp;\n    }\n    return -1.0;\n}\n  \nvector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\n    unordered_map<string, vector<pair<string, double>>> graph;\n    for (int i = 0; i < equations.size(); i++) {\n        graph[equations[i][0]].push_back({equations[i][1], values[i]});\n        graph[equations[i][1]].push_back({equations[i][0], 1 / values[i]});\n    }\n  \n    vector<double> ans;\n    for (const auto& q : queries) {\n        ans.push_back(dfs(q[0], q[1], graph));\n    }\n    return ans;\n}", "javascript": "function dfs(s1, s2, graph) {\n  if (!graph[s1] || !graph[s2]) return -1.0;\n  if (s1 === s2) return 1.0;\n\n  for (const [neighbor, weight] of graph[s1]) {\n    if (!visited.has(neighbor)) {\n      visited.add(neighbor);\n      const temp = dfs(neighbor, s2, graph);\n      if (temp > 0) return weight * temp;\n    }\n  }\n  return -1.0;\n}\n\nfunction calcEquation(equations, values, queries) {\n  const graph = {};\n  for (let i = 0; i < equations.length; i++) {\n    const [s1, s2] = equations[i];\n    const value = values[i];\n\n    if (!graph[s1]) graph[s1] = [];\n    if (!graph[s2]) graph[s2] = [];\n    graph[s1].push([s2, value]);\n    graph[s2].push([s1, 1 / value]);\n  }\n\n  const ans = [];\n  for (const [s1, s2] of queries) {\n    const visited = new Set();\n    ans.push(dfs(s1, s2, graph));\n  }\n  return ans;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/400", "prompt": "Given an integer `n`, return the `nth` digit of the infinite integer sequence `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...]`.\n\n**Example 1:**\n\n**Input:** n = 3\n**Output:** 3\n\n**Example 2:**\n\n**Input:** n = 11\n**Output:** 0\n**Explanation:** The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.\n\n**Constraints:**\n\n*   `1 <= n <= 231 - 1`", "entry_point": "nth_digit", "canonical_solutions": {"python": "def findNthDigit(n):\n    size = 1\n    length = 9\n    start = 1\n\n    while n > length * size:\n        n -= length * size\n        size += 1\n        length *= 10\n        start *= 10\n\n    start += (n - 1) // size\n    s = str(start)\n    return int(s[(n - 1) % size])", "java": "public int findNthDigit(int n) {\n    int size = 1;\n    long length = 9;\n    int start = 1;\n\n    while (n > length * size) {\n        n -= length * size;\n        size++;\n        length *= 10;\n        start *= 10;\n    }\n\n    start += (n - 1) / size;\n    String s = Integer.toString(start);\n    return Character.getNumericValue(s.charAt((n - 1) % size));\n}", "cpp": "int findNthDigit(int n) {\n    int size = 1;\n    long length = 9;\n    int start = 1;\n\n    while (n > length * size) {\n        n -= length * size;\n        size++;\n        length *= 10;\n        start *= 10;\n    }\n\n    start += (n - 1) / size;\n    string s = to_string(start);\n    return s[(n - 1) % size] - '0';\n}", "javascript": "function findNthDigit(n) {\n    let size = 1;\n    let length = 9;\n    let start = 1;\n\n    while (n > length * size) {\n        n -= length * size;\n        size++;\n        length *= 10;\n        start *= 10;\n    }\n\n    start += Math.floor((n - 1) / size);\n    const s = start.toString();\n    return parseInt(s.charAt((n - 1) % size));\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/401", "prompt": "A binary watch has 4 LEDs on the top to represent the hours (0-11), and 6 LEDs on the bottom to represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right.\n\n*   For example, the below binary watch reads `\"4:51 \"`.\n\nGiven an integer `turnedOn` which represents the number of LEDs that are currently on (ignoring the PM), return _all possible times the watch could represent_. You may return the answer in **any order**.\n\nThe hour must not contain a leading zero.\n\n*   For example, `\"01:00 \"` is not valid. It should be `\"1:00 \"`.\n\nThe minute must be consist of two digits and may contain a leading zero.\n\n*   For example, `\"10:2 \"` is not valid. It should be `\"10:02 \"`.\n\n**Example 1:**\n\n**Input:** turnedOn = 1\n**Output:** \\[\"0:01\",\"0:02\",\"0:04\",\"0:08\",\"0:16\",\"0:32\",\"1:00\",\"2:00\",\"4:00\",\"8:00\"\\]\n\n**Example 2:**\n\n**Input:** turnedOn = 9\n**Output:** \\[\\]\n\n**Constraints:**\n\n*   `0 <= turnedOn <= 10`", "entry_point": "binary_watch", "canonical_solutions": {"python": "def readBinaryWatch(turnedOn: int):\n    def count_bits(n):\n        return bin(n).count('1')\n\n    times = []\n    for h in range(12):\n        for m in range(60):\n            if count_bits(h) + count_bits(m) == turnedOn:\n                times.append(f\"{h}:{m:02d}\")\n    return times", "java": "import java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> readBinaryWatch(int turnedOn) {\n    List<String> times = new ArrayList<>();\n    for (int h = 0; h < 12; h++) {\n        for (int m = 0; m < 60; m++) {\n            if (Integer.bitCount(h) + Integer.bitCount(m) == turnedOn) {\n                times.add(String.format(\"%d:%02d\", h, m));\n            }\n        }\n    }\n    return times;\n}", "cpp": "#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> readBinaryWatch(int turnedOn) {\n    vector<string> times;\n    for (int h = 0; h < 12; h++) {\n        for (int m = 0; m < 60; m++) {\n            if (__builtin_popcount(h) + __builtin_popcount(m) == turnedOn) {\n                times.push_back(to_string(h) + (m < 10 ? \":0\" : \":\") + to_string(m));\n            }\n        }\n    }\n    return times;\n}", "javascript": "function readBinaryWatch(turnedOn) {\n    function countBits(n) {\n        return n.toString(2).split('1').length - 1;\n    }\n\n    const times = [];\n    for (let h = 0; h < 12; h++) {\n        for (let m = 0; m < 60; m++) {\n            if (countBits(h) + countBits(m) === turnedOn) {\n                times.push(`${h}:${m.toString().padStart(2, '0')}`);\n            }\n        }\n    }\n    return times;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/402", "prompt": "Given string num representing a non-negative integer `num`, and an integer `k`, return _the smallest possible integer after removing_ `k` _digits from_ `num`.\n\n**Example 1:**\n\n**Input:** num =  \"1432219 \", k = 3\n**Output:**  \"1219 \"\n**Explanation:** Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.\n\n**Example 2:**\n\n**Input:** num =  \"10200 \", k = 1\n**Output:**  \"200 \"\n**Explanation:** Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.\n\n**Example 3:**\n\n**Input:** num =  \"10 \", k = 2\n**Output:**  \"0 \"\n**Explanation:** Remove all the digits from the number and it is left with nothing which is 0.\n\n**Constraints:**\n\n*   `1 <= k <= num.length <= 105`\n*   `num` consists of only digits.\n*   `num` does not have any leading zeros except for the zero itself.", "entry_point": "remove_k_digits", "canonical_solutions": {"python": "def remove_k_digits(num, k):\n    stack = []\n    for c in num:\n        while k > 0 and stack and stack[-1] > c:\n            stack.pop()\n            k -= 1\n        stack.append(c)\n    while k > 0:\n        stack.pop()\n        k -= 1\n    return ''.join(stack).lstrip('0') or '0'", "java": "public String removeKDigits(String num, int k) {\n    StringBuilder result = new StringBuilder();\n    for (char c : num.toCharArray()) {\n        while (k > 0 && result.length() > 0 && result.charAt(result.length() - 1) > c) {\n            result.setLength(result.length() - 1);\n            k--;\n        }\n        result.append(c);\n    }\n    result.setLength(result.length() - k);\n    while (result.length() > 0 && result.charAt(0) == '0') {\n        result.deleteCharAt(0);\n    }\n    return result.length() == 0 ? \"0\" : result.toString();\n}", "cpp": "#include <string>\nusing namespace std;\n\nstring removeKDigits(string num, int k) {\n    string result = \"\";\n    for (char c : num) {\n        while (k > 0 && !result.empty() && result.back() > c) {\n            result.pop_back();\n            k--;\n        }\n        result.push_back(c);\n    }\n    result.resize(result.length() - k);\n    while (!result.empty() && result[0] == '0') {\n        result.erase(result.begin());\n    }\n    return result.empty() ? \"0\" : result;\n}", "javascript": "function removeKDigits(num, k) {\n    let stack = [];\n    for (let i = 0; i < num.length; i++) {\n        let c = num[i];\n        while (k > 0 && stack.length > 0 && stack[stack.length - 1] > c) {\n            stack.pop();\n            k--;\n        }\n        stack.push(c);\n    }\n    while (k > 0) {\n        stack.pop();\n        k--;\n    }\n    let result = stack.join('').replace(/^0+/, '');\n    return result || '0';\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/403", "prompt": "A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.\n\nGiven a list of `stones`' positions (in units) in sorted **ascending order**, determine if the frog can cross the river by landing on the last stone. Initially, the frog is on the first stone and assumes the first jump must be `1` unit.\n\nIf the frog's last jump was `k` units, its next jump must be either `k - 1`, `k`, or `k + 1` units. The frog can only jump in the forward direction.\n\n**Example 1:**\n\n**Input:** stones = \\[0,1,3,5,6,8,12,17\\]\n**Output:** true\n**Explanation:** The frog can jump to the last stone by jumping 1 unit to the 2nd stone, then 2 units to the 3rd stone, then 2 units to the 4th stone, then 3 units to the 6th stone, 4 units to the 7th stone, and 5 units to the 8th stone.\n\n**Example 2:**\n\n**Input:** stones = \\[0,1,2,3,4,8,9,11\\]\n**Output:** false\n**Explanation:** There is no way to jump to the last stone as the gap between the 5th and 6th stone is too large.\n\n**Constraints:**\n\n*   `2 <= stones.length <= 2000`\n*   `0 <= stones[i] <= 231 - 1`\n*   `stones[0] == 0`\n*   `stones` is sorted in a strictly increasing order.", "entry_point": "frog_jump", "canonical_solutions": {"python": "def can_cross(stones):\n    dp = {stone: set() for stone in stones}\n    dp[0].add(0)\n\n    for stone in stones:\n        for k in dp[stone]:\n            for jump in (k - 1, k, k + 1):\n                if jump > 0 and stone + jump in dp:\n                    dp[stone + jump].add(jump)\n\n    return bool(dp[stones[-1]])", "java": "import java.util.*;\n\npublic boolean canCross(int[] stones) {\n    Map<Integer, Set<Integer>> dp = new HashMap<>();\n    for (int stone : stones)\n        dp.put(stone, new HashSet<>());\n    dp.get(0).add(0);\n\n    for (int stone : stones) {\n        for (int k : dp.get(stone)) {\n            for (int jump : new int[]{k - 1, k, k + 1}) {\n                if (jump > 0 && dp.containsKey(stone + jump))\n                    dp.get(stone + jump).add(jump);\n            }\n        }\n    }\n    return !dp.get(stones[stones.length - 1]).isEmpty();\n}", "cpp": "#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nbool canCross(vector<int>& stones) {\n    unordered_map<int, unordered_set<int>> dp;\n    int n = stones.size();\n    for (int stone : stones)\n        dp[stone] = unordered_set<int>();\n    dp[0].insert(0);\n\n    for (int stone : stones) {\n        for (int k : dp[stone]) {\n            for (int jump : {k - 1, k, k + 1}) {\n                if (jump > 0 && dp.count(stone + jump))\n                    dp[stone + jump].insert(jump);\n            }\n        }\n    }\n    return !dp[stones.back()].empty();\n}", "javascript": "function canCross(stones) {\n    const dp = new Map();\n    stones.forEach(stone => dp.set(stone, new Set()));\n    dp.get(0).add(0);\n\n    for (const stone of stones) {\n        for (const k of dp.get(stone)) {\n            for (const jump of [k - 1, k, k + 1]) {\n                if (jump > 0 && dp.has(stone + jump))\n                    dp.get(stone + jump).add(jump);\n            }\n        }\n    }\n    return dp.get(stones[stones.length - 1]).size > 0;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/404", "prompt": "Given the `root` of a binary tree, return _the sum of all left leaves._\n\nA **leaf** is a node with no children. A **left leaf** is a leaf that is the left child of another node.\n\n**Example 1:**\n\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** 24\n**Explanation:** There are two left leaves in the binary tree, with values 9 and 15 respectively.\n\n**Example 2:**\n\n**Input:** root = \\[1\\]\n**Output:** 0\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 1000]`.\n*   `-1000 <= Node.val <= 1000`", "entry_point": "sum_of_left_leaves", "canonical_solutions": {"python": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef sum_of_left_leaves(root):\n    if not root:\n        return 0\n    left_sum = 0\n    if root.left and not root.left.left and not root.left.right:\n        left_sum += root.left.val\n    return left_sum + sum_of_left_leaves(root.left) + sum_of_left_leaves(root.right)", "java": "public class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic int sumOfLeftLeaves(TreeNode root) {\n    if (root == null) return 0;\n    int sum = 0;\n    if (root.left != null && root.left.left == null && root.left.right == null) sum += root.left.val;\n    return sum + sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);\n}", "cpp": "struct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nint sumOfLeftLeaves(TreeNode* root) {\n    if (!root) return 0;\n    int sum = 0;\n    if (root->left && !root->left->left && !root->left->right) sum += root->left->val;\n    return sum + sumOfLeftLeaves(root->left) + sumOfLeftLeaves(root->right);\n}", "javascript": "class TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nfunction sumOfLeftLeaves(root) {\n    if (!root) return 0;\n    let sum = 0;\n    if (root.left && !root.left.left && !root.left.right) sum += root.left.val;\n    return sum + sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/405", "prompt": "Given an integer `num`, return _a string representing its hexadecimal representation_. For negative integers, [two's complement](https://en.wikipedia.org/wiki/Two%27s_complement) method is used.\n\nAll the letters in the answer string should be lowercase characters, and there should not be any leading zeros in the answer except for the zero itself.\n\n**Note:** You are not allowed to use any built-in library method to directly solve this problem.\n\n**Example 1:**\n\n**Input:** num = 26\n**Output:** \"1a\"\n\n**Example 2:**\n\n**Input:** num = -1\n**Output:** \"ffffffff\"\n\n**Constraints:**\n\n*   `-231 <= num <= 231 - 1`", "entry_point": "convert_a_number_to_hexadecimal", "canonical_solutions": {"python": "def to_hex(num: int) -> str:\n    if num == 0:\n        return '0'\n    hex_str = ''\n    hex_digits = '0123456789abcdef'\n    n = num & 0xffffffff\n    while n:\n        hex_str = hex_digits[n & 0xf] + hex_str\n        n >>= 4\n    return hex_str", "java": "public String toHex(int num) {\n    if (num == 0) return \"0\";\n    String hex = \"\";\n    char[] hexDigits = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\n    for (int i = 0; num != 0 && i < 8; ++i) {\n        hex = hexDigits[num & 0xf] + hex;\n        num >>>= 4;\n    }\n    return hex;\n}", "cpp": "std::string toHex(int num) {\n    if (num == 0) return \"0\";\n    std::string hex = \"\";\n    unsigned int n = num;\n    char hexDigits[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\n    while (n) {\n        hex = hexDigits[n & 15] + hex;\n        n >>= 4;\n    }\n    return hex;\n}", "javascript": "function toHex(num) {\n  if (num === 0) return '0';\n  const hexDigits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n  let hex = '';\n  let n = num >>> 0;\n  while (n) {\n    hex = hexDigits[n & 0xf] + hex;\n    n >>>= 4;\n  }\n  return hex;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/406", "prompt": "You are given an array of people, `people`, which are the attributes of some people in a queue (not necessarily in order). Each `people[i] = [hi, ki]` represents the `ith` person of height `hi` with **exactly** `ki` other people in front who have a height greater than or equal to `hi`.\n\nReconstruct and return _the queue that is represented by the input array_ `people`. The returned queue should be formatted as an array `queue`, where `queue[j] = [hj, kj]` is the attributes of the `jth` person in the queue (`queue[0]` is the person at the front of the queue).\n\n**Example 1:**\n\n**Input:** people = \\[\\[7,0\\],\\[4,4\\],\\[7,1\\],\\[5,0\\],\\[6,1\\],\\[5,2\\]\\]\n**Output:** \\[\\[5,0\\],\\[7,0\\],\\[5,2\\],\\[6,1\\],\\[4,4\\],\\[7,1\\]\\]\n**Explanation:**\nPerson 0 has height 5 with no other people taller or the same height in front.\nPerson 1 has height 7 with no other people taller or the same height in front.\nPerson 2 has height 5 with two persons taller or the same height in front, which is person 0 and 1.\nPerson 3 has height 6 with one person taller or the same height in front, which is person 1.\nPerson 4 has height 4 with four people taller or the same height in front, which are people 0, 1, 2, and 3.\nPerson 5 has height 7 with one person taller or the same height in front, which is person 1.\nHence \\[\\[5,0\\],\\[7,0\\],\\[5,2\\],\\[6,1\\],\\[4,4\\],\\[7,1\\]\\] is the reconstructed queue.\n\n**Example 2:**\n\n**Input:** people = \\[\\[6,0\\],\\[5,0\\],\\[4,0\\],\\[3,2\\],\\[2,2\\],\\[1,4\\]\\]\n**Output:** \\[\\[4,0\\],\\[5,0\\],\\[2,2\\],\\[3,2\\],\\[1,4\\],\\[6,0\\]\\]\n\n**Constraints:**\n\n*   `1 <= people.length <= 2000`\n*   `0 <= hi <= 106`\n*   `0 <= ki < people.length`\n*   It is guaranteed that the queue can be reconstructed.", "entry_point": "queue_reconstruction_by_height", "canonical_solutions": {"python": "from typing import List\n\ndef reconstructQueue(people: List[List[int]]) -> List[List[int]]:\n    people.sort(key=lambda x: (-x[0], x[1]))\n\n    result = []\n    for p in people:\n        result.insert(p[1], p)\n    return result", "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic int[][] reconstructQueue(int[][] people) {\n    Arrays.sort(people, (a, b) -> a[0] == b[0] ? a[1] - b[1] : b[0] - a[0]);\n\n    List<int[]> result = new ArrayList<>();\n    for (int[] p : people) {\n        result.add(p[1], p);\n    }\n    return result.toArray(new int[people.length][2]);\n}", "cpp": "#include <vector>\n#include <algorithm>\n\nstd::vector<std::vector<int>> reconstructQueue(std::vector<std::vector<int>>& people) {\n    std::sort(people.begin(), people.end(), [](const std::vector<int>& a, const std::vector<int>& b) {\n        return a[0] > b[0] || (a[0] == b[0] && a[1] < b[1]);\n    });\n\n    std::vector<std::vector<int>> result;\n    for (const std::vector<int>& p : people) {\n        result.insert(result.begin() + p[1], p);\n    }\n    return result;\n}", "javascript": "function reconstructQueue(people) {\n    people.sort((a, b) => {\n        return a[0] !== b[0] ? b[0] - a[0] : a[1] - b[1];\n    });\n\n    const result = [];\n    for (const p of people) {\n        result.splice(p[1], 0, p);\n    }\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/407", "prompt": "Given an `m x n` integer matrix `heightMap` representing the height of each unit cell in a 2D elevation map, return _the volume of water it can trap after raining_.\n\n**Example 1:**\n\n**Input:** heightMap = \\[\\[1,4,3,1,3,2\\],\\[3,2,1,3,2,4\\],\\[2,3,3,2,3,1\\]\\]\n**Output:** 4\n**Explanation:** After the rain, water is trapped between the blocks.\nWe have two small ponds 1 and 3 units trapped.\nThe total volume of water trapped is 4.\n\n**Example 2:**\n\n**Input:** heightMap = \\[\\[3,3,3,3,3\\],\\[3,2,2,2,3\\],\\[3,2,1,2,3\\],\\[3,2,2,2,3\\],\\[3,3,3,3,3\\]\\]\n**Output:** 10\n\n**Constraints:**\n\n*   `m == heightMap.length`\n*   `n == heightMap[i].length`\n*   `1 <= m, n <= 200`\n*   `0 <= heightMap[i][j] <= 2 * 104`", "entry_point": "trapping_rain_water_ii", "canonical_solutions": {"python": "import heapq\n\ndef trapRainWater(heightMap):\n    m, n = len(heightMap), len(heightMap[0])\n    pq = []\n    visited = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n        heapq.heappush(pq, (heightMap[i][0], i, 0))\n        heapq.heappush(pq, (heightMap[i][n - 1], i, n - 1))\n        visited[i][0] = visited[i][n - 1] = True\n\n    for i in range(1, n - 1):\n        heapq.heappush(pq, (heightMap[0][i], 0, i))\n        heapq.heappush(pq, (heightMap[m - 1][i], m - 1, i))\n        visited[0][i] = visited[m - 1][i] = True\n\n    water, maxHeight = 0, 0\n    dirs = ((0, 1), (0, -1), (1, 0), (-1, 0))\n\n    while pq:\n        h, r, c = heapq.heappop(pq)\n        maxHeight = max(maxHeight, h)\n        for dx, dy in dirs:\n            x, y = r + dx, c + dy\n            if x < 0 or x >= m or y < 0 or y >= n or visited[x][y]:\n                continue\n            if heightMap[x][y] < maxHeight:\n                water += maxHeight - heightMap[x][y]\n            heapq.heappush(pq, (heightMap[x][y], x, y))\n            visited[x][y] = True\n\n    return water", "java": "import java.util.PriorityQueue;\n\npublic int trapRainWater(int[][] heightMap) {\n    int m = heightMap.length, n = heightMap[0].length;\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);\n    boolean[][] visited = new boolean[m][n];\n\n    for (int i = 0; i < m; i++) {\n        pq.offer(new int[]{heightMap[i][0], i, 0});\n        pq.offer(new int[]{heightMap[i][n - 1], i, n - 1});\n        visited[i][0] = visited[i][n - 1] = true;\n    }\n\n    for (int i = 1; i < n - 1; i++) {\n        pq.offer(new int[]{heightMap[0][i], 0, i});\n        pq.offer(new int[]{heightMap[m - 1][i], m - 1, i});\n        visited[0][i] = visited[m - 1][i] = true;\n    }\n\n    int water = 0, maxHeight = 0;\n    int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    while (!pq.isEmpty()) {\n        int[] t = pq.poll();\n        int h = t[0], r = t[1], c = t[2];\n        maxHeight = Math.max(maxHeight, h);\n        for (int[] dir : dirs) {\n            int x = r + dir[0], y = c + dir[1];\n            if (x < 0 || x >= m || y < 0 || y >= n || visited[x][y]) continue;\n            if (heightMap[x][y] < maxHeight) water += maxHeight - heightMap[x][y];\n            pq.offer(new int[]{heightMap[x][y], x, y});\n            visited[x][y] = true;\n        }\n    }\n\n    return water;\n}", "cpp": "#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint trapRainWater(vector<vector<int>>& heightMap) {\n    int m = heightMap.size(), n = heightMap[0].size();\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    vector<vector<int>> visited(m, vector<int>(n, 0));\n\n    for (int i = 0; i < m; i++) {\n        pq.push({heightMap[i][0], i * n});\n        pq.push({heightMap[i][n - 1], i * n + n - 1});\n        visited[i][0] = visited[i][n - 1] = 1;\n    }\n\n    for (int i = 1; i < n - 1; i++) {\n        pq.push({heightMap[0][i], i});\n        pq.push({heightMap[m - 1][i], (m - 1) * n + i});\n        visited[0][i] = visited[m - 1][i] = 1;\n    }\n\n    int water = 0, maxHeight = 0;\n    vector<vector<int>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    while (!pq.empty()) {\n        auto t = pq.top(); pq.pop();\n        int h = t.first, r = t.second / n, c = t.second % n;\n        maxHeight = max(maxHeight, h);\n        for (auto dir : dirs) {\n            int x = r + dir[0], y = c + dir[1];\n            if (x < 0 || x >= m || y < 0 || y >= n || visited[x][y]) continue;\n            if (heightMap[x][y] < maxHeight) water += maxHeight - heightMap[x][y];\n            pq.push({heightMap[x][y], x * n + y});\n            visited[x][y] = 1;\n        }\n    }\n\n    return water;\n}", "javascript": "function trapRainWater(heightMap) {\n    const m = heightMap.length;\n    const n = heightMap[0].length;\n    const pq = [];\n    const visited = Array.from({ length: m }, () => Array(n).fill(false));\n\n    const comparator = (a, b) => a[0] - b[0];\n\n    for (let i = 0; i < m; i++) {\n        pq.push([heightMap[i][0], i, 0], [heightMap[i][n - 1], i, n - 1]);\n        visited[i][0] = visited[i][n - 1] = true;\n    }\n\n    for (let i = 1; i < n - 1; i++) {\n        pq.push([heightMap[0][i], 0, i], [heightMap[m - 1][i], m - 1, i]);\n        visited[0][i] = visited[m - 1][i] = true;\n    }\n\n    pq.sort(comparator);\n\n    let water = 0;\n    let maxHeight = 0;\n    const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n\n    while (pq.length) {\n        const [h, r, c] = pq.shift();\n        maxHeight = Math.max(maxHeight, h);\n        for (const [dx, dy] of dirs) {\n            const x = r + dx;\n            const y = c + dy;\n            if (x < 0 || x >= m || y < 0 || y >= n || visited[x][y]) continue;\n            if (heightMap[x][y] < maxHeight) water += maxHeight - heightMap[x][y];\n            pq.push([heightMap[x][y], x, y]);\n            pq.sort(comparator);\n            visited[x][y] = true;\n        }\n    }\n\n    return water;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/408", "prompt": "A string can be **abbreviated** by replacing any number of **non-adjacent**, **non-empty** substrings with their lengths. The lengths **should not** have leading zeros.\n\nFor example, a string such as `\"substitution \"` could be abbreviated as (but not limited to):\n\n*   `\"s10n \"` ( `\"s ubstitutio n \"`)\n*   `\"sub4u4 \"` ( `\"sub stit u tion \"`)\n*   `\"12 \"` ( `\"substitution \"`)\n*   `\"su3i1u2on \"` ( `\"su bst i t u ti on \"`)\n*   `\"substitution \"` (no substrings replaced)\n\nThe following are **not valid** abbreviations:\n\n*   `\"s55n \"` ( `\"s ubsti tutio n \"`, the replaced substrings are adjacent)\n*   `\"s010n \"` (has leading zeros)\n*   `\"s0ubstitution \"` (replaces an empty substring)\n\nGiven a string `word` and an abbreviation `abbr`, return _whether the string **matches** the given abbreviation_.\n\nA **substring** is a contiguous **non-empty** sequence of characters within a string.\n\n**Example 1:**\n\n**Input:** word =  \"internationalization \", abbr =  \"i12iz4n \"\n**Output:** true\n**Explanation:** The word  \"internationalization \" can be abbreviated as  \"i12iz4n \" ( \"i nternational iz atio n \").\n\n**Example 2:**\n\n**Input:** word =  \"apple \", abbr =  \"a2e \"\n**Output:** false\n**Explanation:** The word  \"apple \" cannot be abbreviated as  \"a2e \".\n\n**Constraints:**\n\n*   `1 <= word.length <= 20`\n*   `word` consists of only lowercase English letters.\n*   `1 <= abbr.length <= 10`\n*   `abbr` consists of lowercase English letters and digits.\n*   All the integers in `abbr` will fit in a 32-bit integer.", "entry_point": "valid_word_abbreviation", "canonical_solutions": {"python": "def validWordAbbreviation(word, abbr):\n    i, j = 0, 0\n    while i < len(word) and j < len(abbr):\n        if abbr[j].isdigit():\n            if abbr[j] == '0': return False  # leading zero\n            num = 0\n            while j < len(abbr) and abbr[j].isdigit():\n                num = num * 10 + int(abbr[j])\n                j += 1\n            i += num\n        else:\n            if word[i] != abbr[j]: return False\n            i, j = i + 1, j + 1\n    return i == len(word) and j == len(abbr)", "java": "public boolean validWordAbbreviation(String word, String abbr) {\n    int i = 0, j = 0;\n    while (i < word.length() && j < abbr.length()) {\n        if (Character.isDigit(abbr.charAt(j))) {\n            if (abbr.charAt(j) == '0') return false; // leading zero\n            int num = 0;\n            while (j < abbr.length() && Character.isDigit(abbr.charAt(j)))\n                num = num * 10 + (abbr.charAt(j++) - '0');\n            i += num;\n        } else {\n            if (word.charAt(i++) != abbr.charAt(j++)) return false;\n        }\n    }\n    return i == word.length() && j == abbr.length();\n}", "cpp": "bool validWordAbbreviation(string word, string abbr) {\n    int i = 0, j = 0;\n    while (i < word.size() && j < abbr.size()) {\n        if (isdigit(abbr[j])) {\n            if (abbr[j] == '0') return false; // leading zero\n            int num = 0;\n            while (j < abbr.size() && isdigit(abbr[j]))\n                num = num * 10 + (abbr[j++] - '0');\n            i += num;\n        } else {\n            if (word[i++] != abbr[j++]) return false;\n        }\n    }\n    return i == word.size() && j == abbr.size();\n}", "javascript": "function validWordAbbreviation(word, abbr) {\n    let i = 0, j = 0;\n    while (i < word.length && j < abbr.length) {\n        if (!isNaN(abbr[j])) {\n            if (abbr[j] === '0') return false; // leading zero\n            let num = 0;\n            while (j < abbr.length && !isNaN(abbr[j])) {\n                num = num * 10 + parseInt(abbr[j]);\n                j++;\n            }\n            i += num;\n        } else {\n            if (word[i] !== abbr[j]) return false;\n            i++; j++;\n        }\n    }\n    return i === word.length && j === abbr.length;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/409", "prompt": "Given a string `s` which consists of lowercase or uppercase letters, return _the length of the **longest palindrome**_ that can be built with those letters.\n\nLetters are **case sensitive**, for example, `\"Aa \"` is not considered a palindrome here.\n\n**Example 1:**\n\n**Input:** s =  \"abccccdd \"\n**Output:** 7\n**Explanation:** One longest palindrome that can be built is  \"dccaccd \", whose length is 7.\n\n**Example 2:**\n\n**Input:** s =  \"a \"\n**Output:** 1\n**Explanation:** The longest palindrome that can be built is  \"a \", whose length is 1.\n\n**Constraints:**\n\n*   `1 <= s.length <= 2000`\n*   `s` consists of lowercase **and/or** uppercase English letters only.", "entry_point": "longest_palindrome", "canonical_solutions": {"python": "def longestPalindrome(s: str) -> int:\n    charCount = [0] * 128\n    result = 0\n    for c in s:\n        charCount[ord(c)] += 1\n    for count in charCount:\n        result += count // 2 * 2\n        if result % 2 == 0 and count % 2 == 1:\n            result += 1\n    return result", "java": "public int longestPalindrome(String s) {\n    int[] charCount = new int[128];\n    int result = 0;\n    for (char c : s.toCharArray())\n        charCount[c]++;\n    for (int count : charCount) {\n        result += count / 2 * 2;\n        if (result % 2 == 0 && count % 2 == 1)\n            result++;\n    }\n    return result;\n}", "cpp": "int longestPalindrome(string s) {\n    int charCount[128] = {0};\n    int result = 0;\n    for (char c : s)\n        charCount[c]++;\n    for (int count : charCount) {\n        result += count / 2 * 2;\n        if (result % 2 == 0 && count % 2 == 1)\n            result++;\n    }\n    return result;\n}", "javascript": "function longestPalindrome(s) {\n    let charCount = new Array(128).fill(0);\n    let result = 0;\n    for (let c of s)\n        charCount[c.charCodeAt(0)]++;\n    for (let count of charCount) {\n        result += Math.floor(count / 2) * 2;\n        if (result % 2 === 0 && count % 2 === 1)\n            result++;\n    }\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/410", "prompt": "Given an integer array `nums` and an integer `k`, split `nums` into `k` non-empty subarrays such that the largest sum of any subarray is **minimized**.\n\nReturn _the minimized largest sum of the split_.\n\nA **subarray** is a contiguous part of the array.\n\n**Example 1:**\n\n**Input:** nums = \\[7,2,5,10,8\\], k = 2\n**Output:** 18\n**Explanation:** There are four ways to split nums into two subarrays.\nThe best way is to split it into \\[7,2,5\\] and \\[10,8\\], where the largest sum among the two subarrays is only 18.\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,3,4,5\\], k = 2\n**Output:** 9\n**Explanation:** There are four ways to split nums into two subarrays.\nThe best way is to split it into \\[1,2,3\\] and \\[4,5\\], where the largest sum among the two subarrays is only 9.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `0 <= nums[i] <= 106`\n*   `1 <= k <= min(50, nums.length)`", "entry_point": "split_array_largest_sum", "canonical_solutions": {"python": "def splitArray(nums, m):\n    left, right = max(nums), sum(nums)\n\n    while left < right:\n        mid = (left + right) // 2\n        count, cur_sum = 1, 0\n        for num in nums:\n            cur_sum += num\n            if cur_sum > mid:\n                cur_sum = num\n                count += 1\n\n        if count > m:\n            left = mid + 1\n        else:\n            right = mid\n\n    return left", "java": "public int splitArray(int[] nums, int m) {\n    long left = 0, right = 0;\n    for (int num : nums) {\n        left = Math.max(left, num);\n        right += num;\n    }\n\n    while (left < right) {\n        long mid = (left + right) / 2;\n        int count = 1;\n        long curSum = 0;\n        for (int num : nums) {\n            curSum += num;\n            if (curSum > mid) {\n                curSum = num;\n                count++;\n            }\n        }\n\n        if (count > m) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n\n    return (int)left;\n}", "cpp": "int splitArray(vector<int>& nums, int m) {\n    long long left = 0, right = 0;\n    for (int num : nums) {\n        left = max(left, (long long)num);\n        right += num;\n    }\n\n    while (left < right) {\n        long long mid = (left + right) / 2;\n        int count = 1;\n        long long curSum = 0;\n        for (int num : nums) {\n            curSum += num;\n            if (curSum > mid) {\n                curSum = num;\n                count++;\n            }\n        }\n\n        if (count > m) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n\n    return (int)left;\n}", "javascript": "function splitArray(nums, m) {\n    let left = 0, right = 0;\n    for (let num of nums) {\n        left = Math.max(left, num);\n        right += num;\n    }\n\n    while (left < right) {\n        let mid = Math.floor((left + right) / 2);\n        let count = 1;\n        let curSum = 0;\n        for (let num of nums) {\n            curSum += num;\n            if (curSum > mid) {\n                curSum = num;\n                count++;\n            }\n        }\n\n        if (count > m) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n\n    return left;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/411", "prompt": "A string can be **abbreviated** by replacing any number of **non-adjacent** substrings with their lengths. For example, a string such as `\"substitution \"` could be abbreviated as (but not limited to):\n\n*   `\"s10n \"` ( `\"s ubstitutio n \"`)\n*   `\"sub4u4 \"` ( `\"sub stit u tion \"`)\n*   `\"12 \"` ( `\"substitution \"`)\n*   `\"su3i1u2on \"` ( `\"su bst i t u ti on \"`)\n*   `\"substitution \"` (no substrings replaced)\n\nNote that `\"s55n \"` ( `\"s ubsti tutio n \"`) is not a valid abbreviation of `\"substitution \"` because the replaced substrings are adjacent.\n\nThe **length** of an abbreviation is the number of letters that were not replaced plus the number of substrings that were replaced. For example, the abbreviation `\"s10n \"` has a length of `3` (`2` letters + `1` substring) and `\"su3i1u2on \"` has a length of `9` (`6` letters + `3` substrings).\n\nGiven a target string `target` and an array of strings `dictionary`, return _an **abbreviation** of_ `target` _with the **shortest possible length** such that it is **not an abbreviation** of **any** string in_ `dictionary`_. If there are multiple shortest abbreviations, return any of them_.\n\n**Example 1:**\n\n**Input:** target =  \"apple \", dictionary = \\[ \"blade \"\\]\n**Output:**  \"a4 \"\n**Explanation:** The shortest abbreviation of  \"apple \" is  \"5 \", but this is also an abbreviation of  \"blade \".\nThe next shortest abbreviations are  \"a4 \" and  \"4e \".  \"4e \" is an abbreviation of blade while  \"a4 \" is not.\nHence, return  \"a4 \".\n\n**Example 2:**\n\n**Input:** target =  \"apple \", dictionary = \\[ \"blade \", \"plain \", \"amber \"\\]\n**Output:**  \"1p3 \"\n**Explanation:**  \"5 \" is an abbreviation of both  \"apple \" but also every word in the dictionary.\n \"a4 \" is an abbreviation of  \"apple \" but also  \"amber \".\n \"4e \" is an abbreviation of  \"apple \" but also  \"blade \".\n \"1p3 \",  \"2p2 \", and  \"3l1 \" are the next shortest abbreviations of  \"apple \".\nSince none of them are abbreviations of words in the dictionary, returning any of them is correct.\n\n**Constraints:**\n\n*   `m == target.length`\n*   `n == dictionary.length`\n*   `1 <= m <= 21`\n*   `0 <= n <= 1000`\n*   `1 <= dictionary[i].length <= 100`\n*   `log2(n) + m <= 21` if `n > 0`\n*   `target` and `dictionary[i]` consist of lowercase English letters.\n*   `dictionary` does not contain `target`.", "entry_point": "minimum_unique_word_abbreviation", "canonical_solutions": {"python": "def abbreviate(s, k, i):\n    if i == len(s):\n        return str(k) if k > 0 else \"\"\n    if k == 0:\n        return s[i:] + (abbreviate(s, 1, i + 1) if i + 1 < len(s) else \"\")\n    return str(k) + s[i] + (abbreviate(s, 1, i + 1) if i + 1 < len(s) else \"\")\n\ndef is_abbreviation(target, word):\n    i, j = 0, 0\n    while i < len(target) and j < len(word):\n        if target[i] == word[j]:\n            i, j = i + 1, j + 1\n        elif target[i].isdigit():\n            k = 0\n            while i < len(target) and target[i].isdigit():\n                k = k * 10 + int(target[i])\n                i += 1\n            j += k\n        else:\n            return False\n    return i == len(target) and j == len(word)\n\ndef min_abbreviation(target, dictionary):\n    ans = target\n    for k in range(0, len(target) + 1):\n        for i in range(0, len(target) - k + 1):\n            current = abbreviate(target, k, i)\n            if len(current) < len(ans):\n                valid = True\n                for word in dictionary:\n                    if is_abbreviation(current, word):\n                        valid = False\n                        break\n                if valid:\n                    ans = current\n    return ans", "java": "import java.util.List;\n\npublic class Solution {\n    private static String abbreviate(String s, int k, int i) {\n        if (i == s.length()) {\n            return (k > 0) ? String.valueOf(k) : \"\";\n        }\n        if (k == 0) {\n            return s.substring(i) + (i + 1 < s.length() ? abbreviate(s, 1, i + 1) : \"\");\n        }\n        return String.valueOf(k) + s.charAt(i) + (i + 1 < s.length() ? abbreviate(s, 1, i + 1) : \"\");\n    }\n\n    private static boolean isAbbreviation(String target, String word) {\n        int i = 0, j = 0;\n        while (i < target.length() && j < word.length()) {\n            if (target.charAt(i) == word.charAt(j)) {\n                i++; j++;\n            } else if (Character.isDigit(target.charAt(i))) {\n                int k = 0;\n                while (i < target.length() && Character.isDigit(target.charAt(i))) {\n                    k = k * 10 + target.charAt(i++) - '0';\n                }\n                j += k;\n            } else {\n                return false;\n            }\n        }\n        return (i == target.length() && j == word.length());\n    }\n\n    public static String minAbbreviation(String target, List<String> dictionary) {\n        String ans = target;\n        for (int k = 0; k <= target.length(); k++) {\n            for (int i = 0; i <= target.length() - k; i++) {\n                String current = abbreviate(target, k, i);\n                if (current.length() < ans.length()) {\n                    boolean valid = true;\n                    for (String word : dictionary) {\n                        if (isAbbreviation(current, word)) {\n                            valid = false;\n                            break;\n                        }\n                    }\n                    if (valid) {\n                        ans = current;\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n}", "cpp": "#include <string>\n#include <vector>\n\nstd::string abbreviate(const std::string& s, int k, int i) {\n    if (i == s.length()) {\n        return (k > 0) ? std::to_string(k) : \"\";\n    }\n    if (k == 0) {\n        return s.substr(i) + (i + 1 < s.length() ? abbreviate(s, 1, i + 1) : \"\");\n    }\n    return std::to_string(k) + s[i] + (i + 1 < s.length() ? abbreviate(s, 1, i + 1) : \"\");\n}\n\nbool isAbbreviation(const std::string& target, const std::string& word) {\n    int i = 0, j = 0;\n    while (i < target.length() && j < word.length()) {\n        if (target[i] == word[j]) {\n            i++; j++;\n        } else if (isdigit(target[i])) {\n            int k = 0;\n            while (i < target.length() && isdigit(target[i])) {\n                k = k * 10 + target[i++] - '0';\n            }\n            j += k;\n        } else {\n            return false;\n        }\n    }\n    return (i == target.length() && j == word.length());\n}\n\nstd::string minAbbreviation(std::string target, std::vector<std::string>& dictionary) {\n    std::string ans = target;\n    for (int k = 0; k <= target.length(); k++) {\n        for (int i = 0; i <= target.length() - k; i++) {\n            std::string current = abbreviate(target, k, i);\n            if (current.length() < ans.length()) {\n                bool valid = true;\n                for (const std::string& word : dictionary) {\n                    if (isAbbreviation(current, word)) {\n                        valid = false;\n                        break;\n                    }\n                }\n                if (valid) {\n                    ans = current;\n                }\n            }\n        }\n    }\n    return ans;\n}", "javascript": "function abbreviate(s, k, i) {\n    if (i === s.length) {\n        return (k > 0) ? String(k) : \"\";\n    }\n    if (k === 0) {\n        return s.slice(i) + (i + 1 < s.length ? abbreviate(s, 1, i + 1) : \"\");\n    }\n    return String(k) + s[i] + (i + 1 < s.length ? abbreviate(s, 1, i + 1) : \"\");\n}\n\nfunction isAbbreviation(target, word) {\n    let i = 0, j = 0;\n    while (i < target.length && j < word.length) {\n        if (target[i] === word[j]) {\n            i++; j++;\n        } else if (target[i] >= '0' && target[i] <= '9') {\n            let k = 0;\n            while (i < target.length && target[i] >= '0' && target[i] <= '9') {\n                k = k * 10 + parseInt(target[i++]);\n            }\n            j += k;\n        } else {\n            return false;\n        }\n    }\n    return (i === target.length && j === word.length);\n}\n\nfunction minAbbreviation(target, dictionary) {\n    let ans = target;\n    for (let k = 0; k <= target.length; k++) {\n        for (let i = 0; i <= target.length - k; i++) {\n            let current = abbreviate(target, k, i);\n            if (current.length < ans.length) {\n                let valid = true;\n                for (const word of dictionary) {\n                    if (isAbbreviation(current, word)) {\n                        valid = false;\n                        break;\n                    }\n                }\n                if (valid) {\n                    ans = current;\n                }\n            }\n        }\n    }\n    return ans;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Hard'\n}"}
{"task_id": "LeetCode/412", "prompt": "Given an integer `n`, return _a string array_ `answer` _(**1-indexed**) where_:\n\n*   `answer[i] == \"FizzBuzz \"` if `i` is divisible by `3` and `5`.\n*   `answer[i] == \"Fizz \"` if `i` is divisible by `3`.\n*   `answer[i] == \"Buzz \"` if `i` is divisible by `5`.\n*   `answer[i] == i` (as a string) if none of the above conditions are true.\n\n**Example 1:**\n\n**Input:** n = 3\n**Output:** \\[\"1\",\"2\",\"Fizz\"\\]\n\n**Example 2:**\n\n**Input:** n = 5\n**Output:** \\[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"\\]\n\n**Example 3:**\n\n**Input:** n = 15\n**Output:** \\[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"\\]\n\n**Constraints:**\n\n*   `1 <= n <= 104`", "entry_point": "fizz_buzz", "canonical_solutions": {"python": "def fizzBuzz(n):\n    result = []\n    for i in range(1, n + 1):\n        if i % 15 == 0:\n            result.append(\"FizzBuzz\")\n        elif i % 3 == 0:\n            result.append(\"Fizz\")\n        elif i % 5 == 0:\n            result.append(\"Buzz\")\n        else:\n            result.append(str(i))\n    return result", "java": "import java.util.ArrayList;\n\npublic ArrayList<String> fizzBuzz(int n) {\n    ArrayList<String> result = new ArrayList<>();\n    for (int i = 1; i <= n; i++) {\n        if (i % 15 == 0) result.add(\"FizzBuzz\");\n        else if (i % 3 == 0) result.add(\"Fizz\");\n        else if (i % 5 == 0) result.add(\"Buzz\");\n        else result.add(Integer.toString(i));\n    }\n    return result;\n}", "cpp": "#include <vector>\n#include <string>\n\nstd::vector<std::string> fizzBuzz(int n) {\n    std::vector<std::string> result(n);\n    for(int i = 1; i <= n; ++i) {\n        if (i % 15 == 0) result[i - 1] = \"FizzBuzz\";\n        else if (i % 3 == 0) result[i - 1] = \"Fizz\";\n        else if (i % 5 == 0) result[i - 1] = \"Buzz\";\n        else result[i - 1] = std::to_string(i);\n    }\n    return result;\n}", "javascript": "function fizzBuzz(n) {\n    let result = [];\n    for (let i = 1; i <= n; i++) {\n        if (i % 15 === 0) result.push(\"FizzBuzz\");\n        else if (i % 3 === 0) result.push(\"Fizz\");\n        else if (i % 5 === 0) result.push(\"Buzz\");\n        else result.push(String(i));\n    }\n    return result;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/413", "prompt": "An integer array is called arithmetic if it consists of **at least three elements** and if the difference between any two consecutive elements is the same.\n\n*   For example, `[1,3,5,7,9]`, `[7,7,7,7]`, and `[3,-1,-5,-9]` are arithmetic sequences.\n\nGiven an integer array `nums`, return _the number of arithmetic **subarrays** of_ `nums`.\n\nA **subarray** is a contiguous subsequence of the array.\n\n**Example 1:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** 3\n**Explanation:** We have 3 arithmetic slices in nums: \\[1, 2, 3\\], \\[2, 3, 4\\] and \\[1,2,3,4\\] itself.\n\n**Example 2:**\n\n**Input:** nums = \\[1\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= nums.length <= 5000`\n*   `-1000 <= nums[i] <= 1000`", "entry_point": "arithmetic_slices", "canonical_solutions": {"python": "def numberOfArithmeticSlices(nums):\n    n = len(nums)\n    count, cur = 0, 0\n    for i in range(2, n):\n        if nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]:\n            cur += 1\n            count += cur\n        else:\n            cur = 0\n    return count", "java": "public int numberOfArithmeticSlices(int[] nums) {\n    int n = nums.length, count = 0, cur = 0;\n    for (int i = 2; i < n; ++i) {\n        if (nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]) {\n            cur++;\n            count += cur;\n        } else {\n            cur = 0;\n        }\n    }\n    return count;\n}", "cpp": "int numberOfArithmeticSlices(vector<int>& nums) {\n    int n = nums.size(), count = 0, cur = 0;\n    for (int i = 2; i < n; ++i) {\n        if (nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]) {\n            cur++;\n            count += cur;\n        } else {\n            cur = 0;\n        }\n    }\n    return count;\n}", "javascript": "function numberOfArithmeticSlices(nums) {\n    let n = nums.length, count = 0, cur = 0;\n    for (let i = 2; i < n; ++i) {\n        if (nums[i] - nums[i - 1] === nums[i - 1] - nums[i - 2]) {\n            cur++;\n            count += cur;\n        } else {\n            cur = 0;\n        }\n    }\n    return count;\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
{"task_id": "LeetCode/414", "prompt": "Given an integer array `nums`, return _the **third distinct maximum** number in this array. If the third maximum does not exist, return the **maximum** number_.\n\n**Example 1:**\n\n**Input:** nums = \\[3,2,1\\]\n**Output:** 1\n**Explanation:**\nThe first distinct maximum is 3.\nThe second distinct maximum is 2.\nThe third distinct maximum is 1.\n\n**Example 2:**\n\n**Input:** nums = \\[1,2\\]\n**Output:** 2\n**Explanation:**\nThe first distinct maximum is 2.\nThe second distinct maximum is 1.\nThe third distinct maximum does not exist, so the maximum (2) is returned instead.\n\n**Example 3:**\n\n**Input:** nums = \\[2,2,3,1\\]\n**Output:** 1\n**Explanation:**\nThe first distinct maximum is 3.\nThe second distinct maximum is 2 (both 2's are counted together since they have the same value).\nThe third distinct maximum is 1.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-231 <= nums[i] <= 231 - 1`\n\n**Follow up:** Can you find an `O(n)` solution?", "entry_point": "third_maximum_number", "canonical_solutions": {"python": "def third_max(nums):\n    top3 = set()\n    for num in nums:\n        top3.add(num)\n        if len(top3) > 3:\n            top3.remove(min(top3))\n    return min(top3) if len(top3) == 3 else max(top3)", "java": "import java.util.TreeSet;\n\npublic int thirdMax(int[] nums) {\n    TreeSet<Integer> top3 = new TreeSet<>();\n    for (int num : nums) {\n        top3.add(num);\n        if (top3.size() > 3) {\n            top3.remove(top3.first());\n        }\n    }\n    return top3.size() == 3 ? top3.first() : top3.last();\n}", "cpp": "#include <set>\n\nint thirdMax(vector<int>& nums) {\n    set<int> top3;\n    for (int num : nums) {\n        top3.insert(num);\n        if (top3.size() > 3) {\n            top3.erase(top3.begin());\n        }\n    }\n    return top3.size() == 3 ? *top3.begin() : *top3.rbegin();\n}", "javascript": "function thirdMax(nums) {\n    const top3 = new Set();\n    for (const num of nums) {\n        top3.add(num);\n        if (top3.size > 3) {\n            top3.delete(Math.min(...top3));\n        }\n    }\n    return top3.size === 3 ? Math.min(...top3) : Math.max(...top3);\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/415", "prompt": "Given two non-negative integers, `num1` and `num2` represented as string, return _the sum of_ `num1` _and_ `num2` _as a string_.\n\nYou must solve the problem without using any built-in library for handling large integers (such as `BigInteger`). You must also not convert the inputs to integers directly.\n\n**Example 1:**\n\n**Input:** num1 =  \"11 \", num2 =  \"123 \"\n**Output:**  \"134 \"\n\n**Example 2:**\n\n**Input:** num1 =  \"456 \", num2 =  \"77 \"\n**Output:**  \"533 \"\n\n**Example 3:**\n\n**Input:** num1 =  \"0 \", num2 =  \"0 \"\n**Output:**  \"0 \"\n\n**Constraints:**\n\n*   `1 <= num1.length, num2.length <= 104`\n*   `num1` and `num2` consist of only digits.\n*   `num1` and `num2` don't have any leading zeros except for the zero itself.", "entry_point": "add_strings", "canonical_solutions": {"python": "def addStrings(num1: str, num2: str) -> str:\n    i, j, carry, result = len(num1) - 1, len(num2) - 1, 0, []\n\n    while i >= 0 or j >= 0 or carry:\n        sum = carry\n\n        if i >= 0:\n            sum += int(num1[i])\n            i -= 1\n        if j >= 0:\n            sum += int(num2[j])\n            j -= 1\n\n        carry = sum // 10\n        result.append(str(sum % 10))\n\n    return ''.join(result[::-1])", "java": "public String addStrings(String num1, String num2) {\n    int i = num1.length() - 1, j = num2.length() - 1, carry = 0;\n    StringBuilder result = new StringBuilder();\n\n    while (i >= 0 || j >= 0 || carry != 0) {\n        int sum = carry;\n\n        if (i >= 0) {\n            sum += num1.charAt(i) - '0';\n            --i;\n        }\n        if (j >= 0) {\n            sum += num2.charAt(j) - '0';\n            --j;\n        }\n\n        carry = sum / 10;\n        result.append(sum % 10);\n    }\n\n    return result.reverse().toString();\n}", "cpp": "std::string addStrings(std::string num1, std::string num2) {\n    int i = num1.size() - 1, j = num2.size() - 1, carry = 0;\n    std::string result;\n\n    while (i >= 0 || j >= 0 || carry) {\n        int sum = carry;\n\n        if (i >= 0) {\n            sum += num1[i] - '0';\n            --i;\n        }\n        if (j >= 0) {\n            sum += num2[j] - '0';\n            --j;\n        }\n\n        carry = sum / 10;\n        result.push_back(sum % 10 + '0');\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}", "javascript": "function addStrings(num1, num2) {\n    let i = num1.length - 1, j = num2.length - 1, carry = 0;\n    let result = [];\n\n    while (i >= 0 || j >= 0 || carry) {\n        let sum = carry;\n\n        if (i >= 0) {\n            sum += parseInt(num1[i]);\n            --i;\n        }\n        if (j >= 0) {\n            sum += parseInt(num2[j]);\n            --j;\n        }\n\n        carry = Math.floor(sum / 10);\n        result.push(sum % 10);\n    }\n\n    return result.reverse().join('');\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Easy'\n}"}
{"task_id": "LeetCode/416", "prompt": "Given an integer array `nums`, return `true` _if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or_ `false` _otherwise_.\n\n**Example 1:**\n\n**Input:** nums = \\[1,5,11,5\\]\n**Output:** true\n**Explanation:** The array can be partitioned as \\[1, 5, 5\\] and \\[11\\].\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,3,5\\]\n**Output:** false\n**Explanation:** The array cannot be partitioned into equal sum subsets.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 200`\n*   `1 <= nums[i] <= 100`", "entry_point": "partition_equal_subset_sum", "canonical_solutions": {"python": "def canPartition(nums):\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n    \n    target = total_sum // 2\n    dp = [False] * (target + 1)\n    dp[0] = True\n    \n    for num in nums:\n        for i in range(target, num - 1, -1):\n            dp[i] = dp[i] or dp[i - num]\n    \n    return dp[target]", "java": "public boolean canPartition(int[] nums) {\n    int sum = 0;\n    for (int num : nums) sum += num;\n    \n    if (sum % 2 != 0) return false;\n    \n    int target = sum / 2;\n    boolean[] dp = new boolean[target + 1];\n    dp[0] = true;\n    \n    for (int num : nums) {\n        for (int i = target; i >= num; i--) {\n            dp[i] = dp[i] || dp[i - num];\n        }\n    }\n    return dp[target];\n}", "cpp": "#include <vector>\nusing namespace std;\n\nbool canPartition(vector<int>& nums) {\n    int sum = 0;\n    for (int num : nums) sum += num;\n    \n    if (sum % 2 != 0) return false;\n    \n    int target = sum / 2;\n    vector<bool> dp(target + 1, false);\n    dp[0] = true;\n    \n    for (int num : nums) {\n        for (int i = target; i >= num; i--) {\n            dp[i] = dp[i] || dp[i - num];\n        }\n    }\n    return dp[target];\n}", "javascript": "function canPartition(nums) {\n    const sum = nums.reduce((a, b) => a + b);\n    if (sum % 2 !== 0) return false;\n\n    const target = sum / 2;\n    const dp = new Array(target + 1).fill(false);\n    dp[0] = true;\n\n    for (const num of nums) {\n        for (let i = target; i >= num; i--) {\n            dp[i] = dp[i] || dp[i - num];\n        }\n    }\n    return dp[target];\n}"}, "test": "\n\nMETADATA = {\n    'source': 'LeetCode',\n    'difficulty': 'Medium'\n}"}
